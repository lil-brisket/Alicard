
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `EncounterEnemy` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model EncounterEnemy
 * 
 */
export type EncounterEnemyModel = runtime.Types.Result.DefaultSelection<Prisma.$EncounterEnemyPayload>

export type AggregateEncounterEnemy = {
  _count: EncounterEnemyCountAggregateOutputType | null
  _avg: EncounterEnemyAvgAggregateOutputType | null
  _sum: EncounterEnemySumAggregateOutputType | null
  _min: EncounterEnemyMinAggregateOutputType | null
  _max: EncounterEnemyMaxAggregateOutputType | null
}

export type EncounterEnemyAvgAggregateOutputType = {
  weight: number | null
}

export type EncounterEnemySumAggregateOutputType = {
  weight: number | null
}

export type EncounterEnemyMinAggregateOutputType = {
  id: string | null
  encounterId: string | null
  enemyTemplateId: string | null
  weight: number | null
  createdAt: Date | null
}

export type EncounterEnemyMaxAggregateOutputType = {
  id: string | null
  encounterId: string | null
  enemyTemplateId: string | null
  weight: number | null
  createdAt: Date | null
}

export type EncounterEnemyCountAggregateOutputType = {
  id: number
  encounterId: number
  enemyTemplateId: number
  weight: number
  createdAt: number
  _all: number
}


export type EncounterEnemyAvgAggregateInputType = {
  weight?: true
}

export type EncounterEnemySumAggregateInputType = {
  weight?: true
}

export type EncounterEnemyMinAggregateInputType = {
  id?: true
  encounterId?: true
  enemyTemplateId?: true
  weight?: true
  createdAt?: true
}

export type EncounterEnemyMaxAggregateInputType = {
  id?: true
  encounterId?: true
  enemyTemplateId?: true
  weight?: true
  createdAt?: true
}

export type EncounterEnemyCountAggregateInputType = {
  id?: true
  encounterId?: true
  enemyTemplateId?: true
  weight?: true
  createdAt?: true
  _all?: true
}

export type EncounterEnemyAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EncounterEnemy to aggregate.
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EncounterEnemies to fetch.
   */
  orderBy?: Prisma.EncounterEnemyOrderByWithRelationInput | Prisma.EncounterEnemyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.EncounterEnemyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EncounterEnemies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EncounterEnemies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned EncounterEnemies
  **/
  _count?: true | EncounterEnemyCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: EncounterEnemyAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: EncounterEnemySumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: EncounterEnemyMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: EncounterEnemyMaxAggregateInputType
}

export type GetEncounterEnemyAggregateType<T extends EncounterEnemyAggregateArgs> = {
      [P in keyof T & keyof AggregateEncounterEnemy]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateEncounterEnemy[P]>
    : Prisma.GetScalarType<T[P], AggregateEncounterEnemy[P]>
}




export type EncounterEnemyGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.EncounterEnemyWhereInput
  orderBy?: Prisma.EncounterEnemyOrderByWithAggregationInput | Prisma.EncounterEnemyOrderByWithAggregationInput[]
  by: Prisma.EncounterEnemyScalarFieldEnum[] | Prisma.EncounterEnemyScalarFieldEnum
  having?: Prisma.EncounterEnemyScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: EncounterEnemyCountAggregateInputType | true
  _avg?: EncounterEnemyAvgAggregateInputType
  _sum?: EncounterEnemySumAggregateInputType
  _min?: EncounterEnemyMinAggregateInputType
  _max?: EncounterEnemyMaxAggregateInputType
}

export type EncounterEnemyGroupByOutputType = {
  id: string
  encounterId: string
  enemyTemplateId: string
  weight: number
  createdAt: Date
  _count: EncounterEnemyCountAggregateOutputType | null
  _avg: EncounterEnemyAvgAggregateOutputType | null
  _sum: EncounterEnemySumAggregateOutputType | null
  _min: EncounterEnemyMinAggregateOutputType | null
  _max: EncounterEnemyMaxAggregateOutputType | null
}

type GetEncounterEnemyGroupByPayload<T extends EncounterEnemyGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<EncounterEnemyGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof EncounterEnemyGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], EncounterEnemyGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], EncounterEnemyGroupByOutputType[P]>
      }
    >
  >



export type EncounterEnemyWhereInput = {
  AND?: Prisma.EncounterEnemyWhereInput | Prisma.EncounterEnemyWhereInput[]
  OR?: Prisma.EncounterEnemyWhereInput[]
  NOT?: Prisma.EncounterEnemyWhereInput | Prisma.EncounterEnemyWhereInput[]
  id?: Prisma.StringFilter<"EncounterEnemy"> | string
  encounterId?: Prisma.StringFilter<"EncounterEnemy"> | string
  enemyTemplateId?: Prisma.StringFilter<"EncounterEnemy"> | string
  weight?: Prisma.IntFilter<"EncounterEnemy"> | number
  createdAt?: Prisma.DateTimeFilter<"EncounterEnemy"> | Date | string
  encounter?: Prisma.XOR<Prisma.EncounterDefinitionScalarRelationFilter, Prisma.EncounterDefinitionWhereInput>
  enemyTemplate?: Prisma.XOR<Prisma.EnemyTemplateScalarRelationFilter, Prisma.EnemyTemplateWhereInput>
}

export type EncounterEnemyOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  encounterId?: Prisma.SortOrder
  enemyTemplateId?: Prisma.SortOrder
  weight?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  encounter?: Prisma.EncounterDefinitionOrderByWithRelationInput
  enemyTemplate?: Prisma.EnemyTemplateOrderByWithRelationInput
}

export type EncounterEnemyWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.EncounterEnemyWhereInput | Prisma.EncounterEnemyWhereInput[]
  OR?: Prisma.EncounterEnemyWhereInput[]
  NOT?: Prisma.EncounterEnemyWhereInput | Prisma.EncounterEnemyWhereInput[]
  encounterId?: Prisma.StringFilter<"EncounterEnemy"> | string
  enemyTemplateId?: Prisma.StringFilter<"EncounterEnemy"> | string
  weight?: Prisma.IntFilter<"EncounterEnemy"> | number
  createdAt?: Prisma.DateTimeFilter<"EncounterEnemy"> | Date | string
  encounter?: Prisma.XOR<Prisma.EncounterDefinitionScalarRelationFilter, Prisma.EncounterDefinitionWhereInput>
  enemyTemplate?: Prisma.XOR<Prisma.EnemyTemplateScalarRelationFilter, Prisma.EnemyTemplateWhereInput>
}, "id">

export type EncounterEnemyOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  encounterId?: Prisma.SortOrder
  enemyTemplateId?: Prisma.SortOrder
  weight?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.EncounterEnemyCountOrderByAggregateInput
  _avg?: Prisma.EncounterEnemyAvgOrderByAggregateInput
  _max?: Prisma.EncounterEnemyMaxOrderByAggregateInput
  _min?: Prisma.EncounterEnemyMinOrderByAggregateInput
  _sum?: Prisma.EncounterEnemySumOrderByAggregateInput
}

export type EncounterEnemyScalarWhereWithAggregatesInput = {
  AND?: Prisma.EncounterEnemyScalarWhereWithAggregatesInput | Prisma.EncounterEnemyScalarWhereWithAggregatesInput[]
  OR?: Prisma.EncounterEnemyScalarWhereWithAggregatesInput[]
  NOT?: Prisma.EncounterEnemyScalarWhereWithAggregatesInput | Prisma.EncounterEnemyScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"EncounterEnemy"> | string
  encounterId?: Prisma.StringWithAggregatesFilter<"EncounterEnemy"> | string
  enemyTemplateId?: Prisma.StringWithAggregatesFilter<"EncounterEnemy"> | string
  weight?: Prisma.IntWithAggregatesFilter<"EncounterEnemy"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"EncounterEnemy"> | Date | string
}

export type EncounterEnemyCreateInput = {
  id?: string
  weight?: number
  createdAt?: Date | string
  encounter: Prisma.EncounterDefinitionCreateNestedOneWithoutEnemiesInput
  enemyTemplate: Prisma.EnemyTemplateCreateNestedOneWithoutEncountersInput
}

export type EncounterEnemyUncheckedCreateInput = {
  id?: string
  encounterId: string
  enemyTemplateId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  encounter?: Prisma.EncounterDefinitionUpdateOneRequiredWithoutEnemiesNestedInput
  enemyTemplate?: Prisma.EnemyTemplateUpdateOneRequiredWithoutEncountersNestedInput
}

export type EncounterEnemyUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string
  enemyTemplateId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyCreateManyInput = {
  id?: string
  encounterId: string
  enemyTemplateId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string
  enemyTemplateId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyListRelationFilter = {
  every?: Prisma.EncounterEnemyWhereInput
  some?: Prisma.EncounterEnemyWhereInput
  none?: Prisma.EncounterEnemyWhereInput
}

export type EncounterEnemyOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type EncounterEnemyCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  encounterId?: Prisma.SortOrder
  enemyTemplateId?: Prisma.SortOrder
  weight?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type EncounterEnemyAvgOrderByAggregateInput = {
  weight?: Prisma.SortOrder
}

export type EncounterEnemyMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  encounterId?: Prisma.SortOrder
  enemyTemplateId?: Prisma.SortOrder
  weight?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type EncounterEnemyMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  encounterId?: Prisma.SortOrder
  enemyTemplateId?: Prisma.SortOrder
  weight?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type EncounterEnemySumOrderByAggregateInput = {
  weight?: Prisma.SortOrder
}

export type EncounterEnemyCreateNestedManyWithoutEnemyTemplateInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput> | Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput | Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEnemyTemplateInputEnvelope
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
}

export type EncounterEnemyUncheckedCreateNestedManyWithoutEnemyTemplateInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput> | Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput | Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEnemyTemplateInputEnvelope
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
}

export type EncounterEnemyUpdateManyWithoutEnemyTemplateNestedInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput> | Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput | Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput[]
  upsert?: Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEnemyTemplateInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEnemyTemplateInputEnvelope
  set?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  disconnect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  delete?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  update?: Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEnemyTemplateInput[]
  updateMany?: Prisma.EncounterEnemyUpdateManyWithWhereWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpdateManyWithWhereWithoutEnemyTemplateInput[]
  deleteMany?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
}

export type EncounterEnemyUncheckedUpdateManyWithoutEnemyTemplateNestedInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput> | Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput | Prisma.EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput[]
  upsert?: Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEnemyTemplateInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEnemyTemplateInputEnvelope
  set?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  disconnect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  delete?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  update?: Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEnemyTemplateInput[]
  updateMany?: Prisma.EncounterEnemyUpdateManyWithWhereWithoutEnemyTemplateInput | Prisma.EncounterEnemyUpdateManyWithWhereWithoutEnemyTemplateInput[]
  deleteMany?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
}

export type EncounterEnemyCreateNestedManyWithoutEncounterInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput> | Prisma.EncounterEnemyCreateWithoutEncounterInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput | Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEncounterInputEnvelope
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
}

export type EncounterEnemyUncheckedCreateNestedManyWithoutEncounterInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput> | Prisma.EncounterEnemyCreateWithoutEncounterInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput | Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEncounterInputEnvelope
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
}

export type EncounterEnemyUpdateManyWithoutEncounterNestedInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput> | Prisma.EncounterEnemyCreateWithoutEncounterInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput | Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput[]
  upsert?: Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEncounterInput | Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEncounterInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEncounterInputEnvelope
  set?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  disconnect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  delete?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  update?: Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEncounterInput | Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEncounterInput[]
  updateMany?: Prisma.EncounterEnemyUpdateManyWithWhereWithoutEncounterInput | Prisma.EncounterEnemyUpdateManyWithWhereWithoutEncounterInput[]
  deleteMany?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
}

export type EncounterEnemyUncheckedUpdateManyWithoutEncounterNestedInput = {
  create?: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput> | Prisma.EncounterEnemyCreateWithoutEncounterInput[] | Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput[]
  connectOrCreate?: Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput | Prisma.EncounterEnemyCreateOrConnectWithoutEncounterInput[]
  upsert?: Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEncounterInput | Prisma.EncounterEnemyUpsertWithWhereUniqueWithoutEncounterInput[]
  createMany?: Prisma.EncounterEnemyCreateManyEncounterInputEnvelope
  set?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  disconnect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  delete?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  connect?: Prisma.EncounterEnemyWhereUniqueInput | Prisma.EncounterEnemyWhereUniqueInput[]
  update?: Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEncounterInput | Prisma.EncounterEnemyUpdateWithWhereUniqueWithoutEncounterInput[]
  updateMany?: Prisma.EncounterEnemyUpdateManyWithWhereWithoutEncounterInput | Prisma.EncounterEnemyUpdateManyWithWhereWithoutEncounterInput[]
  deleteMany?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
}

export type EncounterEnemyCreateWithoutEnemyTemplateInput = {
  id?: string
  weight?: number
  createdAt?: Date | string
  encounter: Prisma.EncounterDefinitionCreateNestedOneWithoutEnemiesInput
}

export type EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput = {
  id?: string
  encounterId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyCreateOrConnectWithoutEnemyTemplateInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  create: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput>
}

export type EncounterEnemyCreateManyEnemyTemplateInputEnvelope = {
  data: Prisma.EncounterEnemyCreateManyEnemyTemplateInput | Prisma.EncounterEnemyCreateManyEnemyTemplateInput[]
  skipDuplicates?: boolean
}

export type EncounterEnemyUpsertWithWhereUniqueWithoutEnemyTemplateInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  update: Prisma.XOR<Prisma.EncounterEnemyUpdateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedUpdateWithoutEnemyTemplateInput>
  create: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedCreateWithoutEnemyTemplateInput>
}

export type EncounterEnemyUpdateWithWhereUniqueWithoutEnemyTemplateInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateWithoutEnemyTemplateInput, Prisma.EncounterEnemyUncheckedUpdateWithoutEnemyTemplateInput>
}

export type EncounterEnemyUpdateManyWithWhereWithoutEnemyTemplateInput = {
  where: Prisma.EncounterEnemyScalarWhereInput
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateManyMutationInput, Prisma.EncounterEnemyUncheckedUpdateManyWithoutEnemyTemplateInput>
}

export type EncounterEnemyScalarWhereInput = {
  AND?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
  OR?: Prisma.EncounterEnemyScalarWhereInput[]
  NOT?: Prisma.EncounterEnemyScalarWhereInput | Prisma.EncounterEnemyScalarWhereInput[]
  id?: Prisma.StringFilter<"EncounterEnemy"> | string
  encounterId?: Prisma.StringFilter<"EncounterEnemy"> | string
  enemyTemplateId?: Prisma.StringFilter<"EncounterEnemy"> | string
  weight?: Prisma.IntFilter<"EncounterEnemy"> | number
  createdAt?: Prisma.DateTimeFilter<"EncounterEnemy"> | Date | string
}

export type EncounterEnemyCreateWithoutEncounterInput = {
  id?: string
  weight?: number
  createdAt?: Date | string
  enemyTemplate: Prisma.EnemyTemplateCreateNestedOneWithoutEncountersInput
}

export type EncounterEnemyUncheckedCreateWithoutEncounterInput = {
  id?: string
  enemyTemplateId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyCreateOrConnectWithoutEncounterInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  create: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput>
}

export type EncounterEnemyCreateManyEncounterInputEnvelope = {
  data: Prisma.EncounterEnemyCreateManyEncounterInput | Prisma.EncounterEnemyCreateManyEncounterInput[]
  skipDuplicates?: boolean
}

export type EncounterEnemyUpsertWithWhereUniqueWithoutEncounterInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  update: Prisma.XOR<Prisma.EncounterEnemyUpdateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedUpdateWithoutEncounterInput>
  create: Prisma.XOR<Prisma.EncounterEnemyCreateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedCreateWithoutEncounterInput>
}

export type EncounterEnemyUpdateWithWhereUniqueWithoutEncounterInput = {
  where: Prisma.EncounterEnemyWhereUniqueInput
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateWithoutEncounterInput, Prisma.EncounterEnemyUncheckedUpdateWithoutEncounterInput>
}

export type EncounterEnemyUpdateManyWithWhereWithoutEncounterInput = {
  where: Prisma.EncounterEnemyScalarWhereInput
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateManyMutationInput, Prisma.EncounterEnemyUncheckedUpdateManyWithoutEncounterInput>
}

export type EncounterEnemyCreateManyEnemyTemplateInput = {
  id?: string
  encounterId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyUpdateWithoutEnemyTemplateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  encounter?: Prisma.EncounterDefinitionUpdateOneRequiredWithoutEnemiesNestedInput
}

export type EncounterEnemyUncheckedUpdateWithoutEnemyTemplateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyUncheckedUpdateManyWithoutEnemyTemplateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyCreateManyEncounterInput = {
  id?: string
  enemyTemplateId: string
  weight?: number
  createdAt?: Date | string
}

export type EncounterEnemyUpdateWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  enemyTemplate?: Prisma.EnemyTemplateUpdateOneRequiredWithoutEncountersNestedInput
}

export type EncounterEnemyUncheckedUpdateWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  enemyTemplateId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EncounterEnemyUncheckedUpdateManyWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  enemyTemplateId?: Prisma.StringFieldUpdateOperationsInput | string
  weight?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type EncounterEnemySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  encounterId?: boolean
  enemyTemplateId?: boolean
  weight?: boolean
  createdAt?: boolean
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}, ExtArgs["result"]["encounterEnemy"]>

export type EncounterEnemySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  encounterId?: boolean
  enemyTemplateId?: boolean
  weight?: boolean
  createdAt?: boolean
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}, ExtArgs["result"]["encounterEnemy"]>

export type EncounterEnemySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  encounterId?: boolean
  enemyTemplateId?: boolean
  weight?: boolean
  createdAt?: boolean
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}, ExtArgs["result"]["encounterEnemy"]>

export type EncounterEnemySelectScalar = {
  id?: boolean
  encounterId?: boolean
  enemyTemplateId?: boolean
  weight?: boolean
  createdAt?: boolean
}

export type EncounterEnemyOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "encounterId" | "enemyTemplateId" | "weight" | "createdAt", ExtArgs["result"]["encounterEnemy"]>
export type EncounterEnemyInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}
export type EncounterEnemyIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}
export type EncounterEnemyIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  encounter?: boolean | Prisma.EncounterDefinitionDefaultArgs<ExtArgs>
  enemyTemplate?: boolean | Prisma.EnemyTemplateDefaultArgs<ExtArgs>
}

export type $EncounterEnemyPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "EncounterEnemy"
  objects: {
    encounter: Prisma.$EncounterDefinitionPayload<ExtArgs>
    enemyTemplate: Prisma.$EnemyTemplatePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    encounterId: string
    enemyTemplateId: string
    weight: number
    createdAt: Date
  }, ExtArgs["result"]["encounterEnemy"]>
  composites: {}
}

export type EncounterEnemyGetPayload<S extends boolean | null | undefined | EncounterEnemyDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload, S>

export type EncounterEnemyCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<EncounterEnemyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EncounterEnemyCountAggregateInputType | true
  }

export interface EncounterEnemyDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterEnemy'], meta: { name: 'EncounterEnemy' } }
  /**
   * Find zero or one EncounterEnemy that matches the filter.
   * @param {EncounterEnemyFindUniqueArgs} args - Arguments to find a EncounterEnemy
   * @example
   * // Get one EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends EncounterEnemyFindUniqueArgs>(args: Prisma.SelectSubset<T, EncounterEnemyFindUniqueArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one EncounterEnemy that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {EncounterEnemyFindUniqueOrThrowArgs} args - Arguments to find a EncounterEnemy
   * @example
   * // Get one EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends EncounterEnemyFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, EncounterEnemyFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EncounterEnemy that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyFindFirstArgs} args - Arguments to find a EncounterEnemy
   * @example
   * // Get one EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends EncounterEnemyFindFirstArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyFindFirstArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EncounterEnemy that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyFindFirstOrThrowArgs} args - Arguments to find a EncounterEnemy
   * @example
   * // Get one EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends EncounterEnemyFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more EncounterEnemies that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EncounterEnemies
   * const encounterEnemies = await prisma.encounterEnemy.findMany()
   * 
   * // Get first 10 EncounterEnemies
   * const encounterEnemies = await prisma.encounterEnemy.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const encounterEnemyWithIdOnly = await prisma.encounterEnemy.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends EncounterEnemyFindManyArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a EncounterEnemy.
   * @param {EncounterEnemyCreateArgs} args - Arguments to create a EncounterEnemy.
   * @example
   * // Create one EncounterEnemy
   * const EncounterEnemy = await prisma.encounterEnemy.create({
   *   data: {
   *     // ... data to create a EncounterEnemy
   *   }
   * })
   * 
   */
  create<T extends EncounterEnemyCreateArgs>(args: Prisma.SelectSubset<T, EncounterEnemyCreateArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many EncounterEnemies.
   * @param {EncounterEnemyCreateManyArgs} args - Arguments to create many EncounterEnemies.
   * @example
   * // Create many EncounterEnemies
   * const encounterEnemy = await prisma.encounterEnemy.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends EncounterEnemyCreateManyArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many EncounterEnemies and returns the data saved in the database.
   * @param {EncounterEnemyCreateManyAndReturnArgs} args - Arguments to create many EncounterEnemies.
   * @example
   * // Create many EncounterEnemies
   * const encounterEnemy = await prisma.encounterEnemy.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many EncounterEnemies and only return the `id`
   * const encounterEnemyWithIdOnly = await prisma.encounterEnemy.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends EncounterEnemyCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a EncounterEnemy.
   * @param {EncounterEnemyDeleteArgs} args - Arguments to delete one EncounterEnemy.
   * @example
   * // Delete one EncounterEnemy
   * const EncounterEnemy = await prisma.encounterEnemy.delete({
   *   where: {
   *     // ... filter to delete one EncounterEnemy
   *   }
   * })
   * 
   */
  delete<T extends EncounterEnemyDeleteArgs>(args: Prisma.SelectSubset<T, EncounterEnemyDeleteArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one EncounterEnemy.
   * @param {EncounterEnemyUpdateArgs} args - Arguments to update one EncounterEnemy.
   * @example
   * // Update one EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends EncounterEnemyUpdateArgs>(args: Prisma.SelectSubset<T, EncounterEnemyUpdateArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more EncounterEnemies.
   * @param {EncounterEnemyDeleteManyArgs} args - Arguments to filter EncounterEnemies to delete.
   * @example
   * // Delete a few EncounterEnemies
   * const { count } = await prisma.encounterEnemy.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends EncounterEnemyDeleteManyArgs>(args?: Prisma.SelectSubset<T, EncounterEnemyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EncounterEnemies.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EncounterEnemies
   * const encounterEnemy = await prisma.encounterEnemy.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends EncounterEnemyUpdateManyArgs>(args: Prisma.SelectSubset<T, EncounterEnemyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EncounterEnemies and returns the data updated in the database.
   * @param {EncounterEnemyUpdateManyAndReturnArgs} args - Arguments to update many EncounterEnemies.
   * @example
   * // Update many EncounterEnemies
   * const encounterEnemy = await prisma.encounterEnemy.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more EncounterEnemies and only return the `id`
   * const encounterEnemyWithIdOnly = await prisma.encounterEnemy.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends EncounterEnemyUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, EncounterEnemyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one EncounterEnemy.
   * @param {EncounterEnemyUpsertArgs} args - Arguments to update or create a EncounterEnemy.
   * @example
   * // Update or create a EncounterEnemy
   * const encounterEnemy = await prisma.encounterEnemy.upsert({
   *   create: {
   *     // ... data to create a EncounterEnemy
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EncounterEnemy we want to update
   *   }
   * })
   */
  upsert<T extends EncounterEnemyUpsertArgs>(args: Prisma.SelectSubset<T, EncounterEnemyUpsertArgs<ExtArgs>>): Prisma.Prisma__EncounterEnemyClient<runtime.Types.Result.GetResult<Prisma.$EncounterEnemyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of EncounterEnemies.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyCountArgs} args - Arguments to filter EncounterEnemies to count.
   * @example
   * // Count the number of EncounterEnemies
   * const count = await prisma.encounterEnemy.count({
   *   where: {
   *     // ... the filter for the EncounterEnemies we want to count
   *   }
   * })
  **/
  count<T extends EncounterEnemyCountArgs>(
    args?: Prisma.Subset<T, EncounterEnemyCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], EncounterEnemyCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a EncounterEnemy.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends EncounterEnemyAggregateArgs>(args: Prisma.Subset<T, EncounterEnemyAggregateArgs>): Prisma.PrismaPromise<GetEncounterEnemyAggregateType<T>>

  /**
   * Group by EncounterEnemy.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EncounterEnemyGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends EncounterEnemyGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: EncounterEnemyGroupByArgs['orderBy'] }
      : { orderBy?: EncounterEnemyGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, EncounterEnemyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterEnemyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the EncounterEnemy model
 */
readonly fields: EncounterEnemyFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for EncounterEnemy.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__EncounterEnemyClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  encounter<T extends Prisma.EncounterDefinitionDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EncounterDefinitionDefaultArgs<ExtArgs>>): Prisma.Prisma__EncounterDefinitionClient<runtime.Types.Result.GetResult<Prisma.$EncounterDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  enemyTemplate<T extends Prisma.EnemyTemplateDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EnemyTemplateDefaultArgs<ExtArgs>>): Prisma.Prisma__EnemyTemplateClient<runtime.Types.Result.GetResult<Prisma.$EnemyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the EncounterEnemy model
 */
export interface EncounterEnemyFieldRefs {
  readonly id: Prisma.FieldRef<"EncounterEnemy", 'String'>
  readonly encounterId: Prisma.FieldRef<"EncounterEnemy", 'String'>
  readonly enemyTemplateId: Prisma.FieldRef<"EncounterEnemy", 'String'>
  readonly weight: Prisma.FieldRef<"EncounterEnemy", 'Int'>
  readonly createdAt: Prisma.FieldRef<"EncounterEnemy", 'DateTime'>
}
    

// Custom InputTypes
/**
 * EncounterEnemy findUnique
 */
export type EncounterEnemyFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter, which EncounterEnemy to fetch.
   */
  where: Prisma.EncounterEnemyWhereUniqueInput
}

/**
 * EncounterEnemy findUniqueOrThrow
 */
export type EncounterEnemyFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter, which EncounterEnemy to fetch.
   */
  where: Prisma.EncounterEnemyWhereUniqueInput
}

/**
 * EncounterEnemy findFirst
 */
export type EncounterEnemyFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter, which EncounterEnemy to fetch.
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EncounterEnemies to fetch.
   */
  orderBy?: Prisma.EncounterEnemyOrderByWithRelationInput | Prisma.EncounterEnemyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EncounterEnemies.
   */
  cursor?: Prisma.EncounterEnemyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EncounterEnemies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EncounterEnemies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EncounterEnemies.
   */
  distinct?: Prisma.EncounterEnemyScalarFieldEnum | Prisma.EncounterEnemyScalarFieldEnum[]
}

/**
 * EncounterEnemy findFirstOrThrow
 */
export type EncounterEnemyFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter, which EncounterEnemy to fetch.
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EncounterEnemies to fetch.
   */
  orderBy?: Prisma.EncounterEnemyOrderByWithRelationInput | Prisma.EncounterEnemyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EncounterEnemies.
   */
  cursor?: Prisma.EncounterEnemyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EncounterEnemies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EncounterEnemies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EncounterEnemies.
   */
  distinct?: Prisma.EncounterEnemyScalarFieldEnum | Prisma.EncounterEnemyScalarFieldEnum[]
}

/**
 * EncounterEnemy findMany
 */
export type EncounterEnemyFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter, which EncounterEnemies to fetch.
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EncounterEnemies to fetch.
   */
  orderBy?: Prisma.EncounterEnemyOrderByWithRelationInput | Prisma.EncounterEnemyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing EncounterEnemies.
   */
  cursor?: Prisma.EncounterEnemyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EncounterEnemies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EncounterEnemies.
   */
  skip?: number
  distinct?: Prisma.EncounterEnemyScalarFieldEnum | Prisma.EncounterEnemyScalarFieldEnum[]
}

/**
 * EncounterEnemy create
 */
export type EncounterEnemyCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * The data needed to create a EncounterEnemy.
   */
  data: Prisma.XOR<Prisma.EncounterEnemyCreateInput, Prisma.EncounterEnemyUncheckedCreateInput>
}

/**
 * EncounterEnemy createMany
 */
export type EncounterEnemyCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many EncounterEnemies.
   */
  data: Prisma.EncounterEnemyCreateManyInput | Prisma.EncounterEnemyCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * EncounterEnemy createManyAndReturn
 */
export type EncounterEnemyCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * The data used to create many EncounterEnemies.
   */
  data: Prisma.EncounterEnemyCreateManyInput | Prisma.EncounterEnemyCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * EncounterEnemy update
 */
export type EncounterEnemyUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * The data needed to update a EncounterEnemy.
   */
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateInput, Prisma.EncounterEnemyUncheckedUpdateInput>
  /**
   * Choose, which EncounterEnemy to update.
   */
  where: Prisma.EncounterEnemyWhereUniqueInput
}

/**
 * EncounterEnemy updateMany
 */
export type EncounterEnemyUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update EncounterEnemies.
   */
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateManyMutationInput, Prisma.EncounterEnemyUncheckedUpdateManyInput>
  /**
   * Filter which EncounterEnemies to update
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * Limit how many EncounterEnemies to update.
   */
  limit?: number
}

/**
 * EncounterEnemy updateManyAndReturn
 */
export type EncounterEnemyUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * The data used to update EncounterEnemies.
   */
  data: Prisma.XOR<Prisma.EncounterEnemyUpdateManyMutationInput, Prisma.EncounterEnemyUncheckedUpdateManyInput>
  /**
   * Filter which EncounterEnemies to update
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * Limit how many EncounterEnemies to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * EncounterEnemy upsert
 */
export type EncounterEnemyUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * The filter to search for the EncounterEnemy to update in case it exists.
   */
  where: Prisma.EncounterEnemyWhereUniqueInput
  /**
   * In case the EncounterEnemy found by the `where` argument doesn't exist, create a new EncounterEnemy with this data.
   */
  create: Prisma.XOR<Prisma.EncounterEnemyCreateInput, Prisma.EncounterEnemyUncheckedCreateInput>
  /**
   * In case the EncounterEnemy was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.EncounterEnemyUpdateInput, Prisma.EncounterEnemyUncheckedUpdateInput>
}

/**
 * EncounterEnemy delete
 */
export type EncounterEnemyDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
  /**
   * Filter which EncounterEnemy to delete.
   */
  where: Prisma.EncounterEnemyWhereUniqueInput
}

/**
 * EncounterEnemy deleteMany
 */
export type EncounterEnemyDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EncounterEnemies to delete
   */
  where?: Prisma.EncounterEnemyWhereInput
  /**
   * Limit how many EncounterEnemies to delete.
   */
  limit?: number
}

/**
 * EncounterEnemy without action
 */
export type EncounterEnemyDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EncounterEnemy
   */
  select?: Prisma.EncounterEnemySelect<ExtArgs> | null
  /**
   * Omit specific fields from the EncounterEnemy
   */
  omit?: Prisma.EncounterEnemyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EncounterEnemyInclude<ExtArgs> | null
}
