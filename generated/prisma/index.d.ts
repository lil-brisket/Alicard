
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model PlayerStats
 * 
 */
export type PlayerStats = $Result.DefaultSelection<Prisma.$PlayerStatsPayload>
/**
 * Model MapTile
 * 
 */
export type MapTile = $Result.DefaultSelection<Prisma.$MapTilePayload>
/**
 * Model MapPosition
 * 
 */
export type MapPosition = $Result.DefaultSelection<Prisma.$MapPositionPayload>
/**
 * Model NPC
 * 
 */
export type NPC = $Result.DefaultSelection<Prisma.$NPCPayload>
/**
 * Model ShopItem
 * 
 */
export type ShopItem = $Result.DefaultSelection<Prisma.$ShopItemPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Occupation
 * 
 */
export type Occupation = $Result.DefaultSelection<Prisma.$OccupationPayload>
/**
 * Model PlayerSkill
 * 
 */
export type PlayerSkill = $Result.DefaultSelection<Prisma.$PlayerSkillPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model CombatLog
 * 
 */
export type CombatLog = $Result.DefaultSelection<Prisma.$CombatLogPayload>
/**
 * Model DeathLog
 * 
 */
export type DeathLog = $Result.DefaultSelection<Prisma.$DeathLogPayload>
/**
 * Model Guild
 * 
 */
export type Guild = $Result.DefaultSelection<Prisma.$GuildPayload>
/**
 * Model GuildMember
 * 
 */
export type GuildMember = $Result.DefaultSelection<Prisma.$GuildMemberPayload>
/**
 * Model GuildBank
 * 
 */
export type GuildBank = $Result.DefaultSelection<Prisma.$GuildBankPayload>
/**
 * Model GuildQuest
 * 
 */
export type GuildQuest = $Result.DefaultSelection<Prisma.$GuildQuestPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model BankVaultItem
 * 
 */
export type BankVaultItem = $Result.DefaultSelection<Prisma.$BankVaultItemPayload>
/**
 * Model MarketListing
 * 
 */
export type MarketListing = $Result.DefaultSelection<Prisma.$MarketListingPayload>
/**
 * Model MarketTransaction
 * 
 */
export type MarketTransaction = $Result.DefaultSelection<Prisma.$MarketTransactionPayload>
/**
 * Model Quest
 * 
 */
export type Quest = $Result.DefaultSelection<Prisma.$QuestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TileType: {
  GRASS: 'GRASS',
  FOREST: 'FOREST',
  MOUNTAIN: 'MOUNTAIN',
  RIVER: 'RIVER',
  DESERT: 'DESERT',
  DUNGEON: 'DUNGEON',
  TOWN: 'TOWN',
  SHRINE: 'SHRINE',
  ROAD: 'ROAD'
};

export type TileType = (typeof TileType)[keyof typeof TileType]


export const ZoneType: {
  SAFE: 'SAFE',
  LOW_DANGER: 'LOW_DANGER',
  MEDIUM_DANGER: 'MEDIUM_DANGER',
  HIGH_DANGER: 'HIGH_DANGER',
  EXTREME_DANGER: 'EXTREME_DANGER'
};

export type ZoneType = (typeof ZoneType)[keyof typeof ZoneType]


export const ResourceType: {
  ORE: 'ORE',
  HERB: 'HERB',
  FISH: 'FISH',
  WOOD: 'WOOD',
  RARE_ITEM: 'RARE_ITEM'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const NPCType: {
  MERCHANT: 'MERCHANT',
  QUEST_GIVER: 'QUEST_GIVER',
  TRAINER: 'TRAINER',
  BANKER: 'BANKER',
  GUILD_MASTER: 'GUILD_MASTER',
  GUARD: 'GUARD',
  TAVERN_KEEPER: 'TAVERN_KEEPER'
};

export type NPCType = (typeof NPCType)[keyof typeof NPCType]


export const ItemType: {
  WEAPON: 'WEAPON',
  ARMOR: 'ARMOR',
  ACCESSORY: 'ACCESSORY',
  CONSUMABLE: 'CONSUMABLE',
  MATERIAL: 'MATERIAL',
  QUEST_ITEM: 'QUEST_ITEM',
  TOOL: 'TOOL'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const ItemRarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY'
};

export type ItemRarity = (typeof ItemRarity)[keyof typeof ItemRarity]


export const EquipmentSlot: {
  WEAPON: 'WEAPON',
  HEAD: 'HEAD',
  CHEST: 'CHEST',
  LEGS: 'LEGS',
  FEET: 'FEET',
  ACCESSORY_1: 'ACCESSORY_1',
  ACCESSORY_2: 'ACCESSORY_2'
};

export type EquipmentSlot = (typeof EquipmentSlot)[keyof typeof EquipmentSlot]


export const PrimaryOccupation: {
  BLACKSMITH: 'BLACKSMITH',
  ALCHEMIST: 'ALCHEMIST',
  COOK: 'COOK',
  TAILOR: 'TAILOR',
  MERCHANT: 'MERCHANT',
  BEAST_HANDLER: 'BEAST_HANDLER'
};

export type PrimaryOccupation = (typeof PrimaryOccupation)[keyof typeof PrimaryOccupation]


export const SecondaryOccupation: {
  MINER: 'MINER',
  HERBALIST: 'HERBALIST',
  FISHER: 'FISHER',
  LOGGER: 'LOGGER',
  FORAGER: 'FORAGER'
};

export type SecondaryOccupation = (typeof SecondaryOccupation)[keyof typeof SecondaryOccupation]


export const GuildRole: {
  LEADER: 'LEADER',
  OFFICER: 'OFFICER',
  MEMBER: 'MEMBER'
};

export type GuildRole = (typeof GuildRole)[keyof typeof GuildRole]


export const QuestType: {
  KILL: 'KILL',
  GATHER: 'GATHER',
  DELIVER: 'DELIVER',
  EXPLORE: 'EXPLORE',
  CRAFT: 'CRAFT'
};

export type QuestType = (typeof QuestType)[keyof typeof QuestType]

}

export type TileType = $Enums.TileType

export const TileType: typeof $Enums.TileType

export type ZoneType = $Enums.ZoneType

export const ZoneType: typeof $Enums.ZoneType

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type NPCType = $Enums.NPCType

export const NPCType: typeof $Enums.NPCType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type ItemRarity = $Enums.ItemRarity

export const ItemRarity: typeof $Enums.ItemRarity

export type EquipmentSlot = $Enums.EquipmentSlot

export const EquipmentSlot: typeof $Enums.EquipmentSlot

export type PrimaryOccupation = $Enums.PrimaryOccupation

export const PrimaryOccupation: typeof $Enums.PrimaryOccupation

export type SecondaryOccupation = $Enums.SecondaryOccupation

export const SecondaryOccupation: typeof $Enums.SecondaryOccupation

export type GuildRole = $Enums.GuildRole

export const GuildRole: typeof $Enums.GuildRole

export type QuestType = $Enums.QuestType

export const QuestType: typeof $Enums.QuestType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Posts
 * const posts = await prisma.post.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Posts
   * const posts = await prisma.post.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerStats`: Exposes CRUD operations for the **PlayerStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerStats
    * const playerStats = await prisma.playerStats.findMany()
    * ```
    */
  get playerStats(): Prisma.PlayerStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapTile`: Exposes CRUD operations for the **MapTile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapTiles
    * const mapTiles = await prisma.mapTile.findMany()
    * ```
    */
  get mapTile(): Prisma.MapTileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapPosition`: Exposes CRUD operations for the **MapPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapPositions
    * const mapPositions = await prisma.mapPosition.findMany()
    * ```
    */
  get mapPosition(): Prisma.MapPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nPC`: Exposes CRUD operations for the **NPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCS
    * const nPCS = await prisma.nPC.findMany()
    * ```
    */
  get nPC(): Prisma.NPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopItem`: Exposes CRUD operations for the **ShopItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopItems
    * const shopItems = await prisma.shopItem.findMany()
    * ```
    */
  get shopItem(): Prisma.ShopItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.occupation`: Exposes CRUD operations for the **Occupation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occupations
    * const occupations = await prisma.occupation.findMany()
    * ```
    */
  get occupation(): Prisma.OccupationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerSkill`: Exposes CRUD operations for the **PlayerSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerSkills
    * const playerSkills = await prisma.playerSkill.findMany()
    * ```
    */
  get playerSkill(): Prisma.PlayerSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combatLog`: Exposes CRUD operations for the **CombatLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombatLogs
    * const combatLogs = await prisma.combatLog.findMany()
    * ```
    */
  get combatLog(): Prisma.CombatLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deathLog`: Exposes CRUD operations for the **DeathLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeathLogs
    * const deathLogs = await prisma.deathLog.findMany()
    * ```
    */
  get deathLog(): Prisma.DeathLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **Guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.GuildDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildMember`: Exposes CRUD operations for the **GuildMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildMembers
    * const guildMembers = await prisma.guildMember.findMany()
    * ```
    */
  get guildMember(): Prisma.GuildMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildBank`: Exposes CRUD operations for the **GuildBank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildBanks
    * const guildBanks = await prisma.guildBank.findMany()
    * ```
    */
  get guildBank(): Prisma.GuildBankDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildQuest`: Exposes CRUD operations for the **GuildQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildQuests
    * const guildQuests = await prisma.guildQuest.findMany()
    * ```
    */
  get guildQuest(): Prisma.GuildQuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankVaultItem`: Exposes CRUD operations for the **BankVaultItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankVaultItems
    * const bankVaultItems = await prisma.bankVaultItem.findMany()
    * ```
    */
  get bankVaultItem(): Prisma.BankVaultItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketListing`: Exposes CRUD operations for the **MarketListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketListings
    * const marketListings = await prisma.marketListing.findMany()
    * ```
    */
  get marketListing(): Prisma.MarketListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketTransaction`: Exposes CRUD operations for the **MarketTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketTransactions
    * const marketTransactions = await prisma.marketTransaction.findMany()
    * ```
    */
  get marketTransaction(): Prisma.MarketTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quest`: Exposes CRUD operations for the **Quest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quest.findMany()
    * ```
    */
  get quest(): Prisma.QuestDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Post: 'Post',
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Player: 'Player',
    PlayerStats: 'PlayerStats',
    MapTile: 'MapTile',
    MapPosition: 'MapPosition',
    NPC: 'NPC',
    ShopItem: 'ShopItem',
    Item: 'Item',
    InventoryItem: 'InventoryItem',
    Equipment: 'Equipment',
    Occupation: 'Occupation',
    PlayerSkill: 'PlayerSkill',
    Encounter: 'Encounter',
    CombatLog: 'CombatLog',
    DeathLog: 'DeathLog',
    Guild: 'Guild',
    GuildMember: 'GuildMember',
    GuildBank: 'GuildBank',
    GuildQuest: 'GuildQuest',
    BankAccount: 'BankAccount',
    BankVaultItem: 'BankVaultItem',
    MarketListing: 'MarketListing',
    MarketTransaction: 'MarketTransaction',
    Quest: 'Quest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "post" | "account" | "session" | "user" | "verificationToken" | "player" | "playerStats" | "mapTile" | "mapPosition" | "nPC" | "shopItem" | "item" | "inventoryItem" | "equipment" | "occupation" | "playerSkill" | "encounter" | "combatLog" | "deathLog" | "guild" | "guildMember" | "guildBank" | "guildQuest" | "bankAccount" | "bankVaultItem" | "marketListing" | "marketTransaction" | "quest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      PlayerStats: {
        payload: Prisma.$PlayerStatsPayload<ExtArgs>
        fields: Prisma.PlayerStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          findFirst: {
            args: Prisma.PlayerStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          findMany: {
            args: Prisma.PlayerStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>[]
          }
          create: {
            args: Prisma.PlayerStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          createMany: {
            args: Prisma.PlayerStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>[]
          }
          delete: {
            args: Prisma.PlayerStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          update: {
            args: Prisma.PlayerStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          deleteMany: {
            args: Prisma.PlayerStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>[]
          }
          upsert: {
            args: Prisma.PlayerStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatsPayload>
          }
          aggregate: {
            args: Prisma.PlayerStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerStats>
          }
          groupBy: {
            args: Prisma.PlayerStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerStatsCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatsCountAggregateOutputType> | number
          }
        }
      }
      MapTile: {
        payload: Prisma.$MapTilePayload<ExtArgs>
        fields: Prisma.MapTileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapTileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapTileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          findFirst: {
            args: Prisma.MapTileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapTileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          findMany: {
            args: Prisma.MapTileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          create: {
            args: Prisma.MapTileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          createMany: {
            args: Prisma.MapTileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapTileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          delete: {
            args: Prisma.MapTileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          update: {
            args: Prisma.MapTileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          deleteMany: {
            args: Prisma.MapTileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapTileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapTileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>[]
          }
          upsert: {
            args: Prisma.MapTileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapTilePayload>
          }
          aggregate: {
            args: Prisma.MapTileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapTile>
          }
          groupBy: {
            args: Prisma.MapTileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapTileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapTileCountArgs<ExtArgs>
            result: $Utils.Optional<MapTileCountAggregateOutputType> | number
          }
        }
      }
      MapPosition: {
        payload: Prisma.$MapPositionPayload<ExtArgs>
        fields: Prisma.MapPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          findFirst: {
            args: Prisma.MapPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          findMany: {
            args: Prisma.MapPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>[]
          }
          create: {
            args: Prisma.MapPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          createMany: {
            args: Prisma.MapPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>[]
          }
          delete: {
            args: Prisma.MapPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          update: {
            args: Prisma.MapPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          deleteMany: {
            args: Prisma.MapPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>[]
          }
          upsert: {
            args: Prisma.MapPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPositionPayload>
          }
          aggregate: {
            args: Prisma.MapPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapPosition>
          }
          groupBy: {
            args: Prisma.MapPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapPositionCountArgs<ExtArgs>
            result: $Utils.Optional<MapPositionCountAggregateOutputType> | number
          }
        }
      }
      NPC: {
        payload: Prisma.$NPCPayload<ExtArgs>
        fields: Prisma.NPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findFirst: {
            args: Prisma.NPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findMany: {
            args: Prisma.NPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          create: {
            args: Prisma.NPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          createMany: {
            args: Prisma.NPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          delete: {
            args: Prisma.NPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          update: {
            args: Prisma.NPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          deleteMany: {
            args: Prisma.NPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          upsert: {
            args: Prisma.NPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          aggregate: {
            args: Prisma.NPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPC>
          }
          groupBy: {
            args: Prisma.NPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCCountArgs<ExtArgs>
            result: $Utils.Optional<NPCCountAggregateOutputType> | number
          }
        }
      }
      ShopItem: {
        payload: Prisma.$ShopItemPayload<ExtArgs>
        fields: Prisma.ShopItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findFirst: {
            args: Prisma.ShopItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          findMany: {
            args: Prisma.ShopItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          create: {
            args: Prisma.ShopItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          createMany: {
            args: Prisma.ShopItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          delete: {
            args: Prisma.ShopItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          update: {
            args: Prisma.ShopItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          deleteMany: {
            args: Prisma.ShopItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>[]
          }
          upsert: {
            args: Prisma.ShopItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopItemPayload>
          }
          aggregate: {
            args: Prisma.ShopItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopItem>
          }
          groupBy: {
            args: Prisma.ShopItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShopItemCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Occupation: {
        payload: Prisma.$OccupationPayload<ExtArgs>
        fields: Prisma.OccupationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccupationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccupationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          findFirst: {
            args: Prisma.OccupationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccupationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          findMany: {
            args: Prisma.OccupationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>[]
          }
          create: {
            args: Prisma.OccupationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          createMany: {
            args: Prisma.OccupationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OccupationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>[]
          }
          delete: {
            args: Prisma.OccupationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          update: {
            args: Prisma.OccupationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          deleteMany: {
            args: Prisma.OccupationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OccupationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OccupationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>[]
          }
          upsert: {
            args: Prisma.OccupationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          aggregate: {
            args: Prisma.OccupationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccupation>
          }
          groupBy: {
            args: Prisma.OccupationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccupationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccupationCountArgs<ExtArgs>
            result: $Utils.Optional<OccupationCountAggregateOutputType> | number
          }
        }
      }
      PlayerSkill: {
        payload: Prisma.$PlayerSkillPayload<ExtArgs>
        fields: Prisma.PlayerSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          findFirst: {
            args: Prisma.PlayerSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          findMany: {
            args: Prisma.PlayerSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>[]
          }
          create: {
            args: Prisma.PlayerSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          createMany: {
            args: Prisma.PlayerSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>[]
          }
          delete: {
            args: Prisma.PlayerSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          update: {
            args: Prisma.PlayerSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          deleteMany: {
            args: Prisma.PlayerSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>[]
          }
          upsert: {
            args: Prisma.PlayerSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerSkillPayload>
          }
          aggregate: {
            args: Prisma.PlayerSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerSkill>
          }
          groupBy: {
            args: Prisma.PlayerSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerSkillCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      CombatLog: {
        payload: Prisma.$CombatLogPayload<ExtArgs>
        fields: Prisma.CombatLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombatLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombatLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          findFirst: {
            args: Prisma.CombatLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombatLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          findMany: {
            args: Prisma.CombatLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          create: {
            args: Prisma.CombatLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          createMany: {
            args: Prisma.CombatLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CombatLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          delete: {
            args: Prisma.CombatLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          update: {
            args: Prisma.CombatLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          deleteMany: {
            args: Prisma.CombatLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombatLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CombatLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          upsert: {
            args: Prisma.CombatLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          aggregate: {
            args: Prisma.CombatLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombatLog>
          }
          groupBy: {
            args: Prisma.CombatLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombatLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombatLogCountArgs<ExtArgs>
            result: $Utils.Optional<CombatLogCountAggregateOutputType> | number
          }
        }
      }
      DeathLog: {
        payload: Prisma.$DeathLogPayload<ExtArgs>
        fields: Prisma.DeathLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeathLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeathLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          findFirst: {
            args: Prisma.DeathLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeathLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          findMany: {
            args: Prisma.DeathLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>[]
          }
          create: {
            args: Prisma.DeathLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          createMany: {
            args: Prisma.DeathLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeathLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>[]
          }
          delete: {
            args: Prisma.DeathLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          update: {
            args: Prisma.DeathLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          deleteMany: {
            args: Prisma.DeathLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeathLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeathLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>[]
          }
          upsert: {
            args: Prisma.DeathLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeathLogPayload>
          }
          aggregate: {
            args: Prisma.DeathLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeathLog>
          }
          groupBy: {
            args: Prisma.DeathLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeathLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeathLogCountArgs<ExtArgs>
            result: $Utils.Optional<DeathLogCountAggregateOutputType> | number
          }
        }
      }
      Guild: {
        payload: Prisma.$GuildPayload<ExtArgs>
        fields: Prisma.GuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findFirst: {
            args: Prisma.GuildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findMany: {
            args: Prisma.GuildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>[]
          }
          create: {
            args: Prisma.GuildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          createMany: {
            args: Prisma.GuildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>[]
          }
          delete: {
            args: Prisma.GuildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          update: {
            args: Prisma.GuildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          deleteMany: {
            args: Prisma.GuildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuildUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>[]
          }
          upsert: {
            args: Prisma.GuildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          aggregate: {
            args: Prisma.GuildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuild>
          }
          groupBy: {
            args: Prisma.GuildGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildCountArgs<ExtArgs>
            result: $Utils.Optional<GuildCountAggregateOutputType> | number
          }
        }
      }
      GuildMember: {
        payload: Prisma.$GuildMemberPayload<ExtArgs>
        fields: Prisma.GuildMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          findFirst: {
            args: Prisma.GuildMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          findMany: {
            args: Prisma.GuildMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>[]
          }
          create: {
            args: Prisma.GuildMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          createMany: {
            args: Prisma.GuildMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>[]
          }
          delete: {
            args: Prisma.GuildMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          update: {
            args: Prisma.GuildMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          deleteMany: {
            args: Prisma.GuildMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuildMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>[]
          }
          upsert: {
            args: Prisma.GuildMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          aggregate: {
            args: Prisma.GuildMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildMember>
          }
          groupBy: {
            args: Prisma.GuildMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GuildMemberCountAggregateOutputType> | number
          }
        }
      }
      GuildBank: {
        payload: Prisma.$GuildBankPayload<ExtArgs>
        fields: Prisma.GuildBankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildBankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildBankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          findFirst: {
            args: Prisma.GuildBankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildBankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          findMany: {
            args: Prisma.GuildBankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>[]
          }
          create: {
            args: Prisma.GuildBankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          createMany: {
            args: Prisma.GuildBankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildBankCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>[]
          }
          delete: {
            args: Prisma.GuildBankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          update: {
            args: Prisma.GuildBankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          deleteMany: {
            args: Prisma.GuildBankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildBankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuildBankUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>[]
          }
          upsert: {
            args: Prisma.GuildBankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildBankPayload>
          }
          aggregate: {
            args: Prisma.GuildBankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildBank>
          }
          groupBy: {
            args: Prisma.GuildBankGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildBankGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildBankCountArgs<ExtArgs>
            result: $Utils.Optional<GuildBankCountAggregateOutputType> | number
          }
        }
      }
      GuildQuest: {
        payload: Prisma.$GuildQuestPayload<ExtArgs>
        fields: Prisma.GuildQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildQuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildQuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          findFirst: {
            args: Prisma.GuildQuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildQuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          findMany: {
            args: Prisma.GuildQuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>[]
          }
          create: {
            args: Prisma.GuildQuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          createMany: {
            args: Prisma.GuildQuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildQuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>[]
          }
          delete: {
            args: Prisma.GuildQuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          update: {
            args: Prisma.GuildQuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          deleteMany: {
            args: Prisma.GuildQuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildQuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuildQuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>[]
          }
          upsert: {
            args: Prisma.GuildQuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildQuestPayload>
          }
          aggregate: {
            args: Prisma.GuildQuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildQuest>
          }
          groupBy: {
            args: Prisma.GuildQuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildQuestCountArgs<ExtArgs>
            result: $Utils.Optional<GuildQuestCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      BankVaultItem: {
        payload: Prisma.$BankVaultItemPayload<ExtArgs>
        fields: Prisma.BankVaultItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankVaultItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankVaultItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          findFirst: {
            args: Prisma.BankVaultItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankVaultItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          findMany: {
            args: Prisma.BankVaultItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>[]
          }
          create: {
            args: Prisma.BankVaultItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          createMany: {
            args: Prisma.BankVaultItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankVaultItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>[]
          }
          delete: {
            args: Prisma.BankVaultItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          update: {
            args: Prisma.BankVaultItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          deleteMany: {
            args: Prisma.BankVaultItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankVaultItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankVaultItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>[]
          }
          upsert: {
            args: Prisma.BankVaultItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankVaultItemPayload>
          }
          aggregate: {
            args: Prisma.BankVaultItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankVaultItem>
          }
          groupBy: {
            args: Prisma.BankVaultItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankVaultItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankVaultItemCountArgs<ExtArgs>
            result: $Utils.Optional<BankVaultItemCountAggregateOutputType> | number
          }
        }
      }
      MarketListing: {
        payload: Prisma.$MarketListingPayload<ExtArgs>
        fields: Prisma.MarketListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          findFirst: {
            args: Prisma.MarketListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          findMany: {
            args: Prisma.MarketListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          create: {
            args: Prisma.MarketListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          createMany: {
            args: Prisma.MarketListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          delete: {
            args: Prisma.MarketListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          update: {
            args: Prisma.MarketListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          deleteMany: {
            args: Prisma.MarketListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>[]
          }
          upsert: {
            args: Prisma.MarketListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketListingPayload>
          }
          aggregate: {
            args: Prisma.MarketListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketListing>
          }
          groupBy: {
            args: Prisma.MarketListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketListingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketListingCountAggregateOutputType> | number
          }
        }
      }
      MarketTransaction: {
        payload: Prisma.$MarketTransactionPayload<ExtArgs>
        fields: Prisma.MarketTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          findFirst: {
            args: Prisma.MarketTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          findMany: {
            args: Prisma.MarketTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>[]
          }
          create: {
            args: Prisma.MarketTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          createMany: {
            args: Prisma.MarketTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>[]
          }
          delete: {
            args: Prisma.MarketTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          update: {
            args: Prisma.MarketTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          deleteMany: {
            args: Prisma.MarketTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>[]
          }
          upsert: {
            args: Prisma.MarketTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTransactionPayload>
          }
          aggregate: {
            args: Prisma.MarketTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketTransaction>
          }
          groupBy: {
            args: Prisma.MarketTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<MarketTransactionCountAggregateOutputType> | number
          }
        }
      }
      Quest: {
        payload: Prisma.$QuestPayload<ExtArgs>
        fields: Prisma.QuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findFirst: {
            args: Prisma.QuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findMany: {
            args: Prisma.QuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          create: {
            args: Prisma.QuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          createMany: {
            args: Prisma.QuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          delete: {
            args: Prisma.QuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          update: {
            args: Prisma.QuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          deleteMany: {
            args: Prisma.QuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          upsert: {
            args: Prisma.QuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          aggregate: {
            args: Prisma.QuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuest>
          }
          groupBy: {
            args: Prisma.QuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestCountArgs<ExtArgs>
            result: $Utils.Optional<QuestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    post?: PostOmit
    account?: AccountOmit
    session?: SessionOmit
    user?: UserOmit
    verificationToken?: VerificationTokenOmit
    player?: PlayerOmit
    playerStats?: PlayerStatsOmit
    mapTile?: MapTileOmit
    mapPosition?: MapPositionOmit
    nPC?: NPCOmit
    shopItem?: ShopItemOmit
    item?: ItemOmit
    inventoryItem?: InventoryItemOmit
    equipment?: EquipmentOmit
    occupation?: OccupationOmit
    playerSkill?: PlayerSkillOmit
    encounter?: EncounterOmit
    combatLog?: CombatLogOmit
    deathLog?: DeathLogOmit
    guild?: GuildOmit
    guildMember?: GuildMemberOmit
    guildBank?: GuildBankOmit
    guildQuest?: GuildQuestOmit
    bankAccount?: BankAccountOmit
    bankVaultItem?: BankVaultItemOmit
    marketListing?: MarketListingOmit
    marketTransaction?: MarketTransactionOmit
    quest?: QuestOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    posts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    inventory: number
    marketListings: number
    combatLogs: number
    deathLogs: number
    skills: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | PlayerCountOutputTypeCountInventoryArgs
    marketListings?: boolean | PlayerCountOutputTypeCountMarketListingsArgs
    combatLogs?: boolean | PlayerCountOutputTypeCountCombatLogsArgs
    deathLogs?: boolean | PlayerCountOutputTypeCountDeathLogsArgs
    skills?: boolean | PlayerCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMarketListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketListingWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountCombatLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatLogWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountDeathLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeathLogWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillWhereInput
  }


  /**
   * Count Type MapTileCountOutputType
   */

  export type MapTileCountOutputType = {
    positions: number
    npcs: number
    encounters: number
  }

  export type MapTileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | MapTileCountOutputTypeCountPositionsArgs
    npcs?: boolean | MapTileCountOutputTypeCountNpcsArgs
    encounters?: boolean | MapTileCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * MapTileCountOutputType without action
   */
  export type MapTileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTileCountOutputType
     */
    select?: MapTileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapTileCountOutputType without action
   */
  export type MapTileCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapPositionWhereInput
  }

  /**
   * MapTileCountOutputType without action
   */
  export type MapTileCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }

  /**
   * MapTileCountOutputType without action
   */
  export type MapTileCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type NPCCountOutputType
   */

  export type NPCCountOutputType = {
    shopItems: number
    quests: number
  }

  export type NPCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shopItems?: boolean | NPCCountOutputTypeCountShopItemsArgs
    quests?: boolean | NPCCountOutputTypeCountQuestsArgs
  }

  // Custom InputTypes
  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCCountOutputType
     */
    select?: NPCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountShopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    inventoryItems: number
    shopItems: number
    marketListings: number
    equippedAsWeapon: number
    equippedAsHead: number
    equippedAsChest: number
    equippedAsLegs: number
    equippedAsFeet: number
    equippedAsAccessory1: number
    equippedAsAccessory2: number
    bankVaultItems: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ItemCountOutputTypeCountInventoryItemsArgs
    shopItems?: boolean | ItemCountOutputTypeCountShopItemsArgs
    marketListings?: boolean | ItemCountOutputTypeCountMarketListingsArgs
    equippedAsWeapon?: boolean | ItemCountOutputTypeCountEquippedAsWeaponArgs
    equippedAsHead?: boolean | ItemCountOutputTypeCountEquippedAsHeadArgs
    equippedAsChest?: boolean | ItemCountOutputTypeCountEquippedAsChestArgs
    equippedAsLegs?: boolean | ItemCountOutputTypeCountEquippedAsLegsArgs
    equippedAsFeet?: boolean | ItemCountOutputTypeCountEquippedAsFeetArgs
    equippedAsAccessory1?: boolean | ItemCountOutputTypeCountEquippedAsAccessory1Args
    equippedAsAccessory2?: boolean | ItemCountOutputTypeCountEquippedAsAccessory2Args
    bankVaultItems?: boolean | ItemCountOutputTypeCountBankVaultItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountShopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountMarketListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketListingWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsChestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsLegsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsAccessory1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountEquippedAsAccessory2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountBankVaultItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankVaultItemWhereInput
  }


  /**
   * Count Type GuildCountOutputType
   */

  export type GuildCountOutputType = {
    members: number
    quests: number
  }

  export type GuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GuildCountOutputTypeCountMembersArgs
    quests?: boolean | GuildCountOutputTypeCountQuestsArgs
  }

  // Custom InputTypes
  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildCountOutputType
     */
    select?: GuildCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildMemberWhereInput
  }

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildQuestWhereInput
  }


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    vaultItems: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaultItems?: boolean | BankAccountCountOutputTypeCountVaultItemsArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountVaultItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankVaultItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly name: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly createdById: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
    refresh_token_expires_in: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
    refresh_token_expires_in: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    refresh_token_expires_in: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
    refresh_token_expires_in?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
    refresh_token_expires_in?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "refresh_token_expires_in", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      refresh_token_expires_in: number | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly refresh_token_expires_in: FieldRef<"Account", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    player?: boolean | User$playerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    player?: boolean | User$playerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      password: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    player<T extends User$playerArgs<ExtArgs> = {}>(args?: Subset<T, User$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.player
   */
  export type User$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    level: number | null
    experience: number | null
    gold: number | null
    deathCount: number | null
  }

  export type PlayerSumAggregateOutputType = {
    level: number | null
    experience: number | null
    gold: number | null
    deathCount: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    characterName: string | null
    level: number | null
    experience: number | null
    gold: number | null
    deathCount: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    characterName: string | null
    level: number | null
    experience: number | null
    gold: number | null
    deathCount: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    userId: number
    characterName: number
    level: number
    experience: number
    gold: number
    deathCount: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    level?: true
    experience?: true
    gold?: true
    deathCount?: true
  }

  export type PlayerSumAggregateInputType = {
    level?: true
    experience?: true
    gold?: true
    deathCount?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    userId?: true
    characterName?: true
    level?: true
    experience?: true
    gold?: true
    deathCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    userId?: true
    characterName?: true
    level?: true
    experience?: true
    gold?: true
    deathCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    userId?: true
    characterName?: true
    level?: true
    experience?: true
    gold?: true
    deathCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    userId: string
    characterName: string
    level: number
    experience: number
    gold: number
    deathCount: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    gold?: boolean
    deathCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    position?: boolean | Player$positionArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    equipment?: boolean | Player$equipmentArgs<ExtArgs>
    occupation?: boolean | Player$occupationArgs<ExtArgs>
    guildMember?: boolean | Player$guildMemberArgs<ExtArgs>
    bankAccount?: boolean | Player$bankAccountArgs<ExtArgs>
    marketListings?: boolean | Player$marketListingsArgs<ExtArgs>
    combatLogs?: boolean | Player$combatLogsArgs<ExtArgs>
    deathLogs?: boolean | Player$deathLogsArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    gold?: boolean
    deathCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    gold?: boolean
    deathCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    userId?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    gold?: boolean
    deathCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "characterName" | "level" | "experience" | "gold" | "deathCount" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stats?: boolean | Player$statsArgs<ExtArgs>
    position?: boolean | Player$positionArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    equipment?: boolean | Player$equipmentArgs<ExtArgs>
    occupation?: boolean | Player$occupationArgs<ExtArgs>
    guildMember?: boolean | Player$guildMemberArgs<ExtArgs>
    bankAccount?: boolean | Player$bankAccountArgs<ExtArgs>
    marketListings?: boolean | Player$marketListingsArgs<ExtArgs>
    combatLogs?: boolean | Player$combatLogsArgs<ExtArgs>
    deathLogs?: boolean | Player$deathLogsArgs<ExtArgs>
    skills?: boolean | Player$skillsArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      stats: Prisma.$PlayerStatsPayload<ExtArgs> | null
      position: Prisma.$MapPositionPayload<ExtArgs> | null
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
      equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      occupation: Prisma.$OccupationPayload<ExtArgs> | null
      guildMember: Prisma.$GuildMemberPayload<ExtArgs> | null
      bankAccount: Prisma.$BankAccountPayload<ExtArgs> | null
      marketListings: Prisma.$MarketListingPayload<ExtArgs>[]
      combatLogs: Prisma.$CombatLogPayload<ExtArgs>[]
      deathLogs: Prisma.$DeathLogPayload<ExtArgs>[]
      skills: Prisma.$PlayerSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      characterName: string
      level: number
      experience: number
      gold: number
      deathCount: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stats<T extends Player$statsArgs<ExtArgs> = {}>(args?: Subset<T, Player$statsArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends Player$positionArgs<ExtArgs> = {}>(args?: Subset<T, Player$positionArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Player$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipment<T extends Player$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Player$equipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    occupation<T extends Player$occupationArgs<ExtArgs> = {}>(args?: Subset<T, Player$occupationArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guildMember<T extends Player$guildMemberArgs<ExtArgs> = {}>(args?: Subset<T, Player$guildMemberArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bankAccount<T extends Player$bankAccountArgs<ExtArgs> = {}>(args?: Subset<T, Player$bankAccountArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    marketListings<T extends Player$marketListingsArgs<ExtArgs> = {}>(args?: Subset<T, Player$marketListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    combatLogs<T extends Player$combatLogsArgs<ExtArgs> = {}>(args?: Subset<T, Player$combatLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deathLogs<T extends Player$deathLogsArgs<ExtArgs> = {}>(args?: Subset<T, Player$deathLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Player$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Player$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly userId: FieldRef<"Player", 'String'>
    readonly characterName: FieldRef<"Player", 'String'>
    readonly level: FieldRef<"Player", 'Int'>
    readonly experience: FieldRef<"Player", 'Int'>
    readonly gold: FieldRef<"Player", 'Int'>
    readonly deathCount: FieldRef<"Player", 'Int'>
    readonly isDeleted: FieldRef<"Player", 'Boolean'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.stats
   */
  export type Player$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    where?: PlayerStatsWhereInput
  }

  /**
   * Player.position
   */
  export type Player$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    where?: MapPositionWhereInput
  }

  /**
   * Player.inventory
   */
  export type Player$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Player.equipment
   */
  export type Player$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * Player.occupation
   */
  export type Player$occupationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    where?: OccupationWhereInput
  }

  /**
   * Player.guildMember
   */
  export type Player$guildMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    where?: GuildMemberWhereInput
  }

  /**
   * Player.bankAccount
   */
  export type Player$bankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
  }

  /**
   * Player.marketListings
   */
  export type Player$marketListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    where?: MarketListingWhereInput
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    cursor?: MarketListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * Player.combatLogs
   */
  export type Player$combatLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    where?: CombatLogWhereInput
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    cursor?: CombatLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * Player.deathLogs
   */
  export type Player$deathLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    where?: DeathLogWhereInput
    orderBy?: DeathLogOrderByWithRelationInput | DeathLogOrderByWithRelationInput[]
    cursor?: DeathLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeathLogScalarFieldEnum | DeathLogScalarFieldEnum[]
  }

  /**
   * Player.skills
   */
  export type Player$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    where?: PlayerSkillWhereInput
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    cursor?: PlayerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model PlayerStats
   */

  export type AggregatePlayerStats = {
    _count: PlayerStatsCountAggregateOutputType | null
    _avg: PlayerStatsAvgAggregateOutputType | null
    _sum: PlayerStatsSumAggregateOutputType | null
    _min: PlayerStatsMinAggregateOutputType | null
    _max: PlayerStatsMaxAggregateOutputType | null
  }

  export type PlayerStatsAvgAggregateOutputType = {
    vitality: number | null
    strength: number | null
    speed: number | null
    dexterity: number | null
    maxHP: number | null
    currentHP: number | null
    maxSP: number | null
    currentSP: number | null
    statPoints: number | null
  }

  export type PlayerStatsSumAggregateOutputType = {
    vitality: number | null
    strength: number | null
    speed: number | null
    dexterity: number | null
    maxHP: number | null
    currentHP: number | null
    maxSP: number | null
    currentSP: number | null
    statPoints: number | null
  }

  export type PlayerStatsMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    vitality: number | null
    strength: number | null
    speed: number | null
    dexterity: number | null
    maxHP: number | null
    currentHP: number | null
    maxSP: number | null
    currentSP: number | null
    statPoints: number | null
    updatedAt: Date | null
  }

  export type PlayerStatsMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    vitality: number | null
    strength: number | null
    speed: number | null
    dexterity: number | null
    maxHP: number | null
    currentHP: number | null
    maxSP: number | null
    currentSP: number | null
    statPoints: number | null
    updatedAt: Date | null
  }

  export type PlayerStatsCountAggregateOutputType = {
    id: number
    playerId: number
    vitality: number
    strength: number
    speed: number
    dexterity: number
    maxHP: number
    currentHP: number
    maxSP: number
    currentSP: number
    statPoints: number
    updatedAt: number
    _all: number
  }


  export type PlayerStatsAvgAggregateInputType = {
    vitality?: true
    strength?: true
    speed?: true
    dexterity?: true
    maxHP?: true
    currentHP?: true
    maxSP?: true
    currentSP?: true
    statPoints?: true
  }

  export type PlayerStatsSumAggregateInputType = {
    vitality?: true
    strength?: true
    speed?: true
    dexterity?: true
    maxHP?: true
    currentHP?: true
    maxSP?: true
    currentSP?: true
    statPoints?: true
  }

  export type PlayerStatsMinAggregateInputType = {
    id?: true
    playerId?: true
    vitality?: true
    strength?: true
    speed?: true
    dexterity?: true
    maxHP?: true
    currentHP?: true
    maxSP?: true
    currentSP?: true
    statPoints?: true
    updatedAt?: true
  }

  export type PlayerStatsMaxAggregateInputType = {
    id?: true
    playerId?: true
    vitality?: true
    strength?: true
    speed?: true
    dexterity?: true
    maxHP?: true
    currentHP?: true
    maxSP?: true
    currentSP?: true
    statPoints?: true
    updatedAt?: true
  }

  export type PlayerStatsCountAggregateInputType = {
    id?: true
    playerId?: true
    vitality?: true
    strength?: true
    speed?: true
    dexterity?: true
    maxHP?: true
    currentHP?: true
    maxSP?: true
    currentSP?: true
    statPoints?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStats to aggregate.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerStats
    **/
    _count?: true | PlayerStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerStatsMaxAggregateInputType
  }

  export type GetPlayerStatsAggregateType<T extends PlayerStatsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerStats[P]>
      : GetScalarType<T[P], AggregatePlayerStats[P]>
  }




  export type PlayerStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerStatsWhereInput
    orderBy?: PlayerStatsOrderByWithAggregationInput | PlayerStatsOrderByWithAggregationInput[]
    by: PlayerStatsScalarFieldEnum[] | PlayerStatsScalarFieldEnum
    having?: PlayerStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerStatsCountAggregateInputType | true
    _avg?: PlayerStatsAvgAggregateInputType
    _sum?: PlayerStatsSumAggregateInputType
    _min?: PlayerStatsMinAggregateInputType
    _max?: PlayerStatsMaxAggregateInputType
  }

  export type PlayerStatsGroupByOutputType = {
    id: string
    playerId: string
    vitality: number
    strength: number
    speed: number
    dexterity: number
    maxHP: number
    currentHP: number
    maxSP: number
    currentSP: number
    statPoints: number
    updatedAt: Date
    _count: PlayerStatsCountAggregateOutputType | null
    _avg: PlayerStatsAvgAggregateOutputType | null
    _sum: PlayerStatsSumAggregateOutputType | null
    _min: PlayerStatsMinAggregateOutputType | null
    _max: PlayerStatsMaxAggregateOutputType | null
  }

  type GetPlayerStatsGroupByPayload<T extends PlayerStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerStatsGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerStatsGroupByOutputType[P]>
        }
      >
    >


  export type PlayerStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    vitality?: boolean
    strength?: boolean
    speed?: boolean
    dexterity?: boolean
    maxHP?: boolean
    currentHP?: boolean
    maxSP?: boolean
    currentSP?: boolean
    statPoints?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStats"]>

  export type PlayerStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    vitality?: boolean
    strength?: boolean
    speed?: boolean
    dexterity?: boolean
    maxHP?: boolean
    currentHP?: boolean
    maxSP?: boolean
    currentSP?: boolean
    statPoints?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStats"]>

  export type PlayerStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    vitality?: boolean
    strength?: boolean
    speed?: boolean
    dexterity?: boolean
    maxHP?: boolean
    currentHP?: boolean
    maxSP?: boolean
    currentSP?: boolean
    statPoints?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStats"]>

  export type PlayerStatsSelectScalar = {
    id?: boolean
    playerId?: boolean
    vitality?: boolean
    strength?: boolean
    speed?: boolean
    dexterity?: boolean
    maxHP?: boolean
    currentHP?: boolean
    maxSP?: boolean
    currentSP?: boolean
    statPoints?: boolean
    updatedAt?: boolean
  }

  export type PlayerStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "vitality" | "strength" | "speed" | "dexterity" | "maxHP" | "currentHP" | "maxSP" | "currentSP" | "statPoints" | "updatedAt", ExtArgs["result"]["playerStats"]>
  export type PlayerStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlayerStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerStats"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      vitality: number
      strength: number
      speed: number
      dexterity: number
      maxHP: number
      currentHP: number
      maxSP: number
      currentSP: number
      statPoints: number
      updatedAt: Date
    }, ExtArgs["result"]["playerStats"]>
    composites: {}
  }

  type PlayerStatsGetPayload<S extends boolean | null | undefined | PlayerStatsDefaultArgs> = $Result.GetResult<Prisma.$PlayerStatsPayload, S>

  type PlayerStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerStatsCountAggregateInputType | true
    }

  export interface PlayerStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerStats'], meta: { name: 'PlayerStats' } }
    /**
     * Find zero or one PlayerStats that matches the filter.
     * @param {PlayerStatsFindUniqueArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerStatsFindUniqueArgs>(args: SelectSubset<T, PlayerStatsFindUniqueArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerStatsFindUniqueOrThrowArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindFirstArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerStatsFindFirstArgs>(args?: SelectSubset<T, PlayerStatsFindFirstArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindFirstOrThrowArgs} args - Arguments to find a PlayerStats
     * @example
     * // Get one PlayerStats
     * const playerStats = await prisma.playerStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerStats
     * const playerStats = await prisma.playerStats.findMany()
     * 
     * // Get first 10 PlayerStats
     * const playerStats = await prisma.playerStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerStatsWithIdOnly = await prisma.playerStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerStatsFindManyArgs>(args?: SelectSubset<T, PlayerStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerStats.
     * @param {PlayerStatsCreateArgs} args - Arguments to create a PlayerStats.
     * @example
     * // Create one PlayerStats
     * const PlayerStats = await prisma.playerStats.create({
     *   data: {
     *     // ... data to create a PlayerStats
     *   }
     * })
     * 
     */
    create<T extends PlayerStatsCreateArgs>(args: SelectSubset<T, PlayerStatsCreateArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerStats.
     * @param {PlayerStatsCreateManyArgs} args - Arguments to create many PlayerStats.
     * @example
     * // Create many PlayerStats
     * const playerStats = await prisma.playerStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerStatsCreateManyArgs>(args?: SelectSubset<T, PlayerStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerStats and returns the data saved in the database.
     * @param {PlayerStatsCreateManyAndReturnArgs} args - Arguments to create many PlayerStats.
     * @example
     * // Create many PlayerStats
     * const playerStats = await prisma.playerStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerStats and only return the `id`
     * const playerStatsWithIdOnly = await prisma.playerStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerStats.
     * @param {PlayerStatsDeleteArgs} args - Arguments to delete one PlayerStats.
     * @example
     * // Delete one PlayerStats
     * const PlayerStats = await prisma.playerStats.delete({
     *   where: {
     *     // ... filter to delete one PlayerStats
     *   }
     * })
     * 
     */
    delete<T extends PlayerStatsDeleteArgs>(args: SelectSubset<T, PlayerStatsDeleteArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerStats.
     * @param {PlayerStatsUpdateArgs} args - Arguments to update one PlayerStats.
     * @example
     * // Update one PlayerStats
     * const playerStats = await prisma.playerStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerStatsUpdateArgs>(args: SelectSubset<T, PlayerStatsUpdateArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerStats.
     * @param {PlayerStatsDeleteManyArgs} args - Arguments to filter PlayerStats to delete.
     * @example
     * // Delete a few PlayerStats
     * const { count } = await prisma.playerStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerStatsDeleteManyArgs>(args?: SelectSubset<T, PlayerStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerStats
     * const playerStats = await prisma.playerStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerStatsUpdateManyArgs>(args: SelectSubset<T, PlayerStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerStats and returns the data updated in the database.
     * @param {PlayerStatsUpdateManyAndReturnArgs} args - Arguments to update many PlayerStats.
     * @example
     * // Update many PlayerStats
     * const playerStats = await prisma.playerStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerStats and only return the `id`
     * const playerStatsWithIdOnly = await prisma.playerStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerStats.
     * @param {PlayerStatsUpsertArgs} args - Arguments to update or create a PlayerStats.
     * @example
     * // Update or create a PlayerStats
     * const playerStats = await prisma.playerStats.upsert({
     *   create: {
     *     // ... data to create a PlayerStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerStats we want to update
     *   }
     * })
     */
    upsert<T extends PlayerStatsUpsertArgs>(args: SelectSubset<T, PlayerStatsUpsertArgs<ExtArgs>>): Prisma__PlayerStatsClient<$Result.GetResult<Prisma.$PlayerStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsCountArgs} args - Arguments to filter PlayerStats to count.
     * @example
     * // Count the number of PlayerStats
     * const count = await prisma.playerStats.count({
     *   where: {
     *     // ... the filter for the PlayerStats we want to count
     *   }
     * })
    **/
    count<T extends PlayerStatsCountArgs>(
      args?: Subset<T, PlayerStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerStatsAggregateArgs>(args: Subset<T, PlayerStatsAggregateArgs>): Prisma.PrismaPromise<GetPlayerStatsAggregateType<T>>

    /**
     * Group by PlayerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerStatsGroupByArgs['orderBy'] }
        : { orderBy?: PlayerStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerStats model
   */
  readonly fields: PlayerStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerStats model
   */
  interface PlayerStatsFieldRefs {
    readonly id: FieldRef<"PlayerStats", 'String'>
    readonly playerId: FieldRef<"PlayerStats", 'String'>
    readonly vitality: FieldRef<"PlayerStats", 'Int'>
    readonly strength: FieldRef<"PlayerStats", 'Int'>
    readonly speed: FieldRef<"PlayerStats", 'Int'>
    readonly dexterity: FieldRef<"PlayerStats", 'Int'>
    readonly maxHP: FieldRef<"PlayerStats", 'Int'>
    readonly currentHP: FieldRef<"PlayerStats", 'Int'>
    readonly maxSP: FieldRef<"PlayerStats", 'Int'>
    readonly currentSP: FieldRef<"PlayerStats", 'Int'>
    readonly statPoints: FieldRef<"PlayerStats", 'Int'>
    readonly updatedAt: FieldRef<"PlayerStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerStats findUnique
   */
  export type PlayerStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats findUniqueOrThrow
   */
  export type PlayerStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats findFirst
   */
  export type PlayerStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStats.
     */
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats findFirstOrThrow
   */
  export type PlayerStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStats.
     */
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats findMany
   */
  export type PlayerStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStats to fetch.
     */
    where?: PlayerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStats to fetch.
     */
    orderBy?: PlayerStatsOrderByWithRelationInput | PlayerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerStats.
     */
    cursor?: PlayerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStats.
     */
    skip?: number
    distinct?: PlayerStatsScalarFieldEnum | PlayerStatsScalarFieldEnum[]
  }

  /**
   * PlayerStats create
   */
  export type PlayerStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerStats.
     */
    data: XOR<PlayerStatsCreateInput, PlayerStatsUncheckedCreateInput>
  }

  /**
   * PlayerStats createMany
   */
  export type PlayerStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerStats.
     */
    data: PlayerStatsCreateManyInput | PlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerStats createManyAndReturn
   */
  export type PlayerStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerStats.
     */
    data: PlayerStatsCreateManyInput | PlayerStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerStats update
   */
  export type PlayerStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerStats.
     */
    data: XOR<PlayerStatsUpdateInput, PlayerStatsUncheckedUpdateInput>
    /**
     * Choose, which PlayerStats to update.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats updateMany
   */
  export type PlayerStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerStats.
     */
    data: XOR<PlayerStatsUpdateManyMutationInput, PlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which PlayerStats to update
     */
    where?: PlayerStatsWhereInput
    /**
     * Limit how many PlayerStats to update.
     */
    limit?: number
  }

  /**
   * PlayerStats updateManyAndReturn
   */
  export type PlayerStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * The data used to update PlayerStats.
     */
    data: XOR<PlayerStatsUpdateManyMutationInput, PlayerStatsUncheckedUpdateManyInput>
    /**
     * Filter which PlayerStats to update
     */
    where?: PlayerStatsWhereInput
    /**
     * Limit how many PlayerStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerStats upsert
   */
  export type PlayerStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerStats to update in case it exists.
     */
    where: PlayerStatsWhereUniqueInput
    /**
     * In case the PlayerStats found by the `where` argument doesn't exist, create a new PlayerStats with this data.
     */
    create: XOR<PlayerStatsCreateInput, PlayerStatsUncheckedCreateInput>
    /**
     * In case the PlayerStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerStatsUpdateInput, PlayerStatsUncheckedUpdateInput>
  }

  /**
   * PlayerStats delete
   */
  export type PlayerStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
    /**
     * Filter which PlayerStats to delete.
     */
    where: PlayerStatsWhereUniqueInput
  }

  /**
   * PlayerStats deleteMany
   */
  export type PlayerStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStats to delete
     */
    where?: PlayerStatsWhereInput
    /**
     * Limit how many PlayerStats to delete.
     */
    limit?: number
  }

  /**
   * PlayerStats without action
   */
  export type PlayerStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStats
     */
    select?: PlayerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStats
     */
    omit?: PlayerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatsInclude<ExtArgs> | null
  }


  /**
   * Model MapTile
   */

  export type AggregateMapTile = {
    _count: MapTileCountAggregateOutputType | null
    _avg: MapTileAvgAggregateOutputType | null
    _sum: MapTileSumAggregateOutputType | null
    _min: MapTileMinAggregateOutputType | null
    _max: MapTileMaxAggregateOutputType | null
  }

  export type MapTileAvgAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
  }

  export type MapTileSumAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
  }

  export type MapTileMinAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    tileType: $Enums.TileType | null
    zoneType: $Enums.ZoneType | null
    isSafeZone: boolean | null
    hasResource: boolean | null
    resourceType: $Enums.ResourceType | null
    description: string | null
  }

  export type MapTileMaxAggregateOutputType = {
    id: number | null
    x: number | null
    y: number | null
    tileType: $Enums.TileType | null
    zoneType: $Enums.ZoneType | null
    isSafeZone: boolean | null
    hasResource: boolean | null
    resourceType: $Enums.ResourceType | null
    description: string | null
  }

  export type MapTileCountAggregateOutputType = {
    id: number
    x: number
    y: number
    tileType: number
    zoneType: number
    isSafeZone: number
    hasResource: number
    resourceType: number
    description: number
    _all: number
  }


  export type MapTileAvgAggregateInputType = {
    id?: true
    x?: true
    y?: true
  }

  export type MapTileSumAggregateInputType = {
    id?: true
    x?: true
    y?: true
  }

  export type MapTileMinAggregateInputType = {
    id?: true
    x?: true
    y?: true
    tileType?: true
    zoneType?: true
    isSafeZone?: true
    hasResource?: true
    resourceType?: true
    description?: true
  }

  export type MapTileMaxAggregateInputType = {
    id?: true
    x?: true
    y?: true
    tileType?: true
    zoneType?: true
    isSafeZone?: true
    hasResource?: true
    resourceType?: true
    description?: true
  }

  export type MapTileCountAggregateInputType = {
    id?: true
    x?: true
    y?: true
    tileType?: true
    zoneType?: true
    isSafeZone?: true
    hasResource?: true
    resourceType?: true
    description?: true
    _all?: true
  }

  export type MapTileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapTile to aggregate.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapTiles
    **/
    _count?: true | MapTileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapTileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapTileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapTileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapTileMaxAggregateInputType
  }

  export type GetMapTileAggregateType<T extends MapTileAggregateArgs> = {
        [P in keyof T & keyof AggregateMapTile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapTile[P]>
      : GetScalarType<T[P], AggregateMapTile[P]>
  }




  export type MapTileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapTileWhereInput
    orderBy?: MapTileOrderByWithAggregationInput | MapTileOrderByWithAggregationInput[]
    by: MapTileScalarFieldEnum[] | MapTileScalarFieldEnum
    having?: MapTileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapTileCountAggregateInputType | true
    _avg?: MapTileAvgAggregateInputType
    _sum?: MapTileSumAggregateInputType
    _min?: MapTileMinAggregateInputType
    _max?: MapTileMaxAggregateInputType
  }

  export type MapTileGroupByOutputType = {
    id: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone: boolean
    hasResource: boolean
    resourceType: $Enums.ResourceType | null
    description: string | null
    _count: MapTileCountAggregateOutputType | null
    _avg: MapTileAvgAggregateOutputType | null
    _sum: MapTileSumAggregateOutputType | null
    _min: MapTileMinAggregateOutputType | null
    _max: MapTileMaxAggregateOutputType | null
  }

  type GetMapTileGroupByPayload<T extends MapTileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapTileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapTileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapTileGroupByOutputType[P]>
            : GetScalarType<T[P], MapTileGroupByOutputType[P]>
        }
      >
    >


  export type MapTileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    tileType?: boolean
    zoneType?: boolean
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: boolean
    description?: boolean
    positions?: boolean | MapTile$positionsArgs<ExtArgs>
    npcs?: boolean | MapTile$npcsArgs<ExtArgs>
    encounters?: boolean | MapTile$encountersArgs<ExtArgs>
    _count?: boolean | MapTileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    tileType?: boolean
    zoneType?: boolean
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: boolean
    description?: boolean
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    x?: boolean
    y?: boolean
    tileType?: boolean
    zoneType?: boolean
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: boolean
    description?: boolean
  }, ExtArgs["result"]["mapTile"]>

  export type MapTileSelectScalar = {
    id?: boolean
    x?: boolean
    y?: boolean
    tileType?: boolean
    zoneType?: boolean
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: boolean
    description?: boolean
  }

  export type MapTileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "x" | "y" | "tileType" | "zoneType" | "isSafeZone" | "hasResource" | "resourceType" | "description", ExtArgs["result"]["mapTile"]>
  export type MapTileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | MapTile$positionsArgs<ExtArgs>
    npcs?: boolean | MapTile$npcsArgs<ExtArgs>
    encounters?: boolean | MapTile$encountersArgs<ExtArgs>
    _count?: boolean | MapTileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MapTileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MapTileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MapTilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapTile"
    objects: {
      positions: Prisma.$MapPositionPayload<ExtArgs>[]
      npcs: Prisma.$NPCPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      x: number
      y: number
      tileType: $Enums.TileType
      zoneType: $Enums.ZoneType
      isSafeZone: boolean
      hasResource: boolean
      resourceType: $Enums.ResourceType | null
      description: string | null
    }, ExtArgs["result"]["mapTile"]>
    composites: {}
  }

  type MapTileGetPayload<S extends boolean | null | undefined | MapTileDefaultArgs> = $Result.GetResult<Prisma.$MapTilePayload, S>

  type MapTileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapTileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapTileCountAggregateInputType | true
    }

  export interface MapTileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapTile'], meta: { name: 'MapTile' } }
    /**
     * Find zero or one MapTile that matches the filter.
     * @param {MapTileFindUniqueArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapTileFindUniqueArgs>(args: SelectSubset<T, MapTileFindUniqueArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapTile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapTileFindUniqueOrThrowArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapTileFindUniqueOrThrowArgs>(args: SelectSubset<T, MapTileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapTile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindFirstArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapTileFindFirstArgs>(args?: SelectSubset<T, MapTileFindFirstArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapTile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindFirstOrThrowArgs} args - Arguments to find a MapTile
     * @example
     * // Get one MapTile
     * const mapTile = await prisma.mapTile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapTileFindFirstOrThrowArgs>(args?: SelectSubset<T, MapTileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapTiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapTiles
     * const mapTiles = await prisma.mapTile.findMany()
     * 
     * // Get first 10 MapTiles
     * const mapTiles = await prisma.mapTile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapTileFindManyArgs>(args?: SelectSubset<T, MapTileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapTile.
     * @param {MapTileCreateArgs} args - Arguments to create a MapTile.
     * @example
     * // Create one MapTile
     * const MapTile = await prisma.mapTile.create({
     *   data: {
     *     // ... data to create a MapTile
     *   }
     * })
     * 
     */
    create<T extends MapTileCreateArgs>(args: SelectSubset<T, MapTileCreateArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapTiles.
     * @param {MapTileCreateManyArgs} args - Arguments to create many MapTiles.
     * @example
     * // Create many MapTiles
     * const mapTile = await prisma.mapTile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapTileCreateManyArgs>(args?: SelectSubset<T, MapTileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapTiles and returns the data saved in the database.
     * @param {MapTileCreateManyAndReturnArgs} args - Arguments to create many MapTiles.
     * @example
     * // Create many MapTiles
     * const mapTile = await prisma.mapTile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapTiles and only return the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapTileCreateManyAndReturnArgs>(args?: SelectSubset<T, MapTileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapTile.
     * @param {MapTileDeleteArgs} args - Arguments to delete one MapTile.
     * @example
     * // Delete one MapTile
     * const MapTile = await prisma.mapTile.delete({
     *   where: {
     *     // ... filter to delete one MapTile
     *   }
     * })
     * 
     */
    delete<T extends MapTileDeleteArgs>(args: SelectSubset<T, MapTileDeleteArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapTile.
     * @param {MapTileUpdateArgs} args - Arguments to update one MapTile.
     * @example
     * // Update one MapTile
     * const mapTile = await prisma.mapTile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapTileUpdateArgs>(args: SelectSubset<T, MapTileUpdateArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapTiles.
     * @param {MapTileDeleteManyArgs} args - Arguments to filter MapTiles to delete.
     * @example
     * // Delete a few MapTiles
     * const { count } = await prisma.mapTile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapTileDeleteManyArgs>(args?: SelectSubset<T, MapTileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapTiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapTiles
     * const mapTile = await prisma.mapTile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapTileUpdateManyArgs>(args: SelectSubset<T, MapTileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapTiles and returns the data updated in the database.
     * @param {MapTileUpdateManyAndReturnArgs} args - Arguments to update many MapTiles.
     * @example
     * // Update many MapTiles
     * const mapTile = await prisma.mapTile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapTiles and only return the `id`
     * const mapTileWithIdOnly = await prisma.mapTile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapTileUpdateManyAndReturnArgs>(args: SelectSubset<T, MapTileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapTile.
     * @param {MapTileUpsertArgs} args - Arguments to update or create a MapTile.
     * @example
     * // Update or create a MapTile
     * const mapTile = await prisma.mapTile.upsert({
     *   create: {
     *     // ... data to create a MapTile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapTile we want to update
     *   }
     * })
     */
    upsert<T extends MapTileUpsertArgs>(args: SelectSubset<T, MapTileUpsertArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapTiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileCountArgs} args - Arguments to filter MapTiles to count.
     * @example
     * // Count the number of MapTiles
     * const count = await prisma.mapTile.count({
     *   where: {
     *     // ... the filter for the MapTiles we want to count
     *   }
     * })
    **/
    count<T extends MapTileCountArgs>(
      args?: Subset<T, MapTileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapTileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapTile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapTileAggregateArgs>(args: Subset<T, MapTileAggregateArgs>): Prisma.PrismaPromise<GetMapTileAggregateType<T>>

    /**
     * Group by MapTile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapTileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapTileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapTileGroupByArgs['orderBy'] }
        : { orderBy?: MapTileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapTileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapTileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapTile model
   */
  readonly fields: MapTileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapTile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapTileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    positions<T extends MapTile$positionsArgs<ExtArgs> = {}>(args?: Subset<T, MapTile$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    npcs<T extends MapTile$npcsArgs<ExtArgs> = {}>(args?: Subset<T, MapTile$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends MapTile$encountersArgs<ExtArgs> = {}>(args?: Subset<T, MapTile$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapTile model
   */
  interface MapTileFieldRefs {
    readonly id: FieldRef<"MapTile", 'Int'>
    readonly x: FieldRef<"MapTile", 'Int'>
    readonly y: FieldRef<"MapTile", 'Int'>
    readonly tileType: FieldRef<"MapTile", 'TileType'>
    readonly zoneType: FieldRef<"MapTile", 'ZoneType'>
    readonly isSafeZone: FieldRef<"MapTile", 'Boolean'>
    readonly hasResource: FieldRef<"MapTile", 'Boolean'>
    readonly resourceType: FieldRef<"MapTile", 'ResourceType'>
    readonly description: FieldRef<"MapTile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MapTile findUnique
   */
  export type MapTileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile findUniqueOrThrow
   */
  export type MapTileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile findFirst
   */
  export type MapTileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapTiles.
     */
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile findFirstOrThrow
   */
  export type MapTileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTile to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapTiles.
     */
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile findMany
   */
  export type MapTileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter, which MapTiles to fetch.
     */
    where?: MapTileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapTiles to fetch.
     */
    orderBy?: MapTileOrderByWithRelationInput | MapTileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapTiles.
     */
    cursor?: MapTileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapTiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapTiles.
     */
    skip?: number
    distinct?: MapTileScalarFieldEnum | MapTileScalarFieldEnum[]
  }

  /**
   * MapTile create
   */
  export type MapTileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The data needed to create a MapTile.
     */
    data: XOR<MapTileCreateInput, MapTileUncheckedCreateInput>
  }

  /**
   * MapTile createMany
   */
  export type MapTileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapTiles.
     */
    data: MapTileCreateManyInput | MapTileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapTile createManyAndReturn
   */
  export type MapTileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * The data used to create many MapTiles.
     */
    data: MapTileCreateManyInput | MapTileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapTile update
   */
  export type MapTileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The data needed to update a MapTile.
     */
    data: XOR<MapTileUpdateInput, MapTileUncheckedUpdateInput>
    /**
     * Choose, which MapTile to update.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile updateMany
   */
  export type MapTileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapTiles.
     */
    data: XOR<MapTileUpdateManyMutationInput, MapTileUncheckedUpdateManyInput>
    /**
     * Filter which MapTiles to update
     */
    where?: MapTileWhereInput
    /**
     * Limit how many MapTiles to update.
     */
    limit?: number
  }

  /**
   * MapTile updateManyAndReturn
   */
  export type MapTileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * The data used to update MapTiles.
     */
    data: XOR<MapTileUpdateManyMutationInput, MapTileUncheckedUpdateManyInput>
    /**
     * Filter which MapTiles to update
     */
    where?: MapTileWhereInput
    /**
     * Limit how many MapTiles to update.
     */
    limit?: number
  }

  /**
   * MapTile upsert
   */
  export type MapTileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * The filter to search for the MapTile to update in case it exists.
     */
    where: MapTileWhereUniqueInput
    /**
     * In case the MapTile found by the `where` argument doesn't exist, create a new MapTile with this data.
     */
    create: XOR<MapTileCreateInput, MapTileUncheckedCreateInput>
    /**
     * In case the MapTile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapTileUpdateInput, MapTileUncheckedUpdateInput>
  }

  /**
   * MapTile delete
   */
  export type MapTileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    /**
     * Filter which MapTile to delete.
     */
    where: MapTileWhereUniqueInput
  }

  /**
   * MapTile deleteMany
   */
  export type MapTileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapTiles to delete
     */
    where?: MapTileWhereInput
    /**
     * Limit how many MapTiles to delete.
     */
    limit?: number
  }

  /**
   * MapTile.positions
   */
  export type MapTile$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    where?: MapPositionWhereInput
    orderBy?: MapPositionOrderByWithRelationInput | MapPositionOrderByWithRelationInput[]
    cursor?: MapPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapPositionScalarFieldEnum | MapPositionScalarFieldEnum[]
  }

  /**
   * MapTile.npcs
   */
  export type MapTile$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * MapTile.encounters
   */
  export type MapTile$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * MapTile without action
   */
  export type MapTileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
  }


  /**
   * Model MapPosition
   */

  export type AggregateMapPosition = {
    _count: MapPositionCountAggregateOutputType | null
    _avg: MapPositionAvgAggregateOutputType | null
    _sum: MapPositionSumAggregateOutputType | null
    _min: MapPositionMinAggregateOutputType | null
    _max: MapPositionMaxAggregateOutputType | null
  }

  export type MapPositionAvgAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
  }

  export type MapPositionSumAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
  }

  export type MapPositionMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    updatedAt: Date | null
  }

  export type MapPositionMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    updatedAt: Date | null
  }

  export type MapPositionCountAggregateOutputType = {
    id: number
    playerId: number
    tileX: number
    tileY: number
    tileId: number
    updatedAt: number
    _all: number
  }


  export type MapPositionAvgAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
  }

  export type MapPositionSumAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
  }

  export type MapPositionMinAggregateInputType = {
    id?: true
    playerId?: true
    tileX?: true
    tileY?: true
    tileId?: true
    updatedAt?: true
  }

  export type MapPositionMaxAggregateInputType = {
    id?: true
    playerId?: true
    tileX?: true
    tileY?: true
    tileId?: true
    updatedAt?: true
  }

  export type MapPositionCountAggregateInputType = {
    id?: true
    playerId?: true
    tileX?: true
    tileY?: true
    tileId?: true
    updatedAt?: true
    _all?: true
  }

  export type MapPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapPosition to aggregate.
     */
    where?: MapPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapPositions to fetch.
     */
    orderBy?: MapPositionOrderByWithRelationInput | MapPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapPositions
    **/
    _count?: true | MapPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapPositionMaxAggregateInputType
  }

  export type GetMapPositionAggregateType<T extends MapPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateMapPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapPosition[P]>
      : GetScalarType<T[P], AggregateMapPosition[P]>
  }




  export type MapPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapPositionWhereInput
    orderBy?: MapPositionOrderByWithAggregationInput | MapPositionOrderByWithAggregationInput[]
    by: MapPositionScalarFieldEnum[] | MapPositionScalarFieldEnum
    having?: MapPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapPositionCountAggregateInputType | true
    _avg?: MapPositionAvgAggregateInputType
    _sum?: MapPositionSumAggregateInputType
    _min?: MapPositionMinAggregateInputType
    _max?: MapPositionMaxAggregateInputType
  }

  export type MapPositionGroupByOutputType = {
    id: string
    playerId: string
    tileX: number
    tileY: number
    tileId: number | null
    updatedAt: Date
    _count: MapPositionCountAggregateOutputType | null
    _avg: MapPositionAvgAggregateOutputType | null
    _sum: MapPositionSumAggregateOutputType | null
    _min: MapPositionMinAggregateOutputType | null
    _max: MapPositionMaxAggregateOutputType | null
  }

  type GetMapPositionGroupByPayload<T extends MapPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapPositionGroupByOutputType[P]>
            : GetScalarType<T[P], MapPositionGroupByOutputType[P]>
        }
      >
    >


  export type MapPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }, ExtArgs["result"]["mapPosition"]>

  export type MapPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }, ExtArgs["result"]["mapPosition"]>

  export type MapPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }, ExtArgs["result"]["mapPosition"]>

  export type MapPositionSelectScalar = {
    id?: boolean
    playerId?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    updatedAt?: boolean
  }

  export type MapPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "tileX" | "tileY" | "tileId" | "updatedAt", ExtArgs["result"]["mapPosition"]>
  export type MapPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }
  export type MapPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }
  export type MapPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    tile?: boolean | MapPosition$tileArgs<ExtArgs>
  }

  export type $MapPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapPosition"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      tile: Prisma.$MapTilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      tileX: number
      tileY: number
      tileId: number | null
      updatedAt: Date
    }, ExtArgs["result"]["mapPosition"]>
    composites: {}
  }

  type MapPositionGetPayload<S extends boolean | null | undefined | MapPositionDefaultArgs> = $Result.GetResult<Prisma.$MapPositionPayload, S>

  type MapPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapPositionCountAggregateInputType | true
    }

  export interface MapPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapPosition'], meta: { name: 'MapPosition' } }
    /**
     * Find zero or one MapPosition that matches the filter.
     * @param {MapPositionFindUniqueArgs} args - Arguments to find a MapPosition
     * @example
     * // Get one MapPosition
     * const mapPosition = await prisma.mapPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapPositionFindUniqueArgs>(args: SelectSubset<T, MapPositionFindUniqueArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapPositionFindUniqueOrThrowArgs} args - Arguments to find a MapPosition
     * @example
     * // Get one MapPosition
     * const mapPosition = await prisma.mapPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, MapPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionFindFirstArgs} args - Arguments to find a MapPosition
     * @example
     * // Get one MapPosition
     * const mapPosition = await prisma.mapPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapPositionFindFirstArgs>(args?: SelectSubset<T, MapPositionFindFirstArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionFindFirstOrThrowArgs} args - Arguments to find a MapPosition
     * @example
     * // Get one MapPosition
     * const mapPosition = await prisma.mapPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, MapPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapPositions
     * const mapPositions = await prisma.mapPosition.findMany()
     * 
     * // Get first 10 MapPositions
     * const mapPositions = await prisma.mapPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapPositionWithIdOnly = await prisma.mapPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapPositionFindManyArgs>(args?: SelectSubset<T, MapPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapPosition.
     * @param {MapPositionCreateArgs} args - Arguments to create a MapPosition.
     * @example
     * // Create one MapPosition
     * const MapPosition = await prisma.mapPosition.create({
     *   data: {
     *     // ... data to create a MapPosition
     *   }
     * })
     * 
     */
    create<T extends MapPositionCreateArgs>(args: SelectSubset<T, MapPositionCreateArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapPositions.
     * @param {MapPositionCreateManyArgs} args - Arguments to create many MapPositions.
     * @example
     * // Create many MapPositions
     * const mapPosition = await prisma.mapPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapPositionCreateManyArgs>(args?: SelectSubset<T, MapPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapPositions and returns the data saved in the database.
     * @param {MapPositionCreateManyAndReturnArgs} args - Arguments to create many MapPositions.
     * @example
     * // Create many MapPositions
     * const mapPosition = await prisma.mapPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapPositions and only return the `id`
     * const mapPositionWithIdOnly = await prisma.mapPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, MapPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapPosition.
     * @param {MapPositionDeleteArgs} args - Arguments to delete one MapPosition.
     * @example
     * // Delete one MapPosition
     * const MapPosition = await prisma.mapPosition.delete({
     *   where: {
     *     // ... filter to delete one MapPosition
     *   }
     * })
     * 
     */
    delete<T extends MapPositionDeleteArgs>(args: SelectSubset<T, MapPositionDeleteArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapPosition.
     * @param {MapPositionUpdateArgs} args - Arguments to update one MapPosition.
     * @example
     * // Update one MapPosition
     * const mapPosition = await prisma.mapPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapPositionUpdateArgs>(args: SelectSubset<T, MapPositionUpdateArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapPositions.
     * @param {MapPositionDeleteManyArgs} args - Arguments to filter MapPositions to delete.
     * @example
     * // Delete a few MapPositions
     * const { count } = await prisma.mapPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapPositionDeleteManyArgs>(args?: SelectSubset<T, MapPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapPositions
     * const mapPosition = await prisma.mapPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapPositionUpdateManyArgs>(args: SelectSubset<T, MapPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapPositions and returns the data updated in the database.
     * @param {MapPositionUpdateManyAndReturnArgs} args - Arguments to update many MapPositions.
     * @example
     * // Update many MapPositions
     * const mapPosition = await prisma.mapPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapPositions and only return the `id`
     * const mapPositionWithIdOnly = await prisma.mapPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, MapPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapPosition.
     * @param {MapPositionUpsertArgs} args - Arguments to update or create a MapPosition.
     * @example
     * // Update or create a MapPosition
     * const mapPosition = await prisma.mapPosition.upsert({
     *   create: {
     *     // ... data to create a MapPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapPosition we want to update
     *   }
     * })
     */
    upsert<T extends MapPositionUpsertArgs>(args: SelectSubset<T, MapPositionUpsertArgs<ExtArgs>>): Prisma__MapPositionClient<$Result.GetResult<Prisma.$MapPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionCountArgs} args - Arguments to filter MapPositions to count.
     * @example
     * // Count the number of MapPositions
     * const count = await prisma.mapPosition.count({
     *   where: {
     *     // ... the filter for the MapPositions we want to count
     *   }
     * })
    **/
    count<T extends MapPositionCountArgs>(
      args?: Subset<T, MapPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapPositionAggregateArgs>(args: Subset<T, MapPositionAggregateArgs>): Prisma.PrismaPromise<GetMapPositionAggregateType<T>>

    /**
     * Group by MapPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapPositionGroupByArgs['orderBy'] }
        : { orderBy?: MapPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapPosition model
   */
  readonly fields: MapPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tile<T extends MapPosition$tileArgs<ExtArgs> = {}>(args?: Subset<T, MapPosition$tileArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapPosition model
   */
  interface MapPositionFieldRefs {
    readonly id: FieldRef<"MapPosition", 'String'>
    readonly playerId: FieldRef<"MapPosition", 'String'>
    readonly tileX: FieldRef<"MapPosition", 'Int'>
    readonly tileY: FieldRef<"MapPosition", 'Int'>
    readonly tileId: FieldRef<"MapPosition", 'Int'>
    readonly updatedAt: FieldRef<"MapPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MapPosition findUnique
   */
  export type MapPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter, which MapPosition to fetch.
     */
    where: MapPositionWhereUniqueInput
  }

  /**
   * MapPosition findUniqueOrThrow
   */
  export type MapPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter, which MapPosition to fetch.
     */
    where: MapPositionWhereUniqueInput
  }

  /**
   * MapPosition findFirst
   */
  export type MapPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter, which MapPosition to fetch.
     */
    where?: MapPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapPositions to fetch.
     */
    orderBy?: MapPositionOrderByWithRelationInput | MapPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapPositions.
     */
    cursor?: MapPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapPositions.
     */
    distinct?: MapPositionScalarFieldEnum | MapPositionScalarFieldEnum[]
  }

  /**
   * MapPosition findFirstOrThrow
   */
  export type MapPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter, which MapPosition to fetch.
     */
    where?: MapPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapPositions to fetch.
     */
    orderBy?: MapPositionOrderByWithRelationInput | MapPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapPositions.
     */
    cursor?: MapPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapPositions.
     */
    distinct?: MapPositionScalarFieldEnum | MapPositionScalarFieldEnum[]
  }

  /**
   * MapPosition findMany
   */
  export type MapPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter, which MapPositions to fetch.
     */
    where?: MapPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapPositions to fetch.
     */
    orderBy?: MapPositionOrderByWithRelationInput | MapPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapPositions.
     */
    cursor?: MapPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapPositions.
     */
    skip?: number
    distinct?: MapPositionScalarFieldEnum | MapPositionScalarFieldEnum[]
  }

  /**
   * MapPosition create
   */
  export type MapPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a MapPosition.
     */
    data: XOR<MapPositionCreateInput, MapPositionUncheckedCreateInput>
  }

  /**
   * MapPosition createMany
   */
  export type MapPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapPositions.
     */
    data: MapPositionCreateManyInput | MapPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapPosition createManyAndReturn
   */
  export type MapPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * The data used to create many MapPositions.
     */
    data: MapPositionCreateManyInput | MapPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapPosition update
   */
  export type MapPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a MapPosition.
     */
    data: XOR<MapPositionUpdateInput, MapPositionUncheckedUpdateInput>
    /**
     * Choose, which MapPosition to update.
     */
    where: MapPositionWhereUniqueInput
  }

  /**
   * MapPosition updateMany
   */
  export type MapPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapPositions.
     */
    data: XOR<MapPositionUpdateManyMutationInput, MapPositionUncheckedUpdateManyInput>
    /**
     * Filter which MapPositions to update
     */
    where?: MapPositionWhereInput
    /**
     * Limit how many MapPositions to update.
     */
    limit?: number
  }

  /**
   * MapPosition updateManyAndReturn
   */
  export type MapPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * The data used to update MapPositions.
     */
    data: XOR<MapPositionUpdateManyMutationInput, MapPositionUncheckedUpdateManyInput>
    /**
     * Filter which MapPositions to update
     */
    where?: MapPositionWhereInput
    /**
     * Limit how many MapPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapPosition upsert
   */
  export type MapPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the MapPosition to update in case it exists.
     */
    where: MapPositionWhereUniqueInput
    /**
     * In case the MapPosition found by the `where` argument doesn't exist, create a new MapPosition with this data.
     */
    create: XOR<MapPositionCreateInput, MapPositionUncheckedCreateInput>
    /**
     * In case the MapPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapPositionUpdateInput, MapPositionUncheckedUpdateInput>
  }

  /**
   * MapPosition delete
   */
  export type MapPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
    /**
     * Filter which MapPosition to delete.
     */
    where: MapPositionWhereUniqueInput
  }

  /**
   * MapPosition deleteMany
   */
  export type MapPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapPositions to delete
     */
    where?: MapPositionWhereInput
    /**
     * Limit how many MapPositions to delete.
     */
    limit?: number
  }

  /**
   * MapPosition.tile
   */
  export type MapPosition$tileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    where?: MapTileWhereInput
  }

  /**
   * MapPosition without action
   */
  export type MapPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapPosition
     */
    select?: MapPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapPosition
     */
    omit?: MapPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapPositionInclude<ExtArgs> | null
  }


  /**
   * Model NPC
   */

  export type AggregateNPC = {
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  export type NPCAvgAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
  }

  export type NPCSumAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
  }

  export type NPCMinAggregateOutputType = {
    id: string | null
    name: string | null
    npcType: $Enums.NPCType | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    dialogue: string | null
    createdAt: Date | null
  }

  export type NPCMaxAggregateOutputType = {
    id: string | null
    name: string | null
    npcType: $Enums.NPCType | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    dialogue: string | null
    createdAt: Date | null
  }

  export type NPCCountAggregateOutputType = {
    id: number
    name: number
    npcType: number
    tileX: number
    tileY: number
    tileId: number
    dialogue: number
    createdAt: number
    _all: number
  }


  export type NPCAvgAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
  }

  export type NPCSumAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
  }

  export type NPCMinAggregateInputType = {
    id?: true
    name?: true
    npcType?: true
    tileX?: true
    tileY?: true
    tileId?: true
    dialogue?: true
    createdAt?: true
  }

  export type NPCMaxAggregateInputType = {
    id?: true
    name?: true
    npcType?: true
    tileX?: true
    tileY?: true
    tileId?: true
    dialogue?: true
    createdAt?: true
  }

  export type NPCCountAggregateInputType = {
    id?: true
    name?: true
    npcType?: true
    tileX?: true
    tileY?: true
    tileId?: true
    dialogue?: true
    createdAt?: true
    _all?: true
  }

  export type NPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPC to aggregate.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCS
    **/
    _count?: true | NPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NPCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NPCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCMaxAggregateInputType
  }

  export type GetNPCAggregateType<T extends NPCAggregateArgs> = {
        [P in keyof T & keyof AggregateNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPC[P]>
      : GetScalarType<T[P], AggregateNPC[P]>
  }




  export type NPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithAggregationInput | NPCOrderByWithAggregationInput[]
    by: NPCScalarFieldEnum[] | NPCScalarFieldEnum
    having?: NPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCCountAggregateInputType | true
    _avg?: NPCAvgAggregateInputType
    _sum?: NPCSumAggregateInputType
    _min?: NPCMinAggregateInputType
    _max?: NPCMaxAggregateInputType
  }

  export type NPCGroupByOutputType = {
    id: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    tileId: number | null
    dialogue: string | null
    createdAt: Date
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  type GetNPCGroupByPayload<T extends NPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCGroupByOutputType[P]>
            : GetScalarType<T[P], NPCGroupByOutputType[P]>
        }
      >
    >


  export type NPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    npcType?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    dialogue?: boolean
    createdAt?: boolean
    tile?: boolean | NPC$tileArgs<ExtArgs>
    shopItems?: boolean | NPC$shopItemsArgs<ExtArgs>
    quests?: boolean | NPC$questsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    npcType?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    dialogue?: boolean
    createdAt?: boolean
    tile?: boolean | NPC$tileArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    npcType?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    dialogue?: boolean
    createdAt?: boolean
    tile?: boolean | NPC$tileArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectScalar = {
    id?: boolean
    name?: boolean
    npcType?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    dialogue?: boolean
    createdAt?: boolean
  }

  export type NPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "npcType" | "tileX" | "tileY" | "tileId" | "dialogue" | "createdAt", ExtArgs["result"]["nPC"]>
  export type NPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | NPC$tileArgs<ExtArgs>
    shopItems?: boolean | NPC$shopItemsArgs<ExtArgs>
    quests?: boolean | NPC$questsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | NPC$tileArgs<ExtArgs>
  }
  export type NPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | NPC$tileArgs<ExtArgs>
  }

  export type $NPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPC"
    objects: {
      tile: Prisma.$MapTilePayload<ExtArgs> | null
      shopItems: Prisma.$ShopItemPayload<ExtArgs>[]
      quests: Prisma.$QuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      npcType: $Enums.NPCType
      tileX: number
      tileY: number
      tileId: number | null
      dialogue: string | null
      createdAt: Date
    }, ExtArgs["result"]["nPC"]>
    composites: {}
  }

  type NPCGetPayload<S extends boolean | null | undefined | NPCDefaultArgs> = $Result.GetResult<Prisma.$NPCPayload, S>

  type NPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NPCCountAggregateInputType | true
    }

  export interface NPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPC'], meta: { name: 'NPC' } }
    /**
     * Find zero or one NPC that matches the filter.
     * @param {NPCFindUniqueArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCFindUniqueArgs>(args: SelectSubset<T, NPCFindUniqueArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NPCFindUniqueOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCFindFirstArgs>(args?: SelectSubset<T, NPCFindFirstArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCS
     * const nPCS = await prisma.nPC.findMany()
     * 
     * // Get first 10 NPCS
     * const nPCS = await prisma.nPC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPCWithIdOnly = await prisma.nPC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPCFindManyArgs>(args?: SelectSubset<T, NPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NPC.
     * @param {NPCCreateArgs} args - Arguments to create a NPC.
     * @example
     * // Create one NPC
     * const NPC = await prisma.nPC.create({
     *   data: {
     *     // ... data to create a NPC
     *   }
     * })
     * 
     */
    create<T extends NPCCreateArgs>(args: SelectSubset<T, NPCCreateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NPCS.
     * @param {NPCCreateManyArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCCreateManyArgs>(args?: SelectSubset<T, NPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCS and returns the data saved in the database.
     * @param {NPCCreateManyAndReturnArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NPC.
     * @param {NPCDeleteArgs} args - Arguments to delete one NPC.
     * @example
     * // Delete one NPC
     * const NPC = await prisma.nPC.delete({
     *   where: {
     *     // ... filter to delete one NPC
     *   }
     * })
     * 
     */
    delete<T extends NPCDeleteArgs>(args: SelectSubset<T, NPCDeleteArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NPC.
     * @param {NPCUpdateArgs} args - Arguments to update one NPC.
     * @example
     * // Update one NPC
     * const nPC = await prisma.nPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCUpdateArgs>(args: SelectSubset<T, NPCUpdateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NPCS.
     * @param {NPCDeleteManyArgs} args - Arguments to filter NPCS to delete.
     * @example
     * // Delete a few NPCS
     * const { count } = await prisma.nPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCDeleteManyArgs>(args?: SelectSubset<T, NPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCUpdateManyArgs>(args: SelectSubset<T, NPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS and returns the data updated in the database.
     * @param {NPCUpdateManyAndReturnArgs} args - Arguments to update many NPCS.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NPCUpdateManyAndReturnArgs>(args: SelectSubset<T, NPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NPC.
     * @param {NPCUpsertArgs} args - Arguments to update or create a NPC.
     * @example
     * // Update or create a NPC
     * const nPC = await prisma.nPC.upsert({
     *   create: {
     *     // ... data to create a NPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPC we want to update
     *   }
     * })
     */
    upsert<T extends NPCUpsertArgs>(args: SelectSubset<T, NPCUpsertArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCCountArgs} args - Arguments to filter NPCS to count.
     * @example
     * // Count the number of NPCS
     * const count = await prisma.nPC.count({
     *   where: {
     *     // ... the filter for the NPCS we want to count
     *   }
     * })
    **/
    count<T extends NPCCountArgs>(
      args?: Subset<T, NPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCAggregateArgs>(args: Subset<T, NPCAggregateArgs>): Prisma.PrismaPromise<GetNPCAggregateType<T>>

    /**
     * Group by NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCGroupByArgs['orderBy'] }
        : { orderBy?: NPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPC model
   */
  readonly fields: NPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tile<T extends NPC$tileArgs<ExtArgs> = {}>(args?: Subset<T, NPC$tileArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shopItems<T extends NPC$shopItemsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$shopItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quests<T extends NPC$questsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPC model
   */
  interface NPCFieldRefs {
    readonly id: FieldRef<"NPC", 'String'>
    readonly name: FieldRef<"NPC", 'String'>
    readonly npcType: FieldRef<"NPC", 'NPCType'>
    readonly tileX: FieldRef<"NPC", 'Int'>
    readonly tileY: FieldRef<"NPC", 'Int'>
    readonly tileId: FieldRef<"NPC", 'Int'>
    readonly dialogue: FieldRef<"NPC", 'String'>
    readonly createdAt: FieldRef<"NPC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NPC findUnique
   */
  export type NPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findUniqueOrThrow
   */
  export type NPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findFirst
   */
  export type NPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findFirstOrThrow
   */
  export type NPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findMany
   */
  export type NPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPCS to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC create
   */
  export type NPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to create a NPC.
     */
    data: XOR<NPCCreateInput, NPCUncheckedCreateInput>
  }

  /**
   * NPC createMany
   */
  export type NPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NPC createManyAndReturn
   */
  export type NPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC update
   */
  export type NPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to update a NPC.
     */
    data: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
    /**
     * Choose, which NPC to update.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC updateMany
   */
  export type NPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
  }

  /**
   * NPC updateManyAndReturn
   */
  export type NPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC upsert
   */
  export type NPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The filter to search for the NPC to update in case it exists.
     */
    where: NPCWhereUniqueInput
    /**
     * In case the NPC found by the `where` argument doesn't exist, create a new NPC with this data.
     */
    create: XOR<NPCCreateInput, NPCUncheckedCreateInput>
    /**
     * In case the NPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
  }

  /**
   * NPC delete
   */
  export type NPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter which NPC to delete.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC deleteMany
   */
  export type NPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCS to delete
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to delete.
     */
    limit?: number
  }

  /**
   * NPC.tile
   */
  export type NPC$tileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    where?: MapTileWhereInput
  }

  /**
   * NPC.shopItems
   */
  export type NPC$shopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    cursor?: ShopItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * NPC.quests
   */
  export type NPC$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * NPC without action
   */
  export type NPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
  }


  /**
   * Model ShopItem
   */

  export type AggregateShopItem = {
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  export type ShopItemAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ShopItemSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ShopItemMinAggregateOutputType = {
    id: string | null
    npcId: string | null
    itemId: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
  }

  export type ShopItemMaxAggregateOutputType = {
    id: string | null
    npcId: string | null
    itemId: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
  }

  export type ShopItemCountAggregateOutputType = {
    id: number
    npcId: number
    itemId: number
    price: number
    stock: number
    createdAt: number
    _all: number
  }


  export type ShopItemAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ShopItemSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ShopItemMinAggregateInputType = {
    id?: true
    npcId?: true
    itemId?: true
    price?: true
    stock?: true
    createdAt?: true
  }

  export type ShopItemMaxAggregateInputType = {
    id?: true
    npcId?: true
    itemId?: true
    price?: true
    stock?: true
    createdAt?: true
  }

  export type ShopItemCountAggregateInputType = {
    id?: true
    npcId?: true
    itemId?: true
    price?: true
    stock?: true
    createdAt?: true
    _all?: true
  }

  export type ShopItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItem to aggregate.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopItems
    **/
    _count?: true | ShopItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopItemMaxAggregateInputType
  }

  export type GetShopItemAggregateType<T extends ShopItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShopItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopItem[P]>
      : GetScalarType<T[P], AggregateShopItem[P]>
  }




  export type ShopItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithAggregationInput | ShopItemOrderByWithAggregationInput[]
    by: ShopItemScalarFieldEnum[] | ShopItemScalarFieldEnum
    having?: ShopItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopItemCountAggregateInputType | true
    _avg?: ShopItemAvgAggregateInputType
    _sum?: ShopItemSumAggregateInputType
    _min?: ShopItemMinAggregateInputType
    _max?: ShopItemMaxAggregateInputType
  }

  export type ShopItemGroupByOutputType = {
    id: string
    npcId: string
    itemId: string
    price: number
    stock: number | null
    createdAt: Date
    _count: ShopItemCountAggregateOutputType | null
    _avg: ShopItemAvgAggregateOutputType | null
    _sum: ShopItemSumAggregateOutputType | null
    _min: ShopItemMinAggregateOutputType | null
    _max: ShopItemMaxAggregateOutputType | null
  }

  type GetShopItemGroupByPayload<T extends ShopItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShopItemGroupByOutputType[P]>
        }
      >
    >


  export type ShopItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    itemId?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    itemId?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    itemId?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopItem"]>

  export type ShopItemSelectScalar = {
    id?: boolean
    npcId?: boolean
    itemId?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
  }

  export type ShopItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "npcId" | "itemId" | "price" | "stock" | "createdAt", ExtArgs["result"]["shopItem"]>
  export type ShopItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ShopItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ShopItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ShopItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopItem"
    objects: {
      npc: Prisma.$NPCPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      npcId: string
      itemId: string
      price: number
      stock: number | null
      createdAt: Date
    }, ExtArgs["result"]["shopItem"]>
    composites: {}
  }

  type ShopItemGetPayload<S extends boolean | null | undefined | ShopItemDefaultArgs> = $Result.GetResult<Prisma.$ShopItemPayload, S>

  type ShopItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopItemCountAggregateInputType | true
    }

  export interface ShopItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopItem'], meta: { name: 'ShopItem' } }
    /**
     * Find zero or one ShopItem that matches the filter.
     * @param {ShopItemFindUniqueArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopItemFindUniqueArgs>(args: SelectSubset<T, ShopItemFindUniqueArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopItemFindUniqueOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopItemFindFirstArgs>(args?: SelectSubset<T, ShopItemFindFirstArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindFirstOrThrowArgs} args - Arguments to find a ShopItem
     * @example
     * // Get one ShopItem
     * const shopItem = await prisma.shopItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopItems
     * const shopItems = await prisma.shopItem.findMany()
     * 
     * // Get first 10 ShopItems
     * const shopItems = await prisma.shopItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopItemFindManyArgs>(args?: SelectSubset<T, ShopItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopItem.
     * @param {ShopItemCreateArgs} args - Arguments to create a ShopItem.
     * @example
     * // Create one ShopItem
     * const ShopItem = await prisma.shopItem.create({
     *   data: {
     *     // ... data to create a ShopItem
     *   }
     * })
     * 
     */
    create<T extends ShopItemCreateArgs>(args: SelectSubset<T, ShopItemCreateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopItems.
     * @param {ShopItemCreateManyArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopItemCreateManyArgs>(args?: SelectSubset<T, ShopItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopItems and returns the data saved in the database.
     * @param {ShopItemCreateManyAndReturnArgs} args - Arguments to create many ShopItems.
     * @example
     * // Create many ShopItems
     * const shopItem = await prisma.shopItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopItems and only return the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopItem.
     * @param {ShopItemDeleteArgs} args - Arguments to delete one ShopItem.
     * @example
     * // Delete one ShopItem
     * const ShopItem = await prisma.shopItem.delete({
     *   where: {
     *     // ... filter to delete one ShopItem
     *   }
     * })
     * 
     */
    delete<T extends ShopItemDeleteArgs>(args: SelectSubset<T, ShopItemDeleteArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopItem.
     * @param {ShopItemUpdateArgs} args - Arguments to update one ShopItem.
     * @example
     * // Update one ShopItem
     * const shopItem = await prisma.shopItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopItemUpdateArgs>(args: SelectSubset<T, ShopItemUpdateArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopItems.
     * @param {ShopItemDeleteManyArgs} args - Arguments to filter ShopItems to delete.
     * @example
     * // Delete a few ShopItems
     * const { count } = await prisma.shopItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopItemDeleteManyArgs>(args?: SelectSubset<T, ShopItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopItemUpdateManyArgs>(args: SelectSubset<T, ShopItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopItems and returns the data updated in the database.
     * @param {ShopItemUpdateManyAndReturnArgs} args - Arguments to update many ShopItems.
     * @example
     * // Update many ShopItems
     * const shopItem = await prisma.shopItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopItems and only return the `id`
     * const shopItemWithIdOnly = await prisma.shopItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopItem.
     * @param {ShopItemUpsertArgs} args - Arguments to update or create a ShopItem.
     * @example
     * // Update or create a ShopItem
     * const shopItem = await prisma.shopItem.upsert({
     *   create: {
     *     // ... data to create a ShopItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopItem we want to update
     *   }
     * })
     */
    upsert<T extends ShopItemUpsertArgs>(args: SelectSubset<T, ShopItemUpsertArgs<ExtArgs>>): Prisma__ShopItemClient<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemCountArgs} args - Arguments to filter ShopItems to count.
     * @example
     * // Count the number of ShopItems
     * const count = await prisma.shopItem.count({
     *   where: {
     *     // ... the filter for the ShopItems we want to count
     *   }
     * })
    **/
    count<T extends ShopItemCountArgs>(
      args?: Subset<T, ShopItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopItemAggregateArgs>(args: Subset<T, ShopItemAggregateArgs>): Prisma.PrismaPromise<GetShopItemAggregateType<T>>

    /**
     * Group by ShopItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopItemGroupByArgs['orderBy'] }
        : { orderBy?: ShopItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopItem model
   */
  readonly fields: ShopItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopItem model
   */
  interface ShopItemFieldRefs {
    readonly id: FieldRef<"ShopItem", 'String'>
    readonly npcId: FieldRef<"ShopItem", 'String'>
    readonly itemId: FieldRef<"ShopItem", 'String'>
    readonly price: FieldRef<"ShopItem", 'Int'>
    readonly stock: FieldRef<"ShopItem", 'Int'>
    readonly createdAt: FieldRef<"ShopItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopItem findUnique
   */
  export type ShopItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findUniqueOrThrow
   */
  export type ShopItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem findFirst
   */
  export type ShopItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findFirstOrThrow
   */
  export type ShopItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItem to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopItems.
     */
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem findMany
   */
  export type ShopItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopItems to fetch.
     */
    where?: ShopItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopItems to fetch.
     */
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopItems.
     */
    cursor?: ShopItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopItems.
     */
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * ShopItem create
   */
  export type ShopItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopItem.
     */
    data: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
  }

  /**
   * ShopItem createMany
   */
  export type ShopItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopItem createManyAndReturn
   */
  export type ShopItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShopItems.
     */
    data: ShopItemCreateManyInput | ShopItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItem update
   */
  export type ShopItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopItem.
     */
    data: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
    /**
     * Choose, which ShopItem to update.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem updateMany
   */
  export type ShopItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to update.
     */
    limit?: number
  }

  /**
   * ShopItem updateManyAndReturn
   */
  export type ShopItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * The data used to update ShopItems.
     */
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopItems to update
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopItem upsert
   */
  export type ShopItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopItem to update in case it exists.
     */
    where: ShopItemWhereUniqueInput
    /**
     * In case the ShopItem found by the `where` argument doesn't exist, create a new ShopItem with this data.
     */
    create: XOR<ShopItemCreateInput, ShopItemUncheckedCreateInput>
    /**
     * In case the ShopItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopItemUpdateInput, ShopItemUncheckedUpdateInput>
  }

  /**
   * ShopItem delete
   */
  export type ShopItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    /**
     * Filter which ShopItem to delete.
     */
    where: ShopItemWhereUniqueInput
  }

  /**
   * ShopItem deleteMany
   */
  export type ShopItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopItems to delete
     */
    where?: ShopItemWhereInput
    /**
     * Limit how many ShopItems to delete.
     */
    limit?: number
  }

  /**
   * ShopItem without action
   */
  export type ShopItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    tier: number | null
    value: number | null
    maxStack: number | null
    vitalityBonus: number | null
    strengthBonus: number | null
    speedBonus: number | null
    dexterityBonus: number | null
    hpBonus: number | null
    spBonus: number | null
  }

  export type ItemSumAggregateOutputType = {
    tier: number | null
    value: number | null
    maxStack: number | null
    vitalityBonus: number | null
    strengthBonus: number | null
    speedBonus: number | null
    dexterityBonus: number | null
    hpBonus: number | null
    spBonus: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    itemType: $Enums.ItemType | null
    itemRarity: $Enums.ItemRarity | null
    tier: number | null
    value: number | null
    stackable: boolean | null
    maxStack: number | null
    equipmentSlot: $Enums.EquipmentSlot | null
    vitalityBonus: number | null
    strengthBonus: number | null
    speedBonus: number | null
    dexterityBonus: number | null
    hpBonus: number | null
    spBonus: number | null
    createdAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    itemType: $Enums.ItemType | null
    itemRarity: $Enums.ItemRarity | null
    tier: number | null
    value: number | null
    stackable: boolean | null
    maxStack: number | null
    equipmentSlot: $Enums.EquipmentSlot | null
    vitalityBonus: number | null
    strengthBonus: number | null
    speedBonus: number | null
    dexterityBonus: number | null
    hpBonus: number | null
    spBonus: number | null
    createdAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    itemType: number
    itemRarity: number
    tier: number
    value: number
    stackable: number
    maxStack: number
    equipmentSlot: number
    vitalityBonus: number
    strengthBonus: number
    speedBonus: number
    dexterityBonus: number
    hpBonus: number
    spBonus: number
    createdAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    tier?: true
    value?: true
    maxStack?: true
    vitalityBonus?: true
    strengthBonus?: true
    speedBonus?: true
    dexterityBonus?: true
    hpBonus?: true
    spBonus?: true
  }

  export type ItemSumAggregateInputType = {
    tier?: true
    value?: true
    maxStack?: true
    vitalityBonus?: true
    strengthBonus?: true
    speedBonus?: true
    dexterityBonus?: true
    hpBonus?: true
    spBonus?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    itemType?: true
    itemRarity?: true
    tier?: true
    value?: true
    stackable?: true
    maxStack?: true
    equipmentSlot?: true
    vitalityBonus?: true
    strengthBonus?: true
    speedBonus?: true
    dexterityBonus?: true
    hpBonus?: true
    spBonus?: true
    createdAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    itemType?: true
    itemRarity?: true
    tier?: true
    value?: true
    stackable?: true
    maxStack?: true
    equipmentSlot?: true
    vitalityBonus?: true
    strengthBonus?: true
    speedBonus?: true
    dexterityBonus?: true
    hpBonus?: true
    spBonus?: true
    createdAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    itemType?: true
    itemRarity?: true
    tier?: true
    value?: true
    stackable?: true
    maxStack?: true
    equipmentSlot?: true
    vitalityBonus?: true
    strengthBonus?: true
    speedBonus?: true
    dexterityBonus?: true
    hpBonus?: true
    spBonus?: true
    createdAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier: number
    value: number
    stackable: boolean
    maxStack: number
    equipmentSlot: $Enums.EquipmentSlot | null
    vitalityBonus: number
    strengthBonus: number
    speedBonus: number
    dexterityBonus: number
    hpBonus: number
    spBonus: number
    createdAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    itemType?: boolean
    itemRarity?: boolean
    tier?: boolean
    value?: boolean
    stackable?: boolean
    maxStack?: boolean
    equipmentSlot?: boolean
    vitalityBonus?: boolean
    strengthBonus?: boolean
    speedBonus?: boolean
    dexterityBonus?: boolean
    hpBonus?: boolean
    spBonus?: boolean
    createdAt?: boolean
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    shopItems?: boolean | Item$shopItemsArgs<ExtArgs>
    marketListings?: boolean | Item$marketListingsArgs<ExtArgs>
    equippedAsWeapon?: boolean | Item$equippedAsWeaponArgs<ExtArgs>
    equippedAsHead?: boolean | Item$equippedAsHeadArgs<ExtArgs>
    equippedAsChest?: boolean | Item$equippedAsChestArgs<ExtArgs>
    equippedAsLegs?: boolean | Item$equippedAsLegsArgs<ExtArgs>
    equippedAsFeet?: boolean | Item$equippedAsFeetArgs<ExtArgs>
    equippedAsAccessory1?: boolean | Item$equippedAsAccessory1Args<ExtArgs>
    equippedAsAccessory2?: boolean | Item$equippedAsAccessory2Args<ExtArgs>
    bankVaultItems?: boolean | Item$bankVaultItemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    itemType?: boolean
    itemRarity?: boolean
    tier?: boolean
    value?: boolean
    stackable?: boolean
    maxStack?: boolean
    equipmentSlot?: boolean
    vitalityBonus?: boolean
    strengthBonus?: boolean
    speedBonus?: boolean
    dexterityBonus?: boolean
    hpBonus?: boolean
    spBonus?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    itemType?: boolean
    itemRarity?: boolean
    tier?: boolean
    value?: boolean
    stackable?: boolean
    maxStack?: boolean
    equipmentSlot?: boolean
    vitalityBonus?: boolean
    strengthBonus?: boolean
    speedBonus?: boolean
    dexterityBonus?: boolean
    hpBonus?: boolean
    spBonus?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    itemType?: boolean
    itemRarity?: boolean
    tier?: boolean
    value?: boolean
    stackable?: boolean
    maxStack?: boolean
    equipmentSlot?: boolean
    vitalityBonus?: boolean
    strengthBonus?: boolean
    speedBonus?: boolean
    dexterityBonus?: boolean
    hpBonus?: boolean
    spBonus?: boolean
    createdAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "itemType" | "itemRarity" | "tier" | "value" | "stackable" | "maxStack" | "equipmentSlot" | "vitalityBonus" | "strengthBonus" | "speedBonus" | "dexterityBonus" | "hpBonus" | "spBonus" | "createdAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    shopItems?: boolean | Item$shopItemsArgs<ExtArgs>
    marketListings?: boolean | Item$marketListingsArgs<ExtArgs>
    equippedAsWeapon?: boolean | Item$equippedAsWeaponArgs<ExtArgs>
    equippedAsHead?: boolean | Item$equippedAsHeadArgs<ExtArgs>
    equippedAsChest?: boolean | Item$equippedAsChestArgs<ExtArgs>
    equippedAsLegs?: boolean | Item$equippedAsLegsArgs<ExtArgs>
    equippedAsFeet?: boolean | Item$equippedAsFeetArgs<ExtArgs>
    equippedAsAccessory1?: boolean | Item$equippedAsAccessory1Args<ExtArgs>
    equippedAsAccessory2?: boolean | Item$equippedAsAccessory2Args<ExtArgs>
    bankVaultItems?: boolean | Item$bankVaultItemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      shopItems: Prisma.$ShopItemPayload<ExtArgs>[]
      marketListings: Prisma.$MarketListingPayload<ExtArgs>[]
      equippedAsWeapon: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsHead: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsChest: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsLegs: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsFeet: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsAccessory1: Prisma.$EquipmentPayload<ExtArgs>[]
      equippedAsAccessory2: Prisma.$EquipmentPayload<ExtArgs>[]
      bankVaultItems: Prisma.$BankVaultItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      itemType: $Enums.ItemType
      itemRarity: $Enums.ItemRarity
      tier: number
      value: number
      stackable: boolean
      maxStack: number
      equipmentSlot: $Enums.EquipmentSlot | null
      vitalityBonus: number
      strengthBonus: number
      speedBonus: number
      dexterityBonus: number
      hpBonus: number
      spBonus: number
      createdAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Item$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shopItems<T extends Item$shopItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$shopItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketListings<T extends Item$marketListingsArgs<ExtArgs> = {}>(args?: Subset<T, Item$marketListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsWeapon<T extends Item$equippedAsWeaponArgs<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsWeaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsHead<T extends Item$equippedAsHeadArgs<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsHeadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsChest<T extends Item$equippedAsChestArgs<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsChestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsLegs<T extends Item$equippedAsLegsArgs<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsLegsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsFeet<T extends Item$equippedAsFeetArgs<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsFeetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsAccessory1<T extends Item$equippedAsAccessory1Args<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsAccessory1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equippedAsAccessory2<T extends Item$equippedAsAccessory2Args<ExtArgs> = {}>(args?: Subset<T, Item$equippedAsAccessory2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankVaultItems<T extends Item$bankVaultItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$bankVaultItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly itemType: FieldRef<"Item", 'ItemType'>
    readonly itemRarity: FieldRef<"Item", 'ItemRarity'>
    readonly tier: FieldRef<"Item", 'Int'>
    readonly value: FieldRef<"Item", 'Int'>
    readonly stackable: FieldRef<"Item", 'Boolean'>
    readonly maxStack: FieldRef<"Item", 'Int'>
    readonly equipmentSlot: FieldRef<"Item", 'EquipmentSlot'>
    readonly vitalityBonus: FieldRef<"Item", 'Int'>
    readonly strengthBonus: FieldRef<"Item", 'Int'>
    readonly speedBonus: FieldRef<"Item", 'Int'>
    readonly dexterityBonus: FieldRef<"Item", 'Int'>
    readonly hpBonus: FieldRef<"Item", 'Int'>
    readonly spBonus: FieldRef<"Item", 'Int'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.inventoryItems
   */
  export type Item$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Item.shopItems
   */
  export type Item$shopItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopItem
     */
    select?: ShopItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopItem
     */
    omit?: ShopItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopItemInclude<ExtArgs> | null
    where?: ShopItemWhereInput
    orderBy?: ShopItemOrderByWithRelationInput | ShopItemOrderByWithRelationInput[]
    cursor?: ShopItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopItemScalarFieldEnum | ShopItemScalarFieldEnum[]
  }

  /**
   * Item.marketListings
   */
  export type Item$marketListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    where?: MarketListingWhereInput
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    cursor?: MarketListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * Item.equippedAsWeapon
   */
  export type Item$equippedAsWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsHead
   */
  export type Item$equippedAsHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsChest
   */
  export type Item$equippedAsChestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsLegs
   */
  export type Item$equippedAsLegsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsFeet
   */
  export type Item$equippedAsFeetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsAccessory1
   */
  export type Item$equippedAsAccessory1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.equippedAsAccessory2
   */
  export type Item$equippedAsAccessory2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Item.bankVaultItems
   */
  export type Item$bankVaultItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    where?: BankVaultItemWhereInput
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    cursor?: BankVaultItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankVaultItemScalarFieldEnum | BankVaultItemScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    playerId: number
    itemId: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    playerId: string
    itemId: string
    quantity: number
    createdAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "itemId" | "quantity" | "createdAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      itemId: string
      quantity: number
      createdAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly playerId: FieldRef<"InventoryItem", 'String'>
    readonly itemId: FieldRef<"InventoryItem", 'String'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    weaponId: string | null
    headId: string | null
    chestId: string | null
    legsId: string | null
    feetId: string | null
    accessory1Id: string | null
    accessory2Id: string | null
    updatedAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    weaponId: string | null
    headId: string | null
    chestId: string | null
    legsId: string | null
    feetId: string | null
    accessory1Id: string | null
    accessory2Id: string | null
    updatedAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    playerId: number
    weaponId: number
    headId: number
    chestId: number
    legsId: number
    feetId: number
    accessory1Id: number
    accessory2Id: number
    updatedAt: number
    _all: number
  }


  export type EquipmentMinAggregateInputType = {
    id?: true
    playerId?: true
    weaponId?: true
    headId?: true
    chestId?: true
    legsId?: true
    feetId?: true
    accessory1Id?: true
    accessory2Id?: true
    updatedAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    playerId?: true
    weaponId?: true
    headId?: true
    chestId?: true
    legsId?: true
    feetId?: true
    accessory1Id?: true
    accessory2Id?: true
    updatedAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    playerId?: true
    weaponId?: true
    headId?: true
    chestId?: true
    legsId?: true
    feetId?: true
    accessory1Id?: true
    accessory2Id?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    playerId: string
    weaponId: string | null
    headId: string | null
    chestId: string | null
    legsId: string | null
    feetId: string | null
    accessory1Id: string | null
    accessory2Id: string | null
    updatedAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    weaponId?: boolean
    headId?: boolean
    chestId?: boolean
    legsId?: boolean
    feetId?: boolean
    accessory1Id?: boolean
    accessory2Id?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    weaponId?: boolean
    headId?: boolean
    chestId?: boolean
    legsId?: boolean
    feetId?: boolean
    accessory1Id?: boolean
    accessory2Id?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    weaponId?: boolean
    headId?: boolean
    chestId?: boolean
    legsId?: boolean
    feetId?: boolean
    accessory1Id?: boolean
    accessory2Id?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    playerId?: boolean
    weaponId?: boolean
    headId?: boolean
    chestId?: boolean
    legsId?: boolean
    feetId?: boolean
    accessory1Id?: boolean
    accessory2Id?: boolean
    updatedAt?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "weaponId" | "headId" | "chestId" | "legsId" | "feetId" | "accessory1Id" | "accessory2Id" | "updatedAt", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    weapon?: boolean | Equipment$weaponArgs<ExtArgs>
    head?: boolean | Equipment$headArgs<ExtArgs>
    chest?: boolean | Equipment$chestArgs<ExtArgs>
    legs?: boolean | Equipment$legsArgs<ExtArgs>
    feet?: boolean | Equipment$feetArgs<ExtArgs>
    accessory1?: boolean | Equipment$accessory1Args<ExtArgs>
    accessory2?: boolean | Equipment$accessory2Args<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      weapon: Prisma.$ItemPayload<ExtArgs> | null
      head: Prisma.$ItemPayload<ExtArgs> | null
      chest: Prisma.$ItemPayload<ExtArgs> | null
      legs: Prisma.$ItemPayload<ExtArgs> | null
      feet: Prisma.$ItemPayload<ExtArgs> | null
      accessory1: Prisma.$ItemPayload<ExtArgs> | null
      accessory2: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      weaponId: string | null
      headId: string | null
      chestId: string | null
      legsId: string | null
      feetId: string | null
      accessory1Id: string | null
      accessory2Id: string | null
      updatedAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weapon<T extends Equipment$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$weaponArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    head<T extends Equipment$headArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$headArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chest<T extends Equipment$chestArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$chestArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    legs<T extends Equipment$legsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$legsArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feet<T extends Equipment$feetArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$feetArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accessory1<T extends Equipment$accessory1Args<ExtArgs> = {}>(args?: Subset<T, Equipment$accessory1Args<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accessory2<T extends Equipment$accessory2Args<ExtArgs> = {}>(args?: Subset<T, Equipment$accessory2Args<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly playerId: FieldRef<"Equipment", 'String'>
    readonly weaponId: FieldRef<"Equipment", 'String'>
    readonly headId: FieldRef<"Equipment", 'String'>
    readonly chestId: FieldRef<"Equipment", 'String'>
    readonly legsId: FieldRef<"Equipment", 'String'>
    readonly feetId: FieldRef<"Equipment", 'String'>
    readonly accessory1Id: FieldRef<"Equipment", 'String'>
    readonly accessory2Id: FieldRef<"Equipment", 'String'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.weapon
   */
  export type Equipment$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.head
   */
  export type Equipment$headArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.chest
   */
  export type Equipment$chestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.legs
   */
  export type Equipment$legsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.feet
   */
  export type Equipment$feetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.accessory1
   */
  export type Equipment$accessory1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment.accessory2
   */
  export type Equipment$accessory2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Occupation
   */

  export type AggregateOccupation = {
    _count: OccupationCountAggregateOutputType | null
    _avg: OccupationAvgAggregateOutputType | null
    _sum: OccupationSumAggregateOutputType | null
    _min: OccupationMinAggregateOutputType | null
    _max: OccupationMaxAggregateOutputType | null
  }

  export type OccupationAvgAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type OccupationSumAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type OccupationMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    primaryJob: $Enums.PrimaryOccupation | null
    secondaryJob: $Enums.SecondaryOccupation | null
    level: number | null
    experience: number | null
    updatedAt: Date | null
  }

  export type OccupationMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    primaryJob: $Enums.PrimaryOccupation | null
    secondaryJob: $Enums.SecondaryOccupation | null
    level: number | null
    experience: number | null
    updatedAt: Date | null
  }

  export type OccupationCountAggregateOutputType = {
    id: number
    playerId: number
    primaryJob: number
    secondaryJob: number
    level: number
    experience: number
    updatedAt: number
    _all: number
  }


  export type OccupationAvgAggregateInputType = {
    level?: true
    experience?: true
  }

  export type OccupationSumAggregateInputType = {
    level?: true
    experience?: true
  }

  export type OccupationMinAggregateInputType = {
    id?: true
    playerId?: true
    primaryJob?: true
    secondaryJob?: true
    level?: true
    experience?: true
    updatedAt?: true
  }

  export type OccupationMaxAggregateInputType = {
    id?: true
    playerId?: true
    primaryJob?: true
    secondaryJob?: true
    level?: true
    experience?: true
    updatedAt?: true
  }

  export type OccupationCountAggregateInputType = {
    id?: true
    playerId?: true
    primaryJob?: true
    secondaryJob?: true
    level?: true
    experience?: true
    updatedAt?: true
    _all?: true
  }

  export type OccupationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occupation to aggregate.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Occupations
    **/
    _count?: true | OccupationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OccupationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OccupationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccupationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccupationMaxAggregateInputType
  }

  export type GetOccupationAggregateType<T extends OccupationAggregateArgs> = {
        [P in keyof T & keyof AggregateOccupation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccupation[P]>
      : GetScalarType<T[P], AggregateOccupation[P]>
  }




  export type OccupationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupationWhereInput
    orderBy?: OccupationOrderByWithAggregationInput | OccupationOrderByWithAggregationInput[]
    by: OccupationScalarFieldEnum[] | OccupationScalarFieldEnum
    having?: OccupationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccupationCountAggregateInputType | true
    _avg?: OccupationAvgAggregateInputType
    _sum?: OccupationSumAggregateInputType
    _min?: OccupationMinAggregateInputType
    _max?: OccupationMaxAggregateInputType
  }

  export type OccupationGroupByOutputType = {
    id: string
    playerId: string
    primaryJob: $Enums.PrimaryOccupation | null
    secondaryJob: $Enums.SecondaryOccupation | null
    level: number
    experience: number
    updatedAt: Date
    _count: OccupationCountAggregateOutputType | null
    _avg: OccupationAvgAggregateOutputType | null
    _sum: OccupationSumAggregateOutputType | null
    _min: OccupationMinAggregateOutputType | null
    _max: OccupationMaxAggregateOutputType | null
  }

  type GetOccupationGroupByPayload<T extends OccupationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccupationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccupationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccupationGroupByOutputType[P]>
            : GetScalarType<T[P], OccupationGroupByOutputType[P]>
        }
      >
    >


  export type OccupationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    primaryJob?: boolean
    secondaryJob?: boolean
    level?: boolean
    experience?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupation"]>

  export type OccupationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    primaryJob?: boolean
    secondaryJob?: boolean
    level?: boolean
    experience?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupation"]>

  export type OccupationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    primaryJob?: boolean
    secondaryJob?: boolean
    level?: boolean
    experience?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupation"]>

  export type OccupationSelectScalar = {
    id?: boolean
    playerId?: boolean
    primaryJob?: boolean
    secondaryJob?: boolean
    level?: boolean
    experience?: boolean
    updatedAt?: boolean
  }

  export type OccupationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "primaryJob" | "secondaryJob" | "level" | "experience" | "updatedAt", ExtArgs["result"]["occupation"]>
  export type OccupationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type OccupationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type OccupationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $OccupationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Occupation"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      primaryJob: $Enums.PrimaryOccupation | null
      secondaryJob: $Enums.SecondaryOccupation | null
      level: number
      experience: number
      updatedAt: Date
    }, ExtArgs["result"]["occupation"]>
    composites: {}
  }

  type OccupationGetPayload<S extends boolean | null | undefined | OccupationDefaultArgs> = $Result.GetResult<Prisma.$OccupationPayload, S>

  type OccupationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OccupationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OccupationCountAggregateInputType | true
    }

  export interface OccupationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Occupation'], meta: { name: 'Occupation' } }
    /**
     * Find zero or one Occupation that matches the filter.
     * @param {OccupationFindUniqueArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OccupationFindUniqueArgs>(args: SelectSubset<T, OccupationFindUniqueArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Occupation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OccupationFindUniqueOrThrowArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OccupationFindUniqueOrThrowArgs>(args: SelectSubset<T, OccupationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindFirstArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OccupationFindFirstArgs>(args?: SelectSubset<T, OccupationFindFirstArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindFirstOrThrowArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OccupationFindFirstOrThrowArgs>(args?: SelectSubset<T, OccupationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Occupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Occupations
     * const occupations = await prisma.occupation.findMany()
     * 
     * // Get first 10 Occupations
     * const occupations = await prisma.occupation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const occupationWithIdOnly = await prisma.occupation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OccupationFindManyArgs>(args?: SelectSubset<T, OccupationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Occupation.
     * @param {OccupationCreateArgs} args - Arguments to create a Occupation.
     * @example
     * // Create one Occupation
     * const Occupation = await prisma.occupation.create({
     *   data: {
     *     // ... data to create a Occupation
     *   }
     * })
     * 
     */
    create<T extends OccupationCreateArgs>(args: SelectSubset<T, OccupationCreateArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Occupations.
     * @param {OccupationCreateManyArgs} args - Arguments to create many Occupations.
     * @example
     * // Create many Occupations
     * const occupation = await prisma.occupation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OccupationCreateManyArgs>(args?: SelectSubset<T, OccupationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Occupations and returns the data saved in the database.
     * @param {OccupationCreateManyAndReturnArgs} args - Arguments to create many Occupations.
     * @example
     * // Create many Occupations
     * const occupation = await prisma.occupation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Occupations and only return the `id`
     * const occupationWithIdOnly = await prisma.occupation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OccupationCreateManyAndReturnArgs>(args?: SelectSubset<T, OccupationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Occupation.
     * @param {OccupationDeleteArgs} args - Arguments to delete one Occupation.
     * @example
     * // Delete one Occupation
     * const Occupation = await prisma.occupation.delete({
     *   where: {
     *     // ... filter to delete one Occupation
     *   }
     * })
     * 
     */
    delete<T extends OccupationDeleteArgs>(args: SelectSubset<T, OccupationDeleteArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Occupation.
     * @param {OccupationUpdateArgs} args - Arguments to update one Occupation.
     * @example
     * // Update one Occupation
     * const occupation = await prisma.occupation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OccupationUpdateArgs>(args: SelectSubset<T, OccupationUpdateArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Occupations.
     * @param {OccupationDeleteManyArgs} args - Arguments to filter Occupations to delete.
     * @example
     * // Delete a few Occupations
     * const { count } = await prisma.occupation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OccupationDeleteManyArgs>(args?: SelectSubset<T, OccupationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Occupations
     * const occupation = await prisma.occupation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OccupationUpdateManyArgs>(args: SelectSubset<T, OccupationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occupations and returns the data updated in the database.
     * @param {OccupationUpdateManyAndReturnArgs} args - Arguments to update many Occupations.
     * @example
     * // Update many Occupations
     * const occupation = await prisma.occupation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Occupations and only return the `id`
     * const occupationWithIdOnly = await prisma.occupation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OccupationUpdateManyAndReturnArgs>(args: SelectSubset<T, OccupationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Occupation.
     * @param {OccupationUpsertArgs} args - Arguments to update or create a Occupation.
     * @example
     * // Update or create a Occupation
     * const occupation = await prisma.occupation.upsert({
     *   create: {
     *     // ... data to create a Occupation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Occupation we want to update
     *   }
     * })
     */
    upsert<T extends OccupationUpsertArgs>(args: SelectSubset<T, OccupationUpsertArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationCountArgs} args - Arguments to filter Occupations to count.
     * @example
     * // Count the number of Occupations
     * const count = await prisma.occupation.count({
     *   where: {
     *     // ... the filter for the Occupations we want to count
     *   }
     * })
    **/
    count<T extends OccupationCountArgs>(
      args?: Subset<T, OccupationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccupationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Occupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccupationAggregateArgs>(args: Subset<T, OccupationAggregateArgs>): Prisma.PrismaPromise<GetOccupationAggregateType<T>>

    /**
     * Group by Occupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccupationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccupationGroupByArgs['orderBy'] }
        : { orderBy?: OccupationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccupationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccupationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Occupation model
   */
  readonly fields: OccupationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Occupation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccupationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Occupation model
   */
  interface OccupationFieldRefs {
    readonly id: FieldRef<"Occupation", 'String'>
    readonly playerId: FieldRef<"Occupation", 'String'>
    readonly primaryJob: FieldRef<"Occupation", 'PrimaryOccupation'>
    readonly secondaryJob: FieldRef<"Occupation", 'SecondaryOccupation'>
    readonly level: FieldRef<"Occupation", 'Int'>
    readonly experience: FieldRef<"Occupation", 'Int'>
    readonly updatedAt: FieldRef<"Occupation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Occupation findUnique
   */
  export type OccupationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation findUniqueOrThrow
   */
  export type OccupationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation findFirst
   */
  export type OccupationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occupations.
     */
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation findFirstOrThrow
   */
  export type OccupationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occupations.
     */
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation findMany
   */
  export type OccupationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupations to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation create
   */
  export type OccupationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The data needed to create a Occupation.
     */
    data: XOR<OccupationCreateInput, OccupationUncheckedCreateInput>
  }

  /**
   * Occupation createMany
   */
  export type OccupationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Occupations.
     */
    data: OccupationCreateManyInput | OccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Occupation createManyAndReturn
   */
  export type OccupationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * The data used to create many Occupations.
     */
    data: OccupationCreateManyInput | OccupationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Occupation update
   */
  export type OccupationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The data needed to update a Occupation.
     */
    data: XOR<OccupationUpdateInput, OccupationUncheckedUpdateInput>
    /**
     * Choose, which Occupation to update.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation updateMany
   */
  export type OccupationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Occupations.
     */
    data: XOR<OccupationUpdateManyMutationInput, OccupationUncheckedUpdateManyInput>
    /**
     * Filter which Occupations to update
     */
    where?: OccupationWhereInput
    /**
     * Limit how many Occupations to update.
     */
    limit?: number
  }

  /**
   * Occupation updateManyAndReturn
   */
  export type OccupationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * The data used to update Occupations.
     */
    data: XOR<OccupationUpdateManyMutationInput, OccupationUncheckedUpdateManyInput>
    /**
     * Filter which Occupations to update
     */
    where?: OccupationWhereInput
    /**
     * Limit how many Occupations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Occupation upsert
   */
  export type OccupationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The filter to search for the Occupation to update in case it exists.
     */
    where: OccupationWhereUniqueInput
    /**
     * In case the Occupation found by the `where` argument doesn't exist, create a new Occupation with this data.
     */
    create: XOR<OccupationCreateInput, OccupationUncheckedCreateInput>
    /**
     * In case the Occupation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccupationUpdateInput, OccupationUncheckedUpdateInput>
  }

  /**
   * Occupation delete
   */
  export type OccupationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter which Occupation to delete.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation deleteMany
   */
  export type OccupationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occupations to delete
     */
    where?: OccupationWhereInput
    /**
     * Limit how many Occupations to delete.
     */
    limit?: number
  }

  /**
   * Occupation without action
   */
  export type OccupationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
  }


  /**
   * Model PlayerSkill
   */

  export type AggregatePlayerSkill = {
    _count: PlayerSkillCountAggregateOutputType | null
    _avg: PlayerSkillAvgAggregateOutputType | null
    _sum: PlayerSkillSumAggregateOutputType | null
    _min: PlayerSkillMinAggregateOutputType | null
    _max: PlayerSkillMaxAggregateOutputType | null
  }

  export type PlayerSkillAvgAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type PlayerSkillSumAggregateOutputType = {
    level: number | null
    experience: number | null
  }

  export type PlayerSkillMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    skillName: string | null
    level: number | null
    experience: number | null
    createdAt: Date | null
  }

  export type PlayerSkillMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    skillName: string | null
    level: number | null
    experience: number | null
    createdAt: Date | null
  }

  export type PlayerSkillCountAggregateOutputType = {
    id: number
    playerId: number
    skillName: number
    level: number
    experience: number
    createdAt: number
    _all: number
  }


  export type PlayerSkillAvgAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerSkillSumAggregateInputType = {
    level?: true
    experience?: true
  }

  export type PlayerSkillMinAggregateInputType = {
    id?: true
    playerId?: true
    skillName?: true
    level?: true
    experience?: true
    createdAt?: true
  }

  export type PlayerSkillMaxAggregateInputType = {
    id?: true
    playerId?: true
    skillName?: true
    level?: true
    experience?: true
    createdAt?: true
  }

  export type PlayerSkillCountAggregateInputType = {
    id?: true
    playerId?: true
    skillName?: true
    level?: true
    experience?: true
    createdAt?: true
    _all?: true
  }

  export type PlayerSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkill to aggregate.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerSkills
    **/
    _count?: true | PlayerSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerSkillMaxAggregateInputType
  }

  export type GetPlayerSkillAggregateType<T extends PlayerSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerSkill[P]>
      : GetScalarType<T[P], AggregatePlayerSkill[P]>
  }




  export type PlayerSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerSkillWhereInput
    orderBy?: PlayerSkillOrderByWithAggregationInput | PlayerSkillOrderByWithAggregationInput[]
    by: PlayerSkillScalarFieldEnum[] | PlayerSkillScalarFieldEnum
    having?: PlayerSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerSkillCountAggregateInputType | true
    _avg?: PlayerSkillAvgAggregateInputType
    _sum?: PlayerSkillSumAggregateInputType
    _min?: PlayerSkillMinAggregateInputType
    _max?: PlayerSkillMaxAggregateInputType
  }

  export type PlayerSkillGroupByOutputType = {
    id: string
    playerId: string
    skillName: string
    level: number
    experience: number
    createdAt: Date
    _count: PlayerSkillCountAggregateOutputType | null
    _avg: PlayerSkillAvgAggregateOutputType | null
    _sum: PlayerSkillSumAggregateOutputType | null
    _min: PlayerSkillMinAggregateOutputType | null
    _max: PlayerSkillMaxAggregateOutputType | null
  }

  type GetPlayerSkillGroupByPayload<T extends PlayerSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerSkillGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillName?: boolean
    level?: boolean
    experience?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkill"]>

  export type PlayerSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillName?: boolean
    level?: boolean
    experience?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkill"]>

  export type PlayerSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    skillName?: boolean
    level?: boolean
    experience?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerSkill"]>

  export type PlayerSkillSelectScalar = {
    id?: boolean
    playerId?: boolean
    skillName?: boolean
    level?: boolean
    experience?: boolean
    createdAt?: boolean
  }

  export type PlayerSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "skillName" | "level" | "experience" | "createdAt", ExtArgs["result"]["playerSkill"]>
  export type PlayerSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PlayerSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PlayerSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerSkill"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      skillName: string
      level: number
      experience: number
      createdAt: Date
    }, ExtArgs["result"]["playerSkill"]>
    composites: {}
  }

  type PlayerSkillGetPayload<S extends boolean | null | undefined | PlayerSkillDefaultArgs> = $Result.GetResult<Prisma.$PlayerSkillPayload, S>

  type PlayerSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerSkillCountAggregateInputType | true
    }

  export interface PlayerSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerSkill'], meta: { name: 'PlayerSkill' } }
    /**
     * Find zero or one PlayerSkill that matches the filter.
     * @param {PlayerSkillFindUniqueArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerSkillFindUniqueArgs>(args: SelectSubset<T, PlayerSkillFindUniqueArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerSkillFindUniqueOrThrowArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindFirstArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerSkillFindFirstArgs>(args?: SelectSubset<T, PlayerSkillFindFirstArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindFirstOrThrowArgs} args - Arguments to find a PlayerSkill
     * @example
     * // Get one PlayerSkill
     * const playerSkill = await prisma.playerSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerSkills
     * const playerSkills = await prisma.playerSkill.findMany()
     * 
     * // Get first 10 PlayerSkills
     * const playerSkills = await prisma.playerSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerSkillWithIdOnly = await prisma.playerSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerSkillFindManyArgs>(args?: SelectSubset<T, PlayerSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerSkill.
     * @param {PlayerSkillCreateArgs} args - Arguments to create a PlayerSkill.
     * @example
     * // Create one PlayerSkill
     * const PlayerSkill = await prisma.playerSkill.create({
     *   data: {
     *     // ... data to create a PlayerSkill
     *   }
     * })
     * 
     */
    create<T extends PlayerSkillCreateArgs>(args: SelectSubset<T, PlayerSkillCreateArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerSkills.
     * @param {PlayerSkillCreateManyArgs} args - Arguments to create many PlayerSkills.
     * @example
     * // Create many PlayerSkills
     * const playerSkill = await prisma.playerSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerSkillCreateManyArgs>(args?: SelectSubset<T, PlayerSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerSkills and returns the data saved in the database.
     * @param {PlayerSkillCreateManyAndReturnArgs} args - Arguments to create many PlayerSkills.
     * @example
     * // Create many PlayerSkills
     * const playerSkill = await prisma.playerSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerSkills and only return the `id`
     * const playerSkillWithIdOnly = await prisma.playerSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerSkill.
     * @param {PlayerSkillDeleteArgs} args - Arguments to delete one PlayerSkill.
     * @example
     * // Delete one PlayerSkill
     * const PlayerSkill = await prisma.playerSkill.delete({
     *   where: {
     *     // ... filter to delete one PlayerSkill
     *   }
     * })
     * 
     */
    delete<T extends PlayerSkillDeleteArgs>(args: SelectSubset<T, PlayerSkillDeleteArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerSkill.
     * @param {PlayerSkillUpdateArgs} args - Arguments to update one PlayerSkill.
     * @example
     * // Update one PlayerSkill
     * const playerSkill = await prisma.playerSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerSkillUpdateArgs>(args: SelectSubset<T, PlayerSkillUpdateArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerSkills.
     * @param {PlayerSkillDeleteManyArgs} args - Arguments to filter PlayerSkills to delete.
     * @example
     * // Delete a few PlayerSkills
     * const { count } = await prisma.playerSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerSkillDeleteManyArgs>(args?: SelectSubset<T, PlayerSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerSkills
     * const playerSkill = await prisma.playerSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerSkillUpdateManyArgs>(args: SelectSubset<T, PlayerSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkills and returns the data updated in the database.
     * @param {PlayerSkillUpdateManyAndReturnArgs} args - Arguments to update many PlayerSkills.
     * @example
     * // Update many PlayerSkills
     * const playerSkill = await prisma.playerSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerSkills and only return the `id`
     * const playerSkillWithIdOnly = await prisma.playerSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerSkill.
     * @param {PlayerSkillUpsertArgs} args - Arguments to update or create a PlayerSkill.
     * @example
     * // Update or create a PlayerSkill
     * const playerSkill = await prisma.playerSkill.upsert({
     *   create: {
     *     // ... data to create a PlayerSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerSkill we want to update
     *   }
     * })
     */
    upsert<T extends PlayerSkillUpsertArgs>(args: SelectSubset<T, PlayerSkillUpsertArgs<ExtArgs>>): Prisma__PlayerSkillClient<$Result.GetResult<Prisma.$PlayerSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillCountArgs} args - Arguments to filter PlayerSkills to count.
     * @example
     * // Count the number of PlayerSkills
     * const count = await prisma.playerSkill.count({
     *   where: {
     *     // ... the filter for the PlayerSkills we want to count
     *   }
     * })
    **/
    count<T extends PlayerSkillCountArgs>(
      args?: Subset<T, PlayerSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerSkillAggregateArgs>(args: Subset<T, PlayerSkillAggregateArgs>): Prisma.PrismaPromise<GetPlayerSkillAggregateType<T>>

    /**
     * Group by PlayerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerSkillGroupByArgs['orderBy'] }
        : { orderBy?: PlayerSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerSkill model
   */
  readonly fields: PlayerSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerSkill model
   */
  interface PlayerSkillFieldRefs {
    readonly id: FieldRef<"PlayerSkill", 'String'>
    readonly playerId: FieldRef<"PlayerSkill", 'String'>
    readonly skillName: FieldRef<"PlayerSkill", 'String'>
    readonly level: FieldRef<"PlayerSkill", 'Int'>
    readonly experience: FieldRef<"PlayerSkill", 'Int'>
    readonly createdAt: FieldRef<"PlayerSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerSkill findUnique
   */
  export type PlayerSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill findUniqueOrThrow
   */
  export type PlayerSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill findFirst
   */
  export type PlayerSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkills.
     */
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill findFirstOrThrow
   */
  export type PlayerSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkill to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkills.
     */
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill findMany
   */
  export type PlayerSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter, which PlayerSkills to fetch.
     */
    where?: PlayerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkills to fetch.
     */
    orderBy?: PlayerSkillOrderByWithRelationInput | PlayerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerSkills.
     */
    cursor?: PlayerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkills.
     */
    skip?: number
    distinct?: PlayerSkillScalarFieldEnum | PlayerSkillScalarFieldEnum[]
  }

  /**
   * PlayerSkill create
   */
  export type PlayerSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerSkill.
     */
    data: XOR<PlayerSkillCreateInput, PlayerSkillUncheckedCreateInput>
  }

  /**
   * PlayerSkill createMany
   */
  export type PlayerSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerSkills.
     */
    data: PlayerSkillCreateManyInput | PlayerSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerSkill createManyAndReturn
   */
  export type PlayerSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerSkills.
     */
    data: PlayerSkillCreateManyInput | PlayerSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerSkill update
   */
  export type PlayerSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerSkill.
     */
    data: XOR<PlayerSkillUpdateInput, PlayerSkillUncheckedUpdateInput>
    /**
     * Choose, which PlayerSkill to update.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill updateMany
   */
  export type PlayerSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerSkills.
     */
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkills to update
     */
    where?: PlayerSkillWhereInput
    /**
     * Limit how many PlayerSkills to update.
     */
    limit?: number
  }

  /**
   * PlayerSkill updateManyAndReturn
   */
  export type PlayerSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * The data used to update PlayerSkills.
     */
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkills to update
     */
    where?: PlayerSkillWhereInput
    /**
     * Limit how many PlayerSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerSkill upsert
   */
  export type PlayerSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerSkill to update in case it exists.
     */
    where: PlayerSkillWhereUniqueInput
    /**
     * In case the PlayerSkill found by the `where` argument doesn't exist, create a new PlayerSkill with this data.
     */
    create: XOR<PlayerSkillCreateInput, PlayerSkillUncheckedCreateInput>
    /**
     * In case the PlayerSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerSkillUpdateInput, PlayerSkillUncheckedUpdateInput>
  }

  /**
   * PlayerSkill delete
   */
  export type PlayerSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
    /**
     * Filter which PlayerSkill to delete.
     */
    where: PlayerSkillWhereUniqueInput
  }

  /**
   * PlayerSkill deleteMany
   */
  export type PlayerSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerSkills to delete
     */
    where?: PlayerSkillWhereInput
    /**
     * Limit how many PlayerSkills to delete.
     */
    limit?: number
  }

  /**
   * PlayerSkill without action
   */
  export type PlayerSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerSkill
     */
    select?: PlayerSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerSkill
     */
    omit?: PlayerSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerSkillInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterAvgAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
    enemyLevel: number | null
  }

  export type EncounterSumAggregateOutputType = {
    tileX: number | null
    tileY: number | null
    tileId: number | null
    enemyLevel: number | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    enemyType: string | null
    enemyLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    tileX: number | null
    tileY: number | null
    tileId: number | null
    enemyType: string | null
    enemyLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    tileX: number
    tileY: number
    tileId: number
    enemyType: number
    enemyLevel: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type EncounterAvgAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
    enemyLevel?: true
  }

  export type EncounterSumAggregateInputType = {
    tileX?: true
    tileY?: true
    tileId?: true
    enemyLevel?: true
  }

  export type EncounterMinAggregateInputType = {
    id?: true
    tileX?: true
    tileY?: true
    tileId?: true
    enemyType?: true
    enemyLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    tileX?: true
    tileY?: true
    tileId?: true
    enemyType?: true
    enemyLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    tileX?: true
    tileY?: true
    tileId?: true
    enemyType?: true
    enemyLevel?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _avg?: EncounterAvgAggregateInputType
    _sum?: EncounterSumAggregateInputType
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    tileX: number
    tileY: number
    tileId: number | null
    enemyType: string
    enemyLevel: number
    isActive: boolean
    createdAt: Date
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    enemyType?: boolean
    enemyLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    enemyType?: boolean
    enemyLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    enemyType?: boolean
    enemyLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    tileX?: boolean
    tileY?: boolean
    tileId?: boolean
    enemyType?: boolean
    enemyLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type EncounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tileX" | "tileY" | "tileId" | "enemyType" | "enemyLevel" | "isActive" | "createdAt", ExtArgs["result"]["encounter"]>
  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }
  export type EncounterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tile?: boolean | Encounter$tileArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      tile: Prisma.$MapTilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tileX: number
      tileY: number
      tileId: number | null
      enemyType: string
      enemyLevel: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters and returns the data updated in the database.
     * @param {EncounterUpdateManyAndReturnArgs} args - Arguments to update many Encounters.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tile<T extends Encounter$tileArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$tileArgs<ExtArgs>>): Prisma__MapTileClient<$Result.GetResult<Prisma.$MapTilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly tileX: FieldRef<"Encounter", 'Int'>
    readonly tileY: FieldRef<"Encounter", 'Int'>
    readonly tileId: FieldRef<"Encounter", 'Int'>
    readonly enemyType: FieldRef<"Encounter", 'String'>
    readonly enemyLevel: FieldRef<"Encounter", 'Int'>
    readonly isActive: FieldRef<"Encounter", 'Boolean'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
  }

  /**
   * Encounter updateManyAndReturn
   */
  export type EncounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to delete.
     */
    limit?: number
  }

  /**
   * Encounter.tile
   */
  export type Encounter$tileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapTile
     */
    select?: MapTileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapTile
     */
    omit?: MapTileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapTileInclude<ExtArgs> | null
    where?: MapTileWhereInput
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model CombatLog
   */

  export type AggregateCombatLog = {
    _count: CombatLogCountAggregateOutputType | null
    _avg: CombatLogAvgAggregateOutputType | null
    _sum: CombatLogSumAggregateOutputType | null
    _min: CombatLogMinAggregateOutputType | null
    _max: CombatLogMaxAggregateOutputType | null
  }

  export type CombatLogAvgAggregateOutputType = {
    turnNumber: number | null
  }

  export type CombatLogSumAggregateOutputType = {
    turnNumber: number | null
  }

  export type CombatLogMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    encounterId: string | null
    turnNumber: number | null
    action: string | null
    result: string | null
    createdAt: Date | null
  }

  export type CombatLogMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    encounterId: string | null
    turnNumber: number | null
    action: string | null
    result: string | null
    createdAt: Date | null
  }

  export type CombatLogCountAggregateOutputType = {
    id: number
    playerId: number
    encounterId: number
    turnNumber: number
    action: number
    result: number
    createdAt: number
    _all: number
  }


  export type CombatLogAvgAggregateInputType = {
    turnNumber?: true
  }

  export type CombatLogSumAggregateInputType = {
    turnNumber?: true
  }

  export type CombatLogMinAggregateInputType = {
    id?: true
    playerId?: true
    encounterId?: true
    turnNumber?: true
    action?: true
    result?: true
    createdAt?: true
  }

  export type CombatLogMaxAggregateInputType = {
    id?: true
    playerId?: true
    encounterId?: true
    turnNumber?: true
    action?: true
    result?: true
    createdAt?: true
  }

  export type CombatLogCountAggregateInputType = {
    id?: true
    playerId?: true
    encounterId?: true
    turnNumber?: true
    action?: true
    result?: true
    createdAt?: true
    _all?: true
  }

  export type CombatLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatLog to aggregate.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombatLogs
    **/
    _count?: true | CombatLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombatLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombatLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombatLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombatLogMaxAggregateInputType
  }

  export type GetCombatLogAggregateType<T extends CombatLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCombatLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombatLog[P]>
      : GetScalarType<T[P], AggregateCombatLog[P]>
  }




  export type CombatLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatLogWhereInput
    orderBy?: CombatLogOrderByWithAggregationInput | CombatLogOrderByWithAggregationInput[]
    by: CombatLogScalarFieldEnum[] | CombatLogScalarFieldEnum
    having?: CombatLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombatLogCountAggregateInputType | true
    _avg?: CombatLogAvgAggregateInputType
    _sum?: CombatLogSumAggregateInputType
    _min?: CombatLogMinAggregateInputType
    _max?: CombatLogMaxAggregateInputType
  }

  export type CombatLogGroupByOutputType = {
    id: string
    playerId: string
    encounterId: string | null
    turnNumber: number
    action: string
    result: string
    createdAt: Date
    _count: CombatLogCountAggregateOutputType | null
    _avg: CombatLogAvgAggregateOutputType | null
    _sum: CombatLogSumAggregateOutputType | null
    _min: CombatLogMinAggregateOutputType | null
    _max: CombatLogMaxAggregateOutputType | null
  }

  type GetCombatLogGroupByPayload<T extends CombatLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombatLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombatLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombatLogGroupByOutputType[P]>
            : GetScalarType<T[P], CombatLogGroupByOutputType[P]>
        }
      >
    >


  export type CombatLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    encounterId?: boolean
    turnNumber?: boolean
    action?: boolean
    result?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    encounterId?: boolean
    turnNumber?: boolean
    action?: boolean
    result?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    encounterId?: boolean
    turnNumber?: boolean
    action?: boolean
    result?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectScalar = {
    id?: boolean
    playerId?: boolean
    encounterId?: boolean
    turnNumber?: boolean
    action?: boolean
    result?: boolean
    createdAt?: boolean
  }

  export type CombatLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "encounterId" | "turnNumber" | "action" | "result" | "createdAt", ExtArgs["result"]["combatLog"]>
  export type CombatLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type CombatLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type CombatLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $CombatLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombatLog"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      encounterId: string | null
      turnNumber: number
      action: string
      result: string
      createdAt: Date
    }, ExtArgs["result"]["combatLog"]>
    composites: {}
  }

  type CombatLogGetPayload<S extends boolean | null | undefined | CombatLogDefaultArgs> = $Result.GetResult<Prisma.$CombatLogPayload, S>

  type CombatLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CombatLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CombatLogCountAggregateInputType | true
    }

  export interface CombatLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombatLog'], meta: { name: 'CombatLog' } }
    /**
     * Find zero or one CombatLog that matches the filter.
     * @param {CombatLogFindUniqueArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombatLogFindUniqueArgs>(args: SelectSubset<T, CombatLogFindUniqueArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CombatLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CombatLogFindUniqueOrThrowArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombatLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CombatLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindFirstArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombatLogFindFirstArgs>(args?: SelectSubset<T, CombatLogFindFirstArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindFirstOrThrowArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombatLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CombatLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CombatLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombatLogs
     * const combatLogs = await prisma.combatLog.findMany()
     * 
     * // Get first 10 CombatLogs
     * const combatLogs = await prisma.combatLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombatLogFindManyArgs>(args?: SelectSubset<T, CombatLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CombatLog.
     * @param {CombatLogCreateArgs} args - Arguments to create a CombatLog.
     * @example
     * // Create one CombatLog
     * const CombatLog = await prisma.combatLog.create({
     *   data: {
     *     // ... data to create a CombatLog
     *   }
     * })
     * 
     */
    create<T extends CombatLogCreateArgs>(args: SelectSubset<T, CombatLogCreateArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CombatLogs.
     * @param {CombatLogCreateManyArgs} args - Arguments to create many CombatLogs.
     * @example
     * // Create many CombatLogs
     * const combatLog = await prisma.combatLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombatLogCreateManyArgs>(args?: SelectSubset<T, CombatLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CombatLogs and returns the data saved in the database.
     * @param {CombatLogCreateManyAndReturnArgs} args - Arguments to create many CombatLogs.
     * @example
     * // Create many CombatLogs
     * const combatLog = await prisma.combatLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CombatLogs and only return the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CombatLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CombatLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CombatLog.
     * @param {CombatLogDeleteArgs} args - Arguments to delete one CombatLog.
     * @example
     * // Delete one CombatLog
     * const CombatLog = await prisma.combatLog.delete({
     *   where: {
     *     // ... filter to delete one CombatLog
     *   }
     * })
     * 
     */
    delete<T extends CombatLogDeleteArgs>(args: SelectSubset<T, CombatLogDeleteArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CombatLog.
     * @param {CombatLogUpdateArgs} args - Arguments to update one CombatLog.
     * @example
     * // Update one CombatLog
     * const combatLog = await prisma.combatLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombatLogUpdateArgs>(args: SelectSubset<T, CombatLogUpdateArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CombatLogs.
     * @param {CombatLogDeleteManyArgs} args - Arguments to filter CombatLogs to delete.
     * @example
     * // Delete a few CombatLogs
     * const { count } = await prisma.combatLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombatLogDeleteManyArgs>(args?: SelectSubset<T, CombatLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombatLogs
     * const combatLog = await prisma.combatLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombatLogUpdateManyArgs>(args: SelectSubset<T, CombatLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatLogs and returns the data updated in the database.
     * @param {CombatLogUpdateManyAndReturnArgs} args - Arguments to update many CombatLogs.
     * @example
     * // Update many CombatLogs
     * const combatLog = await prisma.combatLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CombatLogs and only return the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CombatLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CombatLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CombatLog.
     * @param {CombatLogUpsertArgs} args - Arguments to update or create a CombatLog.
     * @example
     * // Update or create a CombatLog
     * const combatLog = await prisma.combatLog.upsert({
     *   create: {
     *     // ... data to create a CombatLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombatLog we want to update
     *   }
     * })
     */
    upsert<T extends CombatLogUpsertArgs>(args: SelectSubset<T, CombatLogUpsertArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CombatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogCountArgs} args - Arguments to filter CombatLogs to count.
     * @example
     * // Count the number of CombatLogs
     * const count = await prisma.combatLog.count({
     *   where: {
     *     // ... the filter for the CombatLogs we want to count
     *   }
     * })
    **/
    count<T extends CombatLogCountArgs>(
      args?: Subset<T, CombatLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombatLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombatLogAggregateArgs>(args: Subset<T, CombatLogAggregateArgs>): Prisma.PrismaPromise<GetCombatLogAggregateType<T>>

    /**
     * Group by CombatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombatLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombatLogGroupByArgs['orderBy'] }
        : { orderBy?: CombatLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombatLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombatLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombatLog model
   */
  readonly fields: CombatLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombatLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombatLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombatLog model
   */
  interface CombatLogFieldRefs {
    readonly id: FieldRef<"CombatLog", 'String'>
    readonly playerId: FieldRef<"CombatLog", 'String'>
    readonly encounterId: FieldRef<"CombatLog", 'String'>
    readonly turnNumber: FieldRef<"CombatLog", 'Int'>
    readonly action: FieldRef<"CombatLog", 'String'>
    readonly result: FieldRef<"CombatLog", 'String'>
    readonly createdAt: FieldRef<"CombatLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CombatLog findUnique
   */
  export type CombatLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog findUniqueOrThrow
   */
  export type CombatLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog findFirst
   */
  export type CombatLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatLogs.
     */
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog findFirstOrThrow
   */
  export type CombatLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatLogs.
     */
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog findMany
   */
  export type CombatLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLogs to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog create
   */
  export type CombatLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CombatLog.
     */
    data: XOR<CombatLogCreateInput, CombatLogUncheckedCreateInput>
  }

  /**
   * CombatLog createMany
   */
  export type CombatLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombatLogs.
     */
    data: CombatLogCreateManyInput | CombatLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombatLog createManyAndReturn
   */
  export type CombatLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * The data used to create many CombatLogs.
     */
    data: CombatLogCreateManyInput | CombatLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatLog update
   */
  export type CombatLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CombatLog.
     */
    data: XOR<CombatLogUpdateInput, CombatLogUncheckedUpdateInput>
    /**
     * Choose, which CombatLog to update.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog updateMany
   */
  export type CombatLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombatLogs.
     */
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyInput>
    /**
     * Filter which CombatLogs to update
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to update.
     */
    limit?: number
  }

  /**
   * CombatLog updateManyAndReturn
   */
  export type CombatLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * The data used to update CombatLogs.
     */
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyInput>
    /**
     * Filter which CombatLogs to update
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatLog upsert
   */
  export type CombatLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CombatLog to update in case it exists.
     */
    where: CombatLogWhereUniqueInput
    /**
     * In case the CombatLog found by the `where` argument doesn't exist, create a new CombatLog with this data.
     */
    create: XOR<CombatLogCreateInput, CombatLogUncheckedCreateInput>
    /**
     * In case the CombatLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombatLogUpdateInput, CombatLogUncheckedUpdateInput>
  }

  /**
   * CombatLog delete
   */
  export type CombatLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter which CombatLog to delete.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog deleteMany
   */
  export type CombatLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatLogs to delete
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to delete.
     */
    limit?: number
  }

  /**
   * CombatLog without action
   */
  export type CombatLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
  }


  /**
   * Model DeathLog
   */

  export type AggregateDeathLog = {
    _count: DeathLogCountAggregateOutputType | null
    _avg: DeathLogAvgAggregateOutputType | null
    _sum: DeathLogSumAggregateOutputType | null
    _min: DeathLogMinAggregateOutputType | null
    _max: DeathLogMaxAggregateOutputType | null
  }

  export type DeathLogAvgAggregateOutputType = {
    deathCount: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DeathLogSumAggregateOutputType = {
    deathCount: number | null
    locationX: number | null
    locationY: number | null
  }

  export type DeathLogMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    deathCount: number | null
    cause: string | null
    locationX: number | null
    locationY: number | null
    createdAt: Date | null
  }

  export type DeathLogMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    deathCount: number | null
    cause: string | null
    locationX: number | null
    locationY: number | null
    createdAt: Date | null
  }

  export type DeathLogCountAggregateOutputType = {
    id: number
    playerId: number
    deathCount: number
    cause: number
    locationX: number
    locationY: number
    createdAt: number
    _all: number
  }


  export type DeathLogAvgAggregateInputType = {
    deathCount?: true
    locationX?: true
    locationY?: true
  }

  export type DeathLogSumAggregateInputType = {
    deathCount?: true
    locationX?: true
    locationY?: true
  }

  export type DeathLogMinAggregateInputType = {
    id?: true
    playerId?: true
    deathCount?: true
    cause?: true
    locationX?: true
    locationY?: true
    createdAt?: true
  }

  export type DeathLogMaxAggregateInputType = {
    id?: true
    playerId?: true
    deathCount?: true
    cause?: true
    locationX?: true
    locationY?: true
    createdAt?: true
  }

  export type DeathLogCountAggregateInputType = {
    id?: true
    playerId?: true
    deathCount?: true
    cause?: true
    locationX?: true
    locationY?: true
    createdAt?: true
    _all?: true
  }

  export type DeathLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeathLog to aggregate.
     */
    where?: DeathLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeathLogs to fetch.
     */
    orderBy?: DeathLogOrderByWithRelationInput | DeathLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeathLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeathLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeathLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeathLogs
    **/
    _count?: true | DeathLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeathLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeathLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeathLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeathLogMaxAggregateInputType
  }

  export type GetDeathLogAggregateType<T extends DeathLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDeathLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeathLog[P]>
      : GetScalarType<T[P], AggregateDeathLog[P]>
  }




  export type DeathLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeathLogWhereInput
    orderBy?: DeathLogOrderByWithAggregationInput | DeathLogOrderByWithAggregationInput[]
    by: DeathLogScalarFieldEnum[] | DeathLogScalarFieldEnum
    having?: DeathLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeathLogCountAggregateInputType | true
    _avg?: DeathLogAvgAggregateInputType
    _sum?: DeathLogSumAggregateInputType
    _min?: DeathLogMinAggregateInputType
    _max?: DeathLogMaxAggregateInputType
  }

  export type DeathLogGroupByOutputType = {
    id: string
    playerId: string
    deathCount: number
    cause: string | null
    locationX: number | null
    locationY: number | null
    createdAt: Date
    _count: DeathLogCountAggregateOutputType | null
    _avg: DeathLogAvgAggregateOutputType | null
    _sum: DeathLogSumAggregateOutputType | null
    _min: DeathLogMinAggregateOutputType | null
    _max: DeathLogMaxAggregateOutputType | null
  }

  type GetDeathLogGroupByPayload<T extends DeathLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeathLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeathLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeathLogGroupByOutputType[P]>
            : GetScalarType<T[P], DeathLogGroupByOutputType[P]>
        }
      >
    >


  export type DeathLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    deathCount?: boolean
    cause?: boolean
    locationX?: boolean
    locationY?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deathLog"]>

  export type DeathLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    deathCount?: boolean
    cause?: boolean
    locationX?: boolean
    locationY?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deathLog"]>

  export type DeathLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    deathCount?: boolean
    cause?: boolean
    locationX?: boolean
    locationY?: boolean
    createdAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deathLog"]>

  export type DeathLogSelectScalar = {
    id?: boolean
    playerId?: boolean
    deathCount?: boolean
    cause?: boolean
    locationX?: boolean
    locationY?: boolean
    createdAt?: boolean
  }

  export type DeathLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "deathCount" | "cause" | "locationX" | "locationY" | "createdAt", ExtArgs["result"]["deathLog"]>
  export type DeathLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type DeathLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type DeathLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $DeathLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeathLog"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      deathCount: number
      cause: string | null
      locationX: number | null
      locationY: number | null
      createdAt: Date
    }, ExtArgs["result"]["deathLog"]>
    composites: {}
  }

  type DeathLogGetPayload<S extends boolean | null | undefined | DeathLogDefaultArgs> = $Result.GetResult<Prisma.$DeathLogPayload, S>

  type DeathLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeathLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeathLogCountAggregateInputType | true
    }

  export interface DeathLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeathLog'], meta: { name: 'DeathLog' } }
    /**
     * Find zero or one DeathLog that matches the filter.
     * @param {DeathLogFindUniqueArgs} args - Arguments to find a DeathLog
     * @example
     * // Get one DeathLog
     * const deathLog = await prisma.deathLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeathLogFindUniqueArgs>(args: SelectSubset<T, DeathLogFindUniqueArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeathLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeathLogFindUniqueOrThrowArgs} args - Arguments to find a DeathLog
     * @example
     * // Get one DeathLog
     * const deathLog = await prisma.deathLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeathLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DeathLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeathLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogFindFirstArgs} args - Arguments to find a DeathLog
     * @example
     * // Get one DeathLog
     * const deathLog = await prisma.deathLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeathLogFindFirstArgs>(args?: SelectSubset<T, DeathLogFindFirstArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeathLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogFindFirstOrThrowArgs} args - Arguments to find a DeathLog
     * @example
     * // Get one DeathLog
     * const deathLog = await prisma.deathLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeathLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DeathLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeathLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeathLogs
     * const deathLogs = await prisma.deathLog.findMany()
     * 
     * // Get first 10 DeathLogs
     * const deathLogs = await prisma.deathLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deathLogWithIdOnly = await prisma.deathLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeathLogFindManyArgs>(args?: SelectSubset<T, DeathLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeathLog.
     * @param {DeathLogCreateArgs} args - Arguments to create a DeathLog.
     * @example
     * // Create one DeathLog
     * const DeathLog = await prisma.deathLog.create({
     *   data: {
     *     // ... data to create a DeathLog
     *   }
     * })
     * 
     */
    create<T extends DeathLogCreateArgs>(args: SelectSubset<T, DeathLogCreateArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeathLogs.
     * @param {DeathLogCreateManyArgs} args - Arguments to create many DeathLogs.
     * @example
     * // Create many DeathLogs
     * const deathLog = await prisma.deathLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeathLogCreateManyArgs>(args?: SelectSubset<T, DeathLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeathLogs and returns the data saved in the database.
     * @param {DeathLogCreateManyAndReturnArgs} args - Arguments to create many DeathLogs.
     * @example
     * // Create many DeathLogs
     * const deathLog = await prisma.deathLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeathLogs and only return the `id`
     * const deathLogWithIdOnly = await prisma.deathLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeathLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DeathLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeathLog.
     * @param {DeathLogDeleteArgs} args - Arguments to delete one DeathLog.
     * @example
     * // Delete one DeathLog
     * const DeathLog = await prisma.deathLog.delete({
     *   where: {
     *     // ... filter to delete one DeathLog
     *   }
     * })
     * 
     */
    delete<T extends DeathLogDeleteArgs>(args: SelectSubset<T, DeathLogDeleteArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeathLog.
     * @param {DeathLogUpdateArgs} args - Arguments to update one DeathLog.
     * @example
     * // Update one DeathLog
     * const deathLog = await prisma.deathLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeathLogUpdateArgs>(args: SelectSubset<T, DeathLogUpdateArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeathLogs.
     * @param {DeathLogDeleteManyArgs} args - Arguments to filter DeathLogs to delete.
     * @example
     * // Delete a few DeathLogs
     * const { count } = await prisma.deathLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeathLogDeleteManyArgs>(args?: SelectSubset<T, DeathLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeathLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeathLogs
     * const deathLog = await prisma.deathLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeathLogUpdateManyArgs>(args: SelectSubset<T, DeathLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeathLogs and returns the data updated in the database.
     * @param {DeathLogUpdateManyAndReturnArgs} args - Arguments to update many DeathLogs.
     * @example
     * // Update many DeathLogs
     * const deathLog = await prisma.deathLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeathLogs and only return the `id`
     * const deathLogWithIdOnly = await prisma.deathLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeathLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DeathLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeathLog.
     * @param {DeathLogUpsertArgs} args - Arguments to update or create a DeathLog.
     * @example
     * // Update or create a DeathLog
     * const deathLog = await prisma.deathLog.upsert({
     *   create: {
     *     // ... data to create a DeathLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeathLog we want to update
     *   }
     * })
     */
    upsert<T extends DeathLogUpsertArgs>(args: SelectSubset<T, DeathLogUpsertArgs<ExtArgs>>): Prisma__DeathLogClient<$Result.GetResult<Prisma.$DeathLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeathLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogCountArgs} args - Arguments to filter DeathLogs to count.
     * @example
     * // Count the number of DeathLogs
     * const count = await prisma.deathLog.count({
     *   where: {
     *     // ... the filter for the DeathLogs we want to count
     *   }
     * })
    **/
    count<T extends DeathLogCountArgs>(
      args?: Subset<T, DeathLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeathLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeathLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeathLogAggregateArgs>(args: Subset<T, DeathLogAggregateArgs>): Prisma.PrismaPromise<GetDeathLogAggregateType<T>>

    /**
     * Group by DeathLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeathLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeathLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeathLogGroupByArgs['orderBy'] }
        : { orderBy?: DeathLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeathLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeathLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeathLog model
   */
  readonly fields: DeathLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeathLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeathLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeathLog model
   */
  interface DeathLogFieldRefs {
    readonly id: FieldRef<"DeathLog", 'String'>
    readonly playerId: FieldRef<"DeathLog", 'String'>
    readonly deathCount: FieldRef<"DeathLog", 'Int'>
    readonly cause: FieldRef<"DeathLog", 'String'>
    readonly locationX: FieldRef<"DeathLog", 'Int'>
    readonly locationY: FieldRef<"DeathLog", 'Int'>
    readonly createdAt: FieldRef<"DeathLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeathLog findUnique
   */
  export type DeathLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter, which DeathLog to fetch.
     */
    where: DeathLogWhereUniqueInput
  }

  /**
   * DeathLog findUniqueOrThrow
   */
  export type DeathLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter, which DeathLog to fetch.
     */
    where: DeathLogWhereUniqueInput
  }

  /**
   * DeathLog findFirst
   */
  export type DeathLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter, which DeathLog to fetch.
     */
    where?: DeathLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeathLogs to fetch.
     */
    orderBy?: DeathLogOrderByWithRelationInput | DeathLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeathLogs.
     */
    cursor?: DeathLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeathLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeathLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeathLogs.
     */
    distinct?: DeathLogScalarFieldEnum | DeathLogScalarFieldEnum[]
  }

  /**
   * DeathLog findFirstOrThrow
   */
  export type DeathLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter, which DeathLog to fetch.
     */
    where?: DeathLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeathLogs to fetch.
     */
    orderBy?: DeathLogOrderByWithRelationInput | DeathLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeathLogs.
     */
    cursor?: DeathLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeathLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeathLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeathLogs.
     */
    distinct?: DeathLogScalarFieldEnum | DeathLogScalarFieldEnum[]
  }

  /**
   * DeathLog findMany
   */
  export type DeathLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter, which DeathLogs to fetch.
     */
    where?: DeathLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeathLogs to fetch.
     */
    orderBy?: DeathLogOrderByWithRelationInput | DeathLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeathLogs.
     */
    cursor?: DeathLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeathLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeathLogs.
     */
    skip?: number
    distinct?: DeathLogScalarFieldEnum | DeathLogScalarFieldEnum[]
  }

  /**
   * DeathLog create
   */
  export type DeathLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DeathLog.
     */
    data: XOR<DeathLogCreateInput, DeathLogUncheckedCreateInput>
  }

  /**
   * DeathLog createMany
   */
  export type DeathLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeathLogs.
     */
    data: DeathLogCreateManyInput | DeathLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeathLog createManyAndReturn
   */
  export type DeathLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * The data used to create many DeathLogs.
     */
    data: DeathLogCreateManyInput | DeathLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeathLog update
   */
  export type DeathLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DeathLog.
     */
    data: XOR<DeathLogUpdateInput, DeathLogUncheckedUpdateInput>
    /**
     * Choose, which DeathLog to update.
     */
    where: DeathLogWhereUniqueInput
  }

  /**
   * DeathLog updateMany
   */
  export type DeathLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeathLogs.
     */
    data: XOR<DeathLogUpdateManyMutationInput, DeathLogUncheckedUpdateManyInput>
    /**
     * Filter which DeathLogs to update
     */
    where?: DeathLogWhereInput
    /**
     * Limit how many DeathLogs to update.
     */
    limit?: number
  }

  /**
   * DeathLog updateManyAndReturn
   */
  export type DeathLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * The data used to update DeathLogs.
     */
    data: XOR<DeathLogUpdateManyMutationInput, DeathLogUncheckedUpdateManyInput>
    /**
     * Filter which DeathLogs to update
     */
    where?: DeathLogWhereInput
    /**
     * Limit how many DeathLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeathLog upsert
   */
  export type DeathLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DeathLog to update in case it exists.
     */
    where: DeathLogWhereUniqueInput
    /**
     * In case the DeathLog found by the `where` argument doesn't exist, create a new DeathLog with this data.
     */
    create: XOR<DeathLogCreateInput, DeathLogUncheckedCreateInput>
    /**
     * In case the DeathLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeathLogUpdateInput, DeathLogUncheckedUpdateInput>
  }

  /**
   * DeathLog delete
   */
  export type DeathLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
    /**
     * Filter which DeathLog to delete.
     */
    where: DeathLogWhereUniqueInput
  }

  /**
   * DeathLog deleteMany
   */
  export type DeathLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeathLogs to delete
     */
    where?: DeathLogWhereInput
    /**
     * Limit how many DeathLogs to delete.
     */
    limit?: number
  }

  /**
   * DeathLog without action
   */
  export type DeathLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeathLog
     */
    select?: DeathLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeathLog
     */
    omit?: DeathLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeathLogInclude<ExtArgs> | null
  }


  /**
   * Model Guild
   */

  export type AggregateGuild = {
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  export type GuildAvgAggregateOutputType = {
    level: number | null
    gold: number | null
  }

  export type GuildSumAggregateOutputType = {
    level: number | null
    gold: number | null
  }

  export type GuildMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    level: number | null
    gold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuildMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    level: number | null
    gold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuildCountAggregateOutputType = {
    id: number
    name: number
    description: number
    level: number
    gold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuildAvgAggregateInputType = {
    level?: true
    gold?: true
  }

  export type GuildSumAggregateInputType = {
    level?: true
    gold?: true
  }

  export type GuildMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    gold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuildMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    gold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuildCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    gold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guild to aggregate.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guilds
    **/
    _count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }




  export type GuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildWhereInput
    orderBy?: GuildOrderByWithAggregationInput | GuildOrderByWithAggregationInput[]
    by: GuildScalarFieldEnum[] | GuildScalarFieldEnum
    having?: GuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildCountAggregateInputType | true
    _avg?: GuildAvgAggregateInputType
    _sum?: GuildSumAggregateInputType
    _min?: GuildMinAggregateInputType
    _max?: GuildMaxAggregateInputType
  }

  export type GuildGroupByOutputType = {
    id: string
    name: string
    description: string | null
    level: number
    gold: number
    createdAt: Date
    updatedAt: Date
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  type GetGuildGroupByPayload<T extends GuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildGroupByOutputType[P]>
            : GetScalarType<T[P], GuildGroupByOutputType[P]>
        }
      >
    >


  export type GuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    gold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Guild$membersArgs<ExtArgs>
    bank?: boolean | Guild$bankArgs<ExtArgs>
    quests?: boolean | Guild$questsArgs<ExtArgs>
    _count?: boolean | GuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guild"]>

  export type GuildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    gold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guild"]>

  export type GuildSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    gold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guild"]>

  export type GuildSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    gold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "level" | "gold" | "createdAt" | "updatedAt", ExtArgs["result"]["guild"]>
  export type GuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Guild$membersArgs<ExtArgs>
    bank?: boolean | Guild$bankArgs<ExtArgs>
    quests?: boolean | Guild$questsArgs<ExtArgs>
    _count?: boolean | GuildCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GuildIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guild"
    objects: {
      members: Prisma.$GuildMemberPayload<ExtArgs>[]
      bank: Prisma.$GuildBankPayload<ExtArgs> | null
      quests: Prisma.$GuildQuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      level: number
      gold: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guild"]>
    composites: {}
  }

  type GuildGetPayload<S extends boolean | null | undefined | GuildDefaultArgs> = $Result.GetResult<Prisma.$GuildPayload, S>

  type GuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildCountAggregateInputType | true
    }

  export interface GuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guild'], meta: { name: 'Guild' } }
    /**
     * Find zero or one Guild that matches the filter.
     * @param {GuildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildFindUniqueArgs>(args: SelectSubset<T, GuildFindUniqueArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guild that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildFindUniqueOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildFindFirstArgs>(args?: SelectSubset<T, GuildFindFirstArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWithIdOnly = await prisma.guild.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildFindManyArgs>(args?: SelectSubset<T, GuildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guild.
     * @param {GuildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
     */
    create<T extends GuildCreateArgs>(args: SelectSubset<T, GuildCreateArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guilds.
     * @param {GuildCreateManyArgs} args - Arguments to create many Guilds.
     * @example
     * // Create many Guilds
     * const guild = await prisma.guild.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildCreateManyArgs>(args?: SelectSubset<T, GuildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guilds and returns the data saved in the database.
     * @param {GuildCreateManyAndReturnArgs} args - Arguments to create many Guilds.
     * @example
     * // Create many Guilds
     * const guild = await prisma.guild.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guilds and only return the `id`
     * const guildWithIdOnly = await prisma.guild.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guild.
     * @param {GuildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
     */
    delete<T extends GuildDeleteArgs>(args: SelectSubset<T, GuildDeleteArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guild.
     * @param {GuildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildUpdateArgs>(args: SelectSubset<T, GuildUpdateArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guilds.
     * @param {GuildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildDeleteManyArgs>(args?: SelectSubset<T, GuildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildUpdateManyArgs>(args: SelectSubset<T, GuildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds and returns the data updated in the database.
     * @param {GuildUpdateManyAndReturnArgs} args - Arguments to update many Guilds.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guilds and only return the `id`
     * const guildWithIdOnly = await prisma.guild.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuildUpdateManyAndReturnArgs>(args: SelectSubset<T, GuildUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guild.
     * @param {GuildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
     */
    upsert<T extends GuildUpsertArgs>(args: SelectSubset<T, GuildUpsertArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends GuildCountArgs>(
      args?: Subset<T, GuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): Prisma.PrismaPromise<GetGuildAggregateType<T>>

    /**
     * Group by Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildGroupByArgs['orderBy'] }
        : { orderBy?: GuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guild model
   */
  readonly fields: GuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Guild$membersArgs<ExtArgs> = {}>(args?: Subset<T, Guild$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bank<T extends Guild$bankArgs<ExtArgs> = {}>(args?: Subset<T, Guild$bankArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quests<T extends Guild$questsArgs<ExtArgs> = {}>(args?: Subset<T, Guild$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guild model
   */
  interface GuildFieldRefs {
    readonly id: FieldRef<"Guild", 'String'>
    readonly name: FieldRef<"Guild", 'String'>
    readonly description: FieldRef<"Guild", 'String'>
    readonly level: FieldRef<"Guild", 'Int'>
    readonly gold: FieldRef<"Guild", 'Int'>
    readonly createdAt: FieldRef<"Guild", 'DateTime'>
    readonly updatedAt: FieldRef<"Guild", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guild findUnique
   */
  export type GuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }

  /**
   * Guild findUniqueOrThrow
   */
  export type GuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }

  /**
   * Guild findFirst
   */
  export type GuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * Guild findFirstOrThrow
   */
  export type GuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * Guild findMany
   */
  export type GuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }

  /**
   * Guild create
   */
  export type GuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * The data needed to create a Guild.
     */
    data: XOR<GuildCreateInput, GuildUncheckedCreateInput>
  }

  /**
   * Guild createMany
   */
  export type GuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guilds.
     */
    data: GuildCreateManyInput | GuildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guild createManyAndReturn
   */
  export type GuildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * The data used to create many Guilds.
     */
    data: GuildCreateManyInput | GuildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guild update
   */
  export type GuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * The data needed to update a Guild.
     */
    data: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
    /**
     * Choose, which Guild to update.
     */
    where: GuildWhereUniqueInput
  }

  /**
   * Guild updateMany
   */
  export type GuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guilds.
     */
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     */
    where?: GuildWhereInput
    /**
     * Limit how many Guilds to update.
     */
    limit?: number
  }

  /**
   * Guild updateManyAndReturn
   */
  export type GuildUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * The data used to update Guilds.
     */
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     */
    where?: GuildWhereInput
    /**
     * Limit how many Guilds to update.
     */
    limit?: number
  }

  /**
   * Guild upsert
   */
  export type GuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * The filter to search for the Guild to update in case it exists.
     */
    where: GuildWhereUniqueInput
    /**
     * In case the Guild found by the `where` argument doesn't exist, create a new Guild with this data.
     */
    create: XOR<GuildCreateInput, GuildUncheckedCreateInput>
    /**
     * In case the Guild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
  }

  /**
   * Guild delete
   */
  export type GuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
    /**
     * Filter which Guild to delete.
     */
    where: GuildWhereUniqueInput
  }

  /**
   * Guild deleteMany
   */
  export type GuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilds to delete
     */
    where?: GuildWhereInput
    /**
     * Limit how many Guilds to delete.
     */
    limit?: number
  }

  /**
   * Guild.members
   */
  export type Guild$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    where?: GuildMemberWhereInput
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    cursor?: GuildMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }

  /**
   * Guild.bank
   */
  export type Guild$bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    where?: GuildBankWhereInput
  }

  /**
   * Guild.quests
   */
  export type Guild$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    where?: GuildQuestWhereInput
    orderBy?: GuildQuestOrderByWithRelationInput | GuildQuestOrderByWithRelationInput[]
    cursor?: GuildQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildQuestScalarFieldEnum | GuildQuestScalarFieldEnum[]
  }

  /**
   * Guild without action
   */
  export type GuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guild
     */
    omit?: GuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildInclude<ExtArgs> | null
  }


  /**
   * Model GuildMember
   */

  export type AggregateGuildMember = {
    _count: GuildMemberCountAggregateOutputType | null
    _min: GuildMemberMinAggregateOutputType | null
    _max: GuildMemberMaxAggregateOutputType | null
  }

  export type GuildMemberMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    guildId: string | null
    role: $Enums.GuildRole | null
    joinedAt: Date | null
  }

  export type GuildMemberMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    guildId: string | null
    role: $Enums.GuildRole | null
    joinedAt: Date | null
  }

  export type GuildMemberCountAggregateOutputType = {
    id: number
    playerId: number
    guildId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type GuildMemberMinAggregateInputType = {
    id?: true
    playerId?: true
    guildId?: true
    role?: true
    joinedAt?: true
  }

  export type GuildMemberMaxAggregateInputType = {
    id?: true
    playerId?: true
    guildId?: true
    role?: true
    joinedAt?: true
  }

  export type GuildMemberCountAggregateInputType = {
    id?: true
    playerId?: true
    guildId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type GuildMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMember to aggregate.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildMembers
    **/
    _count?: true | GuildMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMemberMaxAggregateInputType
  }

  export type GetGuildMemberAggregateType<T extends GuildMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildMember[P]>
      : GetScalarType<T[P], AggregateGuildMember[P]>
  }




  export type GuildMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildMemberWhereInput
    orderBy?: GuildMemberOrderByWithAggregationInput | GuildMemberOrderByWithAggregationInput[]
    by: GuildMemberScalarFieldEnum[] | GuildMemberScalarFieldEnum
    having?: GuildMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildMemberCountAggregateInputType | true
    _min?: GuildMemberMinAggregateInputType
    _max?: GuildMemberMaxAggregateInputType
  }

  export type GuildMemberGroupByOutputType = {
    id: string
    playerId: string
    guildId: string
    role: $Enums.GuildRole
    joinedAt: Date
    _count: GuildMemberCountAggregateOutputType | null
    _min: GuildMemberMinAggregateOutputType | null
    _max: GuildMemberMaxAggregateOutputType | null
  }

  type GetGuildMemberGroupByPayload<T extends GuildMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GuildMemberGroupByOutputType[P]>
        }
      >
    >


  export type GuildMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    guildId?: boolean
    role?: boolean
    joinedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildMember"]>

  export type GuildMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    guildId?: boolean
    role?: boolean
    joinedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildMember"]>

  export type GuildMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    guildId?: boolean
    role?: boolean
    joinedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildMember"]>

  export type GuildMemberSelectScalar = {
    id?: boolean
    playerId?: boolean
    guildId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type GuildMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "guildId" | "role" | "joinedAt", ExtArgs["result"]["guildMember"]>
  export type GuildMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }

  export type $GuildMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildMember"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      guild: Prisma.$GuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      guildId: string
      role: $Enums.GuildRole
      joinedAt: Date
    }, ExtArgs["result"]["guildMember"]>
    composites: {}
  }

  type GuildMemberGetPayload<S extends boolean | null | undefined | GuildMemberDefaultArgs> = $Result.GetResult<Prisma.$GuildMemberPayload, S>

  type GuildMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildMemberCountAggregateInputType | true
    }

  export interface GuildMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildMember'], meta: { name: 'GuildMember' } }
    /**
     * Find zero or one GuildMember that matches the filter.
     * @param {GuildMemberFindUniqueArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildMemberFindUniqueArgs>(args: SelectSubset<T, GuildMemberFindUniqueArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildMemberFindUniqueOrThrowArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindFirstArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildMemberFindFirstArgs>(args?: SelectSubset<T, GuildMemberFindFirstArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindFirstOrThrowArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildMembers
     * const guildMembers = await prisma.guildMember.findMany()
     * 
     * // Get first 10 GuildMembers
     * const guildMembers = await prisma.guildMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildMemberWithIdOnly = await prisma.guildMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildMemberFindManyArgs>(args?: SelectSubset<T, GuildMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildMember.
     * @param {GuildMemberCreateArgs} args - Arguments to create a GuildMember.
     * @example
     * // Create one GuildMember
     * const GuildMember = await prisma.guildMember.create({
     *   data: {
     *     // ... data to create a GuildMember
     *   }
     * })
     * 
     */
    create<T extends GuildMemberCreateArgs>(args: SelectSubset<T, GuildMemberCreateArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildMembers.
     * @param {GuildMemberCreateManyArgs} args - Arguments to create many GuildMembers.
     * @example
     * // Create many GuildMembers
     * const guildMember = await prisma.guildMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildMemberCreateManyArgs>(args?: SelectSubset<T, GuildMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildMembers and returns the data saved in the database.
     * @param {GuildMemberCreateManyAndReturnArgs} args - Arguments to create many GuildMembers.
     * @example
     * // Create many GuildMembers
     * const guildMember = await prisma.guildMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildMembers and only return the `id`
     * const guildMemberWithIdOnly = await prisma.guildMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuildMember.
     * @param {GuildMemberDeleteArgs} args - Arguments to delete one GuildMember.
     * @example
     * // Delete one GuildMember
     * const GuildMember = await prisma.guildMember.delete({
     *   where: {
     *     // ... filter to delete one GuildMember
     *   }
     * })
     * 
     */
    delete<T extends GuildMemberDeleteArgs>(args: SelectSubset<T, GuildMemberDeleteArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildMember.
     * @param {GuildMemberUpdateArgs} args - Arguments to update one GuildMember.
     * @example
     * // Update one GuildMember
     * const guildMember = await prisma.guildMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildMemberUpdateArgs>(args: SelectSubset<T, GuildMemberUpdateArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildMembers.
     * @param {GuildMemberDeleteManyArgs} args - Arguments to filter GuildMembers to delete.
     * @example
     * // Delete a few GuildMembers
     * const { count } = await prisma.guildMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildMemberDeleteManyArgs>(args?: SelectSubset<T, GuildMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildMembers
     * const guildMember = await prisma.guildMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildMemberUpdateManyArgs>(args: SelectSubset<T, GuildMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildMembers and returns the data updated in the database.
     * @param {GuildMemberUpdateManyAndReturnArgs} args - Arguments to update many GuildMembers.
     * @example
     * // Update many GuildMembers
     * const guildMember = await prisma.guildMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuildMembers and only return the `id`
     * const guildMemberWithIdOnly = await prisma.guildMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuildMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GuildMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuildMember.
     * @param {GuildMemberUpsertArgs} args - Arguments to update or create a GuildMember.
     * @example
     * // Update or create a GuildMember
     * const guildMember = await prisma.guildMember.upsert({
     *   create: {
     *     // ... data to create a GuildMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildMember we want to update
     *   }
     * })
     */
    upsert<T extends GuildMemberUpsertArgs>(args: SelectSubset<T, GuildMemberUpsertArgs<ExtArgs>>): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuildMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberCountArgs} args - Arguments to filter GuildMembers to count.
     * @example
     * // Count the number of GuildMembers
     * const count = await prisma.guildMember.count({
     *   where: {
     *     // ... the filter for the GuildMembers we want to count
     *   }
     * })
    **/
    count<T extends GuildMemberCountArgs>(
      args?: Subset<T, GuildMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildMemberAggregateArgs>(args: Subset<T, GuildMemberAggregateArgs>): Prisma.PrismaPromise<GetGuildMemberAggregateType<T>>

    /**
     * Group by GuildMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildMemberGroupByArgs['orderBy'] }
        : { orderBy?: GuildMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildMember model
   */
  readonly fields: GuildMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guild<T extends GuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildDefaultArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildMember model
   */
  interface GuildMemberFieldRefs {
    readonly id: FieldRef<"GuildMember", 'String'>
    readonly playerId: FieldRef<"GuildMember", 'String'>
    readonly guildId: FieldRef<"GuildMember", 'String'>
    readonly role: FieldRef<"GuildMember", 'GuildRole'>
    readonly joinedAt: FieldRef<"GuildMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuildMember findUnique
   */
  export type GuildMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where: GuildMemberWhereUniqueInput
  }

  /**
   * GuildMember findUniqueOrThrow
   */
  export type GuildMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where: GuildMemberWhereUniqueInput
  }

  /**
   * GuildMember findFirst
   */
  export type GuildMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMembers.
     */
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }

  /**
   * GuildMember findFirstOrThrow
   */
  export type GuildMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMembers.
     */
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }

  /**
   * GuildMember findMany
   */
  export type GuildMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter, which GuildMembers to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }

  /**
   * GuildMember create
   */
  export type GuildMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildMember.
     */
    data: XOR<GuildMemberCreateInput, GuildMemberUncheckedCreateInput>
  }

  /**
   * GuildMember createMany
   */
  export type GuildMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildMembers.
     */
    data: GuildMemberCreateManyInput | GuildMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildMember createManyAndReturn
   */
  export type GuildMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GuildMembers.
     */
    data: GuildMemberCreateManyInput | GuildMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildMember update
   */
  export type GuildMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildMember.
     */
    data: XOR<GuildMemberUpdateInput, GuildMemberUncheckedUpdateInput>
    /**
     * Choose, which GuildMember to update.
     */
    where: GuildMemberWhereUniqueInput
  }

  /**
   * GuildMember updateMany
   */
  export type GuildMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildMembers.
     */
    data: XOR<GuildMemberUpdateManyMutationInput, GuildMemberUncheckedUpdateManyInput>
    /**
     * Filter which GuildMembers to update
     */
    where?: GuildMemberWhereInput
    /**
     * Limit how many GuildMembers to update.
     */
    limit?: number
  }

  /**
   * GuildMember updateManyAndReturn
   */
  export type GuildMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * The data used to update GuildMembers.
     */
    data: XOR<GuildMemberUpdateManyMutationInput, GuildMemberUncheckedUpdateManyInput>
    /**
     * Filter which GuildMembers to update
     */
    where?: GuildMemberWhereInput
    /**
     * Limit how many GuildMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildMember upsert
   */
  export type GuildMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildMember to update in case it exists.
     */
    where: GuildMemberWhereUniqueInput
    /**
     * In case the GuildMember found by the `where` argument doesn't exist, create a new GuildMember with this data.
     */
    create: XOR<GuildMemberCreateInput, GuildMemberUncheckedCreateInput>
    /**
     * In case the GuildMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildMemberUpdateInput, GuildMemberUncheckedUpdateInput>
  }

  /**
   * GuildMember delete
   */
  export type GuildMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
    /**
     * Filter which GuildMember to delete.
     */
    where: GuildMemberWhereUniqueInput
  }

  /**
   * GuildMember deleteMany
   */
  export type GuildMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMembers to delete
     */
    where?: GuildMemberWhereInput
    /**
     * Limit how many GuildMembers to delete.
     */
    limit?: number
  }

  /**
   * GuildMember without action
   */
  export type GuildMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildMember
     */
    omit?: GuildMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildMemberInclude<ExtArgs> | null
  }


  /**
   * Model GuildBank
   */

  export type AggregateGuildBank = {
    _count: GuildBankCountAggregateOutputType | null
    _avg: GuildBankAvgAggregateOutputType | null
    _sum: GuildBankSumAggregateOutputType | null
    _min: GuildBankMinAggregateOutputType | null
    _max: GuildBankMaxAggregateOutputType | null
  }

  export type GuildBankAvgAggregateOutputType = {
    gold: number | null
  }

  export type GuildBankSumAggregateOutputType = {
    gold: number | null
  }

  export type GuildBankMinAggregateOutputType = {
    id: string | null
    guildId: string | null
    gold: number | null
    updatedAt: Date | null
  }

  export type GuildBankMaxAggregateOutputType = {
    id: string | null
    guildId: string | null
    gold: number | null
    updatedAt: Date | null
  }

  export type GuildBankCountAggregateOutputType = {
    id: number
    guildId: number
    gold: number
    updatedAt: number
    _all: number
  }


  export type GuildBankAvgAggregateInputType = {
    gold?: true
  }

  export type GuildBankSumAggregateInputType = {
    gold?: true
  }

  export type GuildBankMinAggregateInputType = {
    id?: true
    guildId?: true
    gold?: true
    updatedAt?: true
  }

  export type GuildBankMaxAggregateInputType = {
    id?: true
    guildId?: true
    gold?: true
    updatedAt?: true
  }

  export type GuildBankCountAggregateInputType = {
    id?: true
    guildId?: true
    gold?: true
    updatedAt?: true
    _all?: true
  }

  export type GuildBankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBank to aggregate.
     */
    where?: GuildBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBanks to fetch.
     */
    orderBy?: GuildBankOrderByWithRelationInput | GuildBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildBanks
    **/
    _count?: true | GuildBankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildBankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildBankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildBankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildBankMaxAggregateInputType
  }

  export type GetGuildBankAggregateType<T extends GuildBankAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildBank[P]>
      : GetScalarType<T[P], AggregateGuildBank[P]>
  }




  export type GuildBankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildBankWhereInput
    orderBy?: GuildBankOrderByWithAggregationInput | GuildBankOrderByWithAggregationInput[]
    by: GuildBankScalarFieldEnum[] | GuildBankScalarFieldEnum
    having?: GuildBankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildBankCountAggregateInputType | true
    _avg?: GuildBankAvgAggregateInputType
    _sum?: GuildBankSumAggregateInputType
    _min?: GuildBankMinAggregateInputType
    _max?: GuildBankMaxAggregateInputType
  }

  export type GuildBankGroupByOutputType = {
    id: string
    guildId: string
    gold: number
    updatedAt: Date
    _count: GuildBankCountAggregateOutputType | null
    _avg: GuildBankAvgAggregateOutputType | null
    _sum: GuildBankSumAggregateOutputType | null
    _min: GuildBankMinAggregateOutputType | null
    _max: GuildBankMaxAggregateOutputType | null
  }

  type GetGuildBankGroupByPayload<T extends GuildBankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildBankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildBankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildBankGroupByOutputType[P]>
            : GetScalarType<T[P], GuildBankGroupByOutputType[P]>
        }
      >
    >


  export type GuildBankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    gold?: boolean
    updatedAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildBank"]>

  export type GuildBankSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    gold?: boolean
    updatedAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildBank"]>

  export type GuildBankSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    gold?: boolean
    updatedAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildBank"]>

  export type GuildBankSelectScalar = {
    id?: boolean
    guildId?: boolean
    gold?: boolean
    updatedAt?: boolean
  }

  export type GuildBankOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guildId" | "gold" | "updatedAt", ExtArgs["result"]["guildBank"]>
  export type GuildBankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildBankIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildBankIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }

  export type $GuildBankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildBank"
    objects: {
      guild: Prisma.$GuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guildId: string
      gold: number
      updatedAt: Date
    }, ExtArgs["result"]["guildBank"]>
    composites: {}
  }

  type GuildBankGetPayload<S extends boolean | null | undefined | GuildBankDefaultArgs> = $Result.GetResult<Prisma.$GuildBankPayload, S>

  type GuildBankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildBankFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildBankCountAggregateInputType | true
    }

  export interface GuildBankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildBank'], meta: { name: 'GuildBank' } }
    /**
     * Find zero or one GuildBank that matches the filter.
     * @param {GuildBankFindUniqueArgs} args - Arguments to find a GuildBank
     * @example
     * // Get one GuildBank
     * const guildBank = await prisma.guildBank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildBankFindUniqueArgs>(args: SelectSubset<T, GuildBankFindUniqueArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildBank that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildBankFindUniqueOrThrowArgs} args - Arguments to find a GuildBank
     * @example
     * // Get one GuildBank
     * const guildBank = await prisma.guildBank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildBankFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildBankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankFindFirstArgs} args - Arguments to find a GuildBank
     * @example
     * // Get one GuildBank
     * const guildBank = await prisma.guildBank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildBankFindFirstArgs>(args?: SelectSubset<T, GuildBankFindFirstArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildBank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankFindFirstOrThrowArgs} args - Arguments to find a GuildBank
     * @example
     * // Get one GuildBank
     * const guildBank = await prisma.guildBank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildBankFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildBankFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildBanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildBanks
     * const guildBanks = await prisma.guildBank.findMany()
     * 
     * // Get first 10 GuildBanks
     * const guildBanks = await prisma.guildBank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildBankWithIdOnly = await prisma.guildBank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildBankFindManyArgs>(args?: SelectSubset<T, GuildBankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildBank.
     * @param {GuildBankCreateArgs} args - Arguments to create a GuildBank.
     * @example
     * // Create one GuildBank
     * const GuildBank = await prisma.guildBank.create({
     *   data: {
     *     // ... data to create a GuildBank
     *   }
     * })
     * 
     */
    create<T extends GuildBankCreateArgs>(args: SelectSubset<T, GuildBankCreateArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildBanks.
     * @param {GuildBankCreateManyArgs} args - Arguments to create many GuildBanks.
     * @example
     * // Create many GuildBanks
     * const guildBank = await prisma.guildBank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildBankCreateManyArgs>(args?: SelectSubset<T, GuildBankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildBanks and returns the data saved in the database.
     * @param {GuildBankCreateManyAndReturnArgs} args - Arguments to create many GuildBanks.
     * @example
     * // Create many GuildBanks
     * const guildBank = await prisma.guildBank.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildBanks and only return the `id`
     * const guildBankWithIdOnly = await prisma.guildBank.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildBankCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildBankCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuildBank.
     * @param {GuildBankDeleteArgs} args - Arguments to delete one GuildBank.
     * @example
     * // Delete one GuildBank
     * const GuildBank = await prisma.guildBank.delete({
     *   where: {
     *     // ... filter to delete one GuildBank
     *   }
     * })
     * 
     */
    delete<T extends GuildBankDeleteArgs>(args: SelectSubset<T, GuildBankDeleteArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildBank.
     * @param {GuildBankUpdateArgs} args - Arguments to update one GuildBank.
     * @example
     * // Update one GuildBank
     * const guildBank = await prisma.guildBank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildBankUpdateArgs>(args: SelectSubset<T, GuildBankUpdateArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildBanks.
     * @param {GuildBankDeleteManyArgs} args - Arguments to filter GuildBanks to delete.
     * @example
     * // Delete a few GuildBanks
     * const { count } = await prisma.guildBank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildBankDeleteManyArgs>(args?: SelectSubset<T, GuildBankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildBanks
     * const guildBank = await prisma.guildBank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildBankUpdateManyArgs>(args: SelectSubset<T, GuildBankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildBanks and returns the data updated in the database.
     * @param {GuildBankUpdateManyAndReturnArgs} args - Arguments to update many GuildBanks.
     * @example
     * // Update many GuildBanks
     * const guildBank = await prisma.guildBank.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuildBanks and only return the `id`
     * const guildBankWithIdOnly = await prisma.guildBank.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuildBankUpdateManyAndReturnArgs>(args: SelectSubset<T, GuildBankUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuildBank.
     * @param {GuildBankUpsertArgs} args - Arguments to update or create a GuildBank.
     * @example
     * // Update or create a GuildBank
     * const guildBank = await prisma.guildBank.upsert({
     *   create: {
     *     // ... data to create a GuildBank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildBank we want to update
     *   }
     * })
     */
    upsert<T extends GuildBankUpsertArgs>(args: SelectSubset<T, GuildBankUpsertArgs<ExtArgs>>): Prisma__GuildBankClient<$Result.GetResult<Prisma.$GuildBankPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuildBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankCountArgs} args - Arguments to filter GuildBanks to count.
     * @example
     * // Count the number of GuildBanks
     * const count = await prisma.guildBank.count({
     *   where: {
     *     // ... the filter for the GuildBanks we want to count
     *   }
     * })
    **/
    count<T extends GuildBankCountArgs>(
      args?: Subset<T, GuildBankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildBankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildBankAggregateArgs>(args: Subset<T, GuildBankAggregateArgs>): Prisma.PrismaPromise<GetGuildBankAggregateType<T>>

    /**
     * Group by GuildBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildBankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildBankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildBankGroupByArgs['orderBy'] }
        : { orderBy?: GuildBankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildBankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildBank model
   */
  readonly fields: GuildBankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildBank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildBankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guild<T extends GuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildDefaultArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildBank model
   */
  interface GuildBankFieldRefs {
    readonly id: FieldRef<"GuildBank", 'String'>
    readonly guildId: FieldRef<"GuildBank", 'String'>
    readonly gold: FieldRef<"GuildBank", 'Int'>
    readonly updatedAt: FieldRef<"GuildBank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuildBank findUnique
   */
  export type GuildBankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter, which GuildBank to fetch.
     */
    where: GuildBankWhereUniqueInput
  }

  /**
   * GuildBank findUniqueOrThrow
   */
  export type GuildBankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter, which GuildBank to fetch.
     */
    where: GuildBankWhereUniqueInput
  }

  /**
   * GuildBank findFirst
   */
  export type GuildBankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter, which GuildBank to fetch.
     */
    where?: GuildBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBanks to fetch.
     */
    orderBy?: GuildBankOrderByWithRelationInput | GuildBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBanks.
     */
    cursor?: GuildBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBanks.
     */
    distinct?: GuildBankScalarFieldEnum | GuildBankScalarFieldEnum[]
  }

  /**
   * GuildBank findFirstOrThrow
   */
  export type GuildBankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter, which GuildBank to fetch.
     */
    where?: GuildBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBanks to fetch.
     */
    orderBy?: GuildBankOrderByWithRelationInput | GuildBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildBanks.
     */
    cursor?: GuildBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildBanks.
     */
    distinct?: GuildBankScalarFieldEnum | GuildBankScalarFieldEnum[]
  }

  /**
   * GuildBank findMany
   */
  export type GuildBankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter, which GuildBanks to fetch.
     */
    where?: GuildBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildBanks to fetch.
     */
    orderBy?: GuildBankOrderByWithRelationInput | GuildBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildBanks.
     */
    cursor?: GuildBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildBanks.
     */
    skip?: number
    distinct?: GuildBankScalarFieldEnum | GuildBankScalarFieldEnum[]
  }

  /**
   * GuildBank create
   */
  export type GuildBankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildBank.
     */
    data: XOR<GuildBankCreateInput, GuildBankUncheckedCreateInput>
  }

  /**
   * GuildBank createMany
   */
  export type GuildBankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildBanks.
     */
    data: GuildBankCreateManyInput | GuildBankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildBank createManyAndReturn
   */
  export type GuildBankCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * The data used to create many GuildBanks.
     */
    data: GuildBankCreateManyInput | GuildBankCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildBank update
   */
  export type GuildBankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildBank.
     */
    data: XOR<GuildBankUpdateInput, GuildBankUncheckedUpdateInput>
    /**
     * Choose, which GuildBank to update.
     */
    where: GuildBankWhereUniqueInput
  }

  /**
   * GuildBank updateMany
   */
  export type GuildBankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildBanks.
     */
    data: XOR<GuildBankUpdateManyMutationInput, GuildBankUncheckedUpdateManyInput>
    /**
     * Filter which GuildBanks to update
     */
    where?: GuildBankWhereInput
    /**
     * Limit how many GuildBanks to update.
     */
    limit?: number
  }

  /**
   * GuildBank updateManyAndReturn
   */
  export type GuildBankUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * The data used to update GuildBanks.
     */
    data: XOR<GuildBankUpdateManyMutationInput, GuildBankUncheckedUpdateManyInput>
    /**
     * Filter which GuildBanks to update
     */
    where?: GuildBankWhereInput
    /**
     * Limit how many GuildBanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildBank upsert
   */
  export type GuildBankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildBank to update in case it exists.
     */
    where: GuildBankWhereUniqueInput
    /**
     * In case the GuildBank found by the `where` argument doesn't exist, create a new GuildBank with this data.
     */
    create: XOR<GuildBankCreateInput, GuildBankUncheckedCreateInput>
    /**
     * In case the GuildBank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildBankUpdateInput, GuildBankUncheckedUpdateInput>
  }

  /**
   * GuildBank delete
   */
  export type GuildBankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
    /**
     * Filter which GuildBank to delete.
     */
    where: GuildBankWhereUniqueInput
  }

  /**
   * GuildBank deleteMany
   */
  export type GuildBankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildBanks to delete
     */
    where?: GuildBankWhereInput
    /**
     * Limit how many GuildBanks to delete.
     */
    limit?: number
  }

  /**
   * GuildBank without action
   */
  export type GuildBankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildBank
     */
    select?: GuildBankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildBank
     */
    omit?: GuildBankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildBankInclude<ExtArgs> | null
  }


  /**
   * Model GuildQuest
   */

  export type AggregateGuildQuest = {
    _count: GuildQuestCountAggregateOutputType | null
    _min: GuildQuestMinAggregateOutputType | null
    _max: GuildQuestMaxAggregateOutputType | null
  }

  export type GuildQuestMinAggregateOutputType = {
    id: string | null
    guildId: string | null
    title: string | null
    description: string | null
    reward: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GuildQuestMaxAggregateOutputType = {
    id: string | null
    guildId: string | null
    title: string | null
    description: string | null
    reward: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type GuildQuestCountAggregateOutputType = {
    id: number
    guildId: number
    title: number
    description: number
    reward: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type GuildQuestMinAggregateInputType = {
    id?: true
    guildId?: true
    title?: true
    description?: true
    reward?: true
    isActive?: true
    createdAt?: true
  }

  export type GuildQuestMaxAggregateInputType = {
    id?: true
    guildId?: true
    title?: true
    description?: true
    reward?: true
    isActive?: true
    createdAt?: true
  }

  export type GuildQuestCountAggregateInputType = {
    id?: true
    guildId?: true
    title?: true
    description?: true
    reward?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type GuildQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildQuest to aggregate.
     */
    where?: GuildQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildQuests to fetch.
     */
    orderBy?: GuildQuestOrderByWithRelationInput | GuildQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildQuests
    **/
    _count?: true | GuildQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildQuestMaxAggregateInputType
  }

  export type GetGuildQuestAggregateType<T extends GuildQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildQuest[P]>
      : GetScalarType<T[P], AggregateGuildQuest[P]>
  }




  export type GuildQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildQuestWhereInput
    orderBy?: GuildQuestOrderByWithAggregationInput | GuildQuestOrderByWithAggregationInput[]
    by: GuildQuestScalarFieldEnum[] | GuildQuestScalarFieldEnum
    having?: GuildQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildQuestCountAggregateInputType | true
    _min?: GuildQuestMinAggregateInputType
    _max?: GuildQuestMaxAggregateInputType
  }

  export type GuildQuestGroupByOutputType = {
    id: string
    guildId: string
    title: string
    description: string
    reward: string | null
    isActive: boolean
    createdAt: Date
    _count: GuildQuestCountAggregateOutputType | null
    _min: GuildQuestMinAggregateOutputType | null
    _max: GuildQuestMaxAggregateOutputType | null
  }

  type GetGuildQuestGroupByPayload<T extends GuildQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildQuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuildQuestGroupByOutputType[P]>
        }
      >
    >


  export type GuildQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildQuest"]>

  export type GuildQuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildQuest"]>

  export type GuildQuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guildId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildQuest"]>

  export type GuildQuestSelectScalar = {
    id?: boolean
    guildId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type GuildQuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guildId" | "title" | "description" | "reward" | "isActive" | "createdAt", ExtArgs["result"]["guildQuest"]>
  export type GuildQuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildQuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }
  export type GuildQuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guild?: boolean | GuildDefaultArgs<ExtArgs>
  }

  export type $GuildQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildQuest"
    objects: {
      guild: Prisma.$GuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guildId: string
      title: string
      description: string
      reward: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["guildQuest"]>
    composites: {}
  }

  type GuildQuestGetPayload<S extends boolean | null | undefined | GuildQuestDefaultArgs> = $Result.GetResult<Prisma.$GuildQuestPayload, S>

  type GuildQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildQuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildQuestCountAggregateInputType | true
    }

  export interface GuildQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildQuest'], meta: { name: 'GuildQuest' } }
    /**
     * Find zero or one GuildQuest that matches the filter.
     * @param {GuildQuestFindUniqueArgs} args - Arguments to find a GuildQuest
     * @example
     * // Get one GuildQuest
     * const guildQuest = await prisma.guildQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildQuestFindUniqueArgs>(args: SelectSubset<T, GuildQuestFindUniqueArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildQuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildQuestFindUniqueOrThrowArgs} args - Arguments to find a GuildQuest
     * @example
     * // Get one GuildQuest
     * const guildQuest = await prisma.guildQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildQuestFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildQuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestFindFirstArgs} args - Arguments to find a GuildQuest
     * @example
     * // Get one GuildQuest
     * const guildQuest = await prisma.guildQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildQuestFindFirstArgs>(args?: SelectSubset<T, GuildQuestFindFirstArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestFindFirstOrThrowArgs} args - Arguments to find a GuildQuest
     * @example
     * // Get one GuildQuest
     * const guildQuest = await prisma.guildQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildQuestFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildQuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildQuests
     * const guildQuests = await prisma.guildQuest.findMany()
     * 
     * // Get first 10 GuildQuests
     * const guildQuests = await prisma.guildQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildQuestWithIdOnly = await prisma.guildQuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildQuestFindManyArgs>(args?: SelectSubset<T, GuildQuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildQuest.
     * @param {GuildQuestCreateArgs} args - Arguments to create a GuildQuest.
     * @example
     * // Create one GuildQuest
     * const GuildQuest = await prisma.guildQuest.create({
     *   data: {
     *     // ... data to create a GuildQuest
     *   }
     * })
     * 
     */
    create<T extends GuildQuestCreateArgs>(args: SelectSubset<T, GuildQuestCreateArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildQuests.
     * @param {GuildQuestCreateManyArgs} args - Arguments to create many GuildQuests.
     * @example
     * // Create many GuildQuests
     * const guildQuest = await prisma.guildQuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildQuestCreateManyArgs>(args?: SelectSubset<T, GuildQuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildQuests and returns the data saved in the database.
     * @param {GuildQuestCreateManyAndReturnArgs} args - Arguments to create many GuildQuests.
     * @example
     * // Create many GuildQuests
     * const guildQuest = await prisma.guildQuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildQuests and only return the `id`
     * const guildQuestWithIdOnly = await prisma.guildQuest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildQuestCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildQuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuildQuest.
     * @param {GuildQuestDeleteArgs} args - Arguments to delete one GuildQuest.
     * @example
     * // Delete one GuildQuest
     * const GuildQuest = await prisma.guildQuest.delete({
     *   where: {
     *     // ... filter to delete one GuildQuest
     *   }
     * })
     * 
     */
    delete<T extends GuildQuestDeleteArgs>(args: SelectSubset<T, GuildQuestDeleteArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildQuest.
     * @param {GuildQuestUpdateArgs} args - Arguments to update one GuildQuest.
     * @example
     * // Update one GuildQuest
     * const guildQuest = await prisma.guildQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildQuestUpdateArgs>(args: SelectSubset<T, GuildQuestUpdateArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildQuests.
     * @param {GuildQuestDeleteManyArgs} args - Arguments to filter GuildQuests to delete.
     * @example
     * // Delete a few GuildQuests
     * const { count } = await prisma.guildQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildQuestDeleteManyArgs>(args?: SelectSubset<T, GuildQuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildQuests
     * const guildQuest = await prisma.guildQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildQuestUpdateManyArgs>(args: SelectSubset<T, GuildQuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildQuests and returns the data updated in the database.
     * @param {GuildQuestUpdateManyAndReturnArgs} args - Arguments to update many GuildQuests.
     * @example
     * // Update many GuildQuests
     * const guildQuest = await prisma.guildQuest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuildQuests and only return the `id`
     * const guildQuestWithIdOnly = await prisma.guildQuest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuildQuestUpdateManyAndReturnArgs>(args: SelectSubset<T, GuildQuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuildQuest.
     * @param {GuildQuestUpsertArgs} args - Arguments to update or create a GuildQuest.
     * @example
     * // Update or create a GuildQuest
     * const guildQuest = await prisma.guildQuest.upsert({
     *   create: {
     *     // ... data to create a GuildQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildQuest we want to update
     *   }
     * })
     */
    upsert<T extends GuildQuestUpsertArgs>(args: SelectSubset<T, GuildQuestUpsertArgs<ExtArgs>>): Prisma__GuildQuestClient<$Result.GetResult<Prisma.$GuildQuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuildQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestCountArgs} args - Arguments to filter GuildQuests to count.
     * @example
     * // Count the number of GuildQuests
     * const count = await prisma.guildQuest.count({
     *   where: {
     *     // ... the filter for the GuildQuests we want to count
     *   }
     * })
    **/
    count<T extends GuildQuestCountArgs>(
      args?: Subset<T, GuildQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildQuestAggregateArgs>(args: Subset<T, GuildQuestAggregateArgs>): Prisma.PrismaPromise<GetGuildQuestAggregateType<T>>

    /**
     * Group by GuildQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildQuestGroupByArgs['orderBy'] }
        : { orderBy?: GuildQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildQuest model
   */
  readonly fields: GuildQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guild<T extends GuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildDefaultArgs<ExtArgs>>): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildQuest model
   */
  interface GuildQuestFieldRefs {
    readonly id: FieldRef<"GuildQuest", 'String'>
    readonly guildId: FieldRef<"GuildQuest", 'String'>
    readonly title: FieldRef<"GuildQuest", 'String'>
    readonly description: FieldRef<"GuildQuest", 'String'>
    readonly reward: FieldRef<"GuildQuest", 'String'>
    readonly isActive: FieldRef<"GuildQuest", 'Boolean'>
    readonly createdAt: FieldRef<"GuildQuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuildQuest findUnique
   */
  export type GuildQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter, which GuildQuest to fetch.
     */
    where: GuildQuestWhereUniqueInput
  }

  /**
   * GuildQuest findUniqueOrThrow
   */
  export type GuildQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter, which GuildQuest to fetch.
     */
    where: GuildQuestWhereUniqueInput
  }

  /**
   * GuildQuest findFirst
   */
  export type GuildQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter, which GuildQuest to fetch.
     */
    where?: GuildQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildQuests to fetch.
     */
    orderBy?: GuildQuestOrderByWithRelationInput | GuildQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildQuests.
     */
    cursor?: GuildQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildQuests.
     */
    distinct?: GuildQuestScalarFieldEnum | GuildQuestScalarFieldEnum[]
  }

  /**
   * GuildQuest findFirstOrThrow
   */
  export type GuildQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter, which GuildQuest to fetch.
     */
    where?: GuildQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildQuests to fetch.
     */
    orderBy?: GuildQuestOrderByWithRelationInput | GuildQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildQuests.
     */
    cursor?: GuildQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildQuests.
     */
    distinct?: GuildQuestScalarFieldEnum | GuildQuestScalarFieldEnum[]
  }

  /**
   * GuildQuest findMany
   */
  export type GuildQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter, which GuildQuests to fetch.
     */
    where?: GuildQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildQuests to fetch.
     */
    orderBy?: GuildQuestOrderByWithRelationInput | GuildQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildQuests.
     */
    cursor?: GuildQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildQuests.
     */
    skip?: number
    distinct?: GuildQuestScalarFieldEnum | GuildQuestScalarFieldEnum[]
  }

  /**
   * GuildQuest create
   */
  export type GuildQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildQuest.
     */
    data: XOR<GuildQuestCreateInput, GuildQuestUncheckedCreateInput>
  }

  /**
   * GuildQuest createMany
   */
  export type GuildQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildQuests.
     */
    data: GuildQuestCreateManyInput | GuildQuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildQuest createManyAndReturn
   */
  export type GuildQuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * The data used to create many GuildQuests.
     */
    data: GuildQuestCreateManyInput | GuildQuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildQuest update
   */
  export type GuildQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildQuest.
     */
    data: XOR<GuildQuestUpdateInput, GuildQuestUncheckedUpdateInput>
    /**
     * Choose, which GuildQuest to update.
     */
    where: GuildQuestWhereUniqueInput
  }

  /**
   * GuildQuest updateMany
   */
  export type GuildQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildQuests.
     */
    data: XOR<GuildQuestUpdateManyMutationInput, GuildQuestUncheckedUpdateManyInput>
    /**
     * Filter which GuildQuests to update
     */
    where?: GuildQuestWhereInput
    /**
     * Limit how many GuildQuests to update.
     */
    limit?: number
  }

  /**
   * GuildQuest updateManyAndReturn
   */
  export type GuildQuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * The data used to update GuildQuests.
     */
    data: XOR<GuildQuestUpdateManyMutationInput, GuildQuestUncheckedUpdateManyInput>
    /**
     * Filter which GuildQuests to update
     */
    where?: GuildQuestWhereInput
    /**
     * Limit how many GuildQuests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildQuest upsert
   */
  export type GuildQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildQuest to update in case it exists.
     */
    where: GuildQuestWhereUniqueInput
    /**
     * In case the GuildQuest found by the `where` argument doesn't exist, create a new GuildQuest with this data.
     */
    create: XOR<GuildQuestCreateInput, GuildQuestUncheckedCreateInput>
    /**
     * In case the GuildQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildQuestUpdateInput, GuildQuestUncheckedUpdateInput>
  }

  /**
   * GuildQuest delete
   */
  export type GuildQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
    /**
     * Filter which GuildQuest to delete.
     */
    where: GuildQuestWhereUniqueInput
  }

  /**
   * GuildQuest deleteMany
   */
  export type GuildQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildQuests to delete
     */
    where?: GuildQuestWhereInput
    /**
     * Limit how many GuildQuests to delete.
     */
    limit?: number
  }

  /**
   * GuildQuest without action
   */
  export type GuildQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildQuest
     */
    select?: GuildQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildQuest
     */
    omit?: GuildQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildQuestInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    gold: number | null
    vaultLevel: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    gold: number | null
    vaultLevel: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    gold: number | null
    vaultLevel: number | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    gold: number | null
    vaultLevel: number | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    playerId: number
    gold: number
    vaultLevel: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    gold?: true
    vaultLevel?: true
  }

  export type BankAccountSumAggregateInputType = {
    gold?: true
    vaultLevel?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    playerId?: true
    gold?: true
    vaultLevel?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    playerId?: true
    gold?: true
    vaultLevel?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    playerId?: true
    gold?: true
    vaultLevel?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    playerId: string
    gold: number
    vaultLevel: number
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gold?: boolean
    vaultLevel?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    vaultItems?: boolean | BankAccount$vaultItemsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gold?: boolean
    vaultLevel?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gold?: boolean
    vaultLevel?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    playerId?: boolean
    gold?: boolean
    vaultLevel?: boolean
    updatedAt?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "gold" | "vaultLevel" | "updatedAt", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    vaultItems?: boolean | BankAccount$vaultItemsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      vaultItems: Prisma.$BankVaultItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      gold: number
      vaultLevel: number
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaultItems<T extends BankAccount$vaultItemsArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$vaultItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly playerId: FieldRef<"BankAccount", 'String'>
    readonly gold: FieldRef<"BankAccount", 'Int'>
    readonly vaultLevel: FieldRef<"BankAccount", 'Int'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.vaultItems
   */
  export type BankAccount$vaultItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    where?: BankVaultItemWhereInput
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    cursor?: BankVaultItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankVaultItemScalarFieldEnum | BankVaultItemScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model BankVaultItem
   */

  export type AggregateBankVaultItem = {
    _count: BankVaultItemCountAggregateOutputType | null
    _avg: BankVaultItemAvgAggregateOutputType | null
    _sum: BankVaultItemSumAggregateOutputType | null
    _min: BankVaultItemMinAggregateOutputType | null
    _max: BankVaultItemMaxAggregateOutputType | null
  }

  export type BankVaultItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type BankVaultItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type BankVaultItemMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    itemId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type BankVaultItemMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    itemId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type BankVaultItemCountAggregateOutputType = {
    id: number
    accountId: number
    itemId: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type BankVaultItemAvgAggregateInputType = {
    quantity?: true
  }

  export type BankVaultItemSumAggregateInputType = {
    quantity?: true
  }

  export type BankVaultItemMinAggregateInputType = {
    id?: true
    accountId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
  }

  export type BankVaultItemMaxAggregateInputType = {
    id?: true
    accountId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
  }

  export type BankVaultItemCountAggregateInputType = {
    id?: true
    accountId?: true
    itemId?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type BankVaultItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankVaultItem to aggregate.
     */
    where?: BankVaultItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankVaultItems to fetch.
     */
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankVaultItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankVaultItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankVaultItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankVaultItems
    **/
    _count?: true | BankVaultItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankVaultItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankVaultItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankVaultItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankVaultItemMaxAggregateInputType
  }

  export type GetBankVaultItemAggregateType<T extends BankVaultItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBankVaultItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankVaultItem[P]>
      : GetScalarType<T[P], AggregateBankVaultItem[P]>
  }




  export type BankVaultItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankVaultItemWhereInput
    orderBy?: BankVaultItemOrderByWithAggregationInput | BankVaultItemOrderByWithAggregationInput[]
    by: BankVaultItemScalarFieldEnum[] | BankVaultItemScalarFieldEnum
    having?: BankVaultItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankVaultItemCountAggregateInputType | true
    _avg?: BankVaultItemAvgAggregateInputType
    _sum?: BankVaultItemSumAggregateInputType
    _min?: BankVaultItemMinAggregateInputType
    _max?: BankVaultItemMaxAggregateInputType
  }

  export type BankVaultItemGroupByOutputType = {
    id: string
    accountId: string
    itemId: string
    quantity: number
    createdAt: Date
    _count: BankVaultItemCountAggregateOutputType | null
    _avg: BankVaultItemAvgAggregateOutputType | null
    _sum: BankVaultItemSumAggregateOutputType | null
    _min: BankVaultItemMinAggregateOutputType | null
    _max: BankVaultItemMaxAggregateOutputType | null
  }

  type GetBankVaultItemGroupByPayload<T extends BankVaultItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankVaultItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankVaultItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankVaultItemGroupByOutputType[P]>
            : GetScalarType<T[P], BankVaultItemGroupByOutputType[P]>
        }
      >
    >


  export type BankVaultItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankVaultItem"]>

  export type BankVaultItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankVaultItem"]>

  export type BankVaultItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankVaultItem"]>

  export type BankVaultItemSelectScalar = {
    id?: boolean
    accountId?: boolean
    itemId?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type BankVaultItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "itemId" | "quantity" | "createdAt", ExtArgs["result"]["bankVaultItem"]>
  export type BankVaultItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BankVaultItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BankVaultItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $BankVaultItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankVaultItem"
    objects: {
      account: Prisma.$BankAccountPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      itemId: string
      quantity: number
      createdAt: Date
    }, ExtArgs["result"]["bankVaultItem"]>
    composites: {}
  }

  type BankVaultItemGetPayload<S extends boolean | null | undefined | BankVaultItemDefaultArgs> = $Result.GetResult<Prisma.$BankVaultItemPayload, S>

  type BankVaultItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankVaultItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankVaultItemCountAggregateInputType | true
    }

  export interface BankVaultItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankVaultItem'], meta: { name: 'BankVaultItem' } }
    /**
     * Find zero or one BankVaultItem that matches the filter.
     * @param {BankVaultItemFindUniqueArgs} args - Arguments to find a BankVaultItem
     * @example
     * // Get one BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankVaultItemFindUniqueArgs>(args: SelectSubset<T, BankVaultItemFindUniqueArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankVaultItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankVaultItemFindUniqueOrThrowArgs} args - Arguments to find a BankVaultItem
     * @example
     * // Get one BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankVaultItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BankVaultItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankVaultItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemFindFirstArgs} args - Arguments to find a BankVaultItem
     * @example
     * // Get one BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankVaultItemFindFirstArgs>(args?: SelectSubset<T, BankVaultItemFindFirstArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankVaultItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemFindFirstOrThrowArgs} args - Arguments to find a BankVaultItem
     * @example
     * // Get one BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankVaultItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BankVaultItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankVaultItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankVaultItems
     * const bankVaultItems = await prisma.bankVaultItem.findMany()
     * 
     * // Get first 10 BankVaultItems
     * const bankVaultItems = await prisma.bankVaultItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankVaultItemWithIdOnly = await prisma.bankVaultItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankVaultItemFindManyArgs>(args?: SelectSubset<T, BankVaultItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankVaultItem.
     * @param {BankVaultItemCreateArgs} args - Arguments to create a BankVaultItem.
     * @example
     * // Create one BankVaultItem
     * const BankVaultItem = await prisma.bankVaultItem.create({
     *   data: {
     *     // ... data to create a BankVaultItem
     *   }
     * })
     * 
     */
    create<T extends BankVaultItemCreateArgs>(args: SelectSubset<T, BankVaultItemCreateArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankVaultItems.
     * @param {BankVaultItemCreateManyArgs} args - Arguments to create many BankVaultItems.
     * @example
     * // Create many BankVaultItems
     * const bankVaultItem = await prisma.bankVaultItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankVaultItemCreateManyArgs>(args?: SelectSubset<T, BankVaultItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankVaultItems and returns the data saved in the database.
     * @param {BankVaultItemCreateManyAndReturnArgs} args - Arguments to create many BankVaultItems.
     * @example
     * // Create many BankVaultItems
     * const bankVaultItem = await prisma.bankVaultItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankVaultItems and only return the `id`
     * const bankVaultItemWithIdOnly = await prisma.bankVaultItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankVaultItemCreateManyAndReturnArgs>(args?: SelectSubset<T, BankVaultItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankVaultItem.
     * @param {BankVaultItemDeleteArgs} args - Arguments to delete one BankVaultItem.
     * @example
     * // Delete one BankVaultItem
     * const BankVaultItem = await prisma.bankVaultItem.delete({
     *   where: {
     *     // ... filter to delete one BankVaultItem
     *   }
     * })
     * 
     */
    delete<T extends BankVaultItemDeleteArgs>(args: SelectSubset<T, BankVaultItemDeleteArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankVaultItem.
     * @param {BankVaultItemUpdateArgs} args - Arguments to update one BankVaultItem.
     * @example
     * // Update one BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankVaultItemUpdateArgs>(args: SelectSubset<T, BankVaultItemUpdateArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankVaultItems.
     * @param {BankVaultItemDeleteManyArgs} args - Arguments to filter BankVaultItems to delete.
     * @example
     * // Delete a few BankVaultItems
     * const { count } = await prisma.bankVaultItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankVaultItemDeleteManyArgs>(args?: SelectSubset<T, BankVaultItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankVaultItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankVaultItems
     * const bankVaultItem = await prisma.bankVaultItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankVaultItemUpdateManyArgs>(args: SelectSubset<T, BankVaultItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankVaultItems and returns the data updated in the database.
     * @param {BankVaultItemUpdateManyAndReturnArgs} args - Arguments to update many BankVaultItems.
     * @example
     * // Update many BankVaultItems
     * const bankVaultItem = await prisma.bankVaultItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankVaultItems and only return the `id`
     * const bankVaultItemWithIdOnly = await prisma.bankVaultItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankVaultItemUpdateManyAndReturnArgs>(args: SelectSubset<T, BankVaultItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankVaultItem.
     * @param {BankVaultItemUpsertArgs} args - Arguments to update or create a BankVaultItem.
     * @example
     * // Update or create a BankVaultItem
     * const bankVaultItem = await prisma.bankVaultItem.upsert({
     *   create: {
     *     // ... data to create a BankVaultItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankVaultItem we want to update
     *   }
     * })
     */
    upsert<T extends BankVaultItemUpsertArgs>(args: SelectSubset<T, BankVaultItemUpsertArgs<ExtArgs>>): Prisma__BankVaultItemClient<$Result.GetResult<Prisma.$BankVaultItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankVaultItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemCountArgs} args - Arguments to filter BankVaultItems to count.
     * @example
     * // Count the number of BankVaultItems
     * const count = await prisma.bankVaultItem.count({
     *   where: {
     *     // ... the filter for the BankVaultItems we want to count
     *   }
     * })
    **/
    count<T extends BankVaultItemCountArgs>(
      args?: Subset<T, BankVaultItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankVaultItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankVaultItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankVaultItemAggregateArgs>(args: Subset<T, BankVaultItemAggregateArgs>): Prisma.PrismaPromise<GetBankVaultItemAggregateType<T>>

    /**
     * Group by BankVaultItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankVaultItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankVaultItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankVaultItemGroupByArgs['orderBy'] }
        : { orderBy?: BankVaultItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankVaultItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankVaultItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankVaultItem model
   */
  readonly fields: BankVaultItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankVaultItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankVaultItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankVaultItem model
   */
  interface BankVaultItemFieldRefs {
    readonly id: FieldRef<"BankVaultItem", 'String'>
    readonly accountId: FieldRef<"BankVaultItem", 'String'>
    readonly itemId: FieldRef<"BankVaultItem", 'String'>
    readonly quantity: FieldRef<"BankVaultItem", 'Int'>
    readonly createdAt: FieldRef<"BankVaultItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankVaultItem findUnique
   */
  export type BankVaultItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter, which BankVaultItem to fetch.
     */
    where: BankVaultItemWhereUniqueInput
  }

  /**
   * BankVaultItem findUniqueOrThrow
   */
  export type BankVaultItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter, which BankVaultItem to fetch.
     */
    where: BankVaultItemWhereUniqueInput
  }

  /**
   * BankVaultItem findFirst
   */
  export type BankVaultItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter, which BankVaultItem to fetch.
     */
    where?: BankVaultItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankVaultItems to fetch.
     */
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankVaultItems.
     */
    cursor?: BankVaultItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankVaultItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankVaultItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankVaultItems.
     */
    distinct?: BankVaultItemScalarFieldEnum | BankVaultItemScalarFieldEnum[]
  }

  /**
   * BankVaultItem findFirstOrThrow
   */
  export type BankVaultItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter, which BankVaultItem to fetch.
     */
    where?: BankVaultItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankVaultItems to fetch.
     */
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankVaultItems.
     */
    cursor?: BankVaultItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankVaultItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankVaultItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankVaultItems.
     */
    distinct?: BankVaultItemScalarFieldEnum | BankVaultItemScalarFieldEnum[]
  }

  /**
   * BankVaultItem findMany
   */
  export type BankVaultItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter, which BankVaultItems to fetch.
     */
    where?: BankVaultItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankVaultItems to fetch.
     */
    orderBy?: BankVaultItemOrderByWithRelationInput | BankVaultItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankVaultItems.
     */
    cursor?: BankVaultItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankVaultItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankVaultItems.
     */
    skip?: number
    distinct?: BankVaultItemScalarFieldEnum | BankVaultItemScalarFieldEnum[]
  }

  /**
   * BankVaultItem create
   */
  export type BankVaultItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BankVaultItem.
     */
    data: XOR<BankVaultItemCreateInput, BankVaultItemUncheckedCreateInput>
  }

  /**
   * BankVaultItem createMany
   */
  export type BankVaultItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankVaultItems.
     */
    data: BankVaultItemCreateManyInput | BankVaultItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankVaultItem createManyAndReturn
   */
  export type BankVaultItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * The data used to create many BankVaultItems.
     */
    data: BankVaultItemCreateManyInput | BankVaultItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankVaultItem update
   */
  export type BankVaultItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BankVaultItem.
     */
    data: XOR<BankVaultItemUpdateInput, BankVaultItemUncheckedUpdateInput>
    /**
     * Choose, which BankVaultItem to update.
     */
    where: BankVaultItemWhereUniqueInput
  }

  /**
   * BankVaultItem updateMany
   */
  export type BankVaultItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankVaultItems.
     */
    data: XOR<BankVaultItemUpdateManyMutationInput, BankVaultItemUncheckedUpdateManyInput>
    /**
     * Filter which BankVaultItems to update
     */
    where?: BankVaultItemWhereInput
    /**
     * Limit how many BankVaultItems to update.
     */
    limit?: number
  }

  /**
   * BankVaultItem updateManyAndReturn
   */
  export type BankVaultItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * The data used to update BankVaultItems.
     */
    data: XOR<BankVaultItemUpdateManyMutationInput, BankVaultItemUncheckedUpdateManyInput>
    /**
     * Filter which BankVaultItems to update
     */
    where?: BankVaultItemWhereInput
    /**
     * Limit how many BankVaultItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankVaultItem upsert
   */
  export type BankVaultItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BankVaultItem to update in case it exists.
     */
    where: BankVaultItemWhereUniqueInput
    /**
     * In case the BankVaultItem found by the `where` argument doesn't exist, create a new BankVaultItem with this data.
     */
    create: XOR<BankVaultItemCreateInput, BankVaultItemUncheckedCreateInput>
    /**
     * In case the BankVaultItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankVaultItemUpdateInput, BankVaultItemUncheckedUpdateInput>
  }

  /**
   * BankVaultItem delete
   */
  export type BankVaultItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
    /**
     * Filter which BankVaultItem to delete.
     */
    where: BankVaultItemWhereUniqueInput
  }

  /**
   * BankVaultItem deleteMany
   */
  export type BankVaultItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankVaultItems to delete
     */
    where?: BankVaultItemWhereInput
    /**
     * Limit how many BankVaultItems to delete.
     */
    limit?: number
  }

  /**
   * BankVaultItem without action
   */
  export type BankVaultItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankVaultItem
     */
    select?: BankVaultItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankVaultItem
     */
    omit?: BankVaultItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankVaultItemInclude<ExtArgs> | null
  }


  /**
   * Model MarketListing
   */

  export type AggregateMarketListing = {
    _count: MarketListingCountAggregateOutputType | null
    _avg: MarketListingAvgAggregateOutputType | null
    _sum: MarketListingSumAggregateOutputType | null
    _min: MarketListingMinAggregateOutputType | null
    _max: MarketListingMaxAggregateOutputType | null
  }

  export type MarketListingAvgAggregateOutputType = {
    quantity: number | null
    pricePerUnit: number | null
    totalPrice: number | null
    listingTax: number | null
  }

  export type MarketListingSumAggregateOutputType = {
    quantity: number | null
    pricePerUnit: number | null
    totalPrice: number | null
    listingTax: number | null
  }

  export type MarketListingMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
    pricePerUnit: number | null
    totalPrice: number | null
    listingTax: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    soldAt: Date | null
  }

  export type MarketListingMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
    pricePerUnit: number | null
    totalPrice: number | null
    listingTax: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    soldAt: Date | null
  }

  export type MarketListingCountAggregateOutputType = {
    id: number
    playerId: number
    itemId: number
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive: number
    expiresAt: number
    createdAt: number
    soldAt: number
    _all: number
  }


  export type MarketListingAvgAggregateInputType = {
    quantity?: true
    pricePerUnit?: true
    totalPrice?: true
    listingTax?: true
  }

  export type MarketListingSumAggregateInputType = {
    quantity?: true
    pricePerUnit?: true
    totalPrice?: true
    listingTax?: true
  }

  export type MarketListingMinAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    pricePerUnit?: true
    totalPrice?: true
    listingTax?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    soldAt?: true
  }

  export type MarketListingMaxAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    pricePerUnit?: true
    totalPrice?: true
    listingTax?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    soldAt?: true
  }

  export type MarketListingCountAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    pricePerUnit?: true
    totalPrice?: true
    listingTax?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    soldAt?: true
    _all?: true
  }

  export type MarketListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketListing to aggregate.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketListings
    **/
    _count?: true | MarketListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketListingMaxAggregateInputType
  }

  export type GetMarketListingAggregateType<T extends MarketListingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketListing[P]>
      : GetScalarType<T[P], AggregateMarketListing[P]>
  }




  export type MarketListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketListingWhereInput
    orderBy?: MarketListingOrderByWithAggregationInput | MarketListingOrderByWithAggregationInput[]
    by: MarketListingScalarFieldEnum[] | MarketListingScalarFieldEnum
    having?: MarketListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketListingCountAggregateInputType | true
    _avg?: MarketListingAvgAggregateInputType
    _sum?: MarketListingSumAggregateInputType
    _min?: MarketListingMinAggregateInputType
    _max?: MarketListingMaxAggregateInputType
  }

  export type MarketListingGroupByOutputType = {
    id: string
    playerId: string
    itemId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    soldAt: Date | null
    _count: MarketListingCountAggregateOutputType | null
    _avg: MarketListingAvgAggregateOutputType | null
    _sum: MarketListingSumAggregateOutputType | null
    _min: MarketListingMinAggregateOutputType | null
    _max: MarketListingMaxAggregateOutputType | null
  }

  type GetMarketListingGroupByPayload<T extends MarketListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketListingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketListingGroupByOutputType[P]>
        }
      >
    >


  export type MarketListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalPrice?: boolean
    listingTax?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    soldAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalPrice?: boolean
    listingTax?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    soldAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalPrice?: boolean
    listingTax?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    soldAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketListing"]>

  export type MarketListingSelectScalar = {
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    pricePerUnit?: boolean
    totalPrice?: boolean
    listingTax?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    soldAt?: boolean
  }

  export type MarketListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "itemId" | "quantity" | "pricePerUnit" | "totalPrice" | "listingTax" | "isActive" | "expiresAt" | "createdAt" | "soldAt", ExtArgs["result"]["marketListing"]>
  export type MarketListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type MarketListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type MarketListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $MarketListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketListing"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      itemId: string
      quantity: number
      pricePerUnit: number
      totalPrice: number
      listingTax: number
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
      soldAt: Date | null
    }, ExtArgs["result"]["marketListing"]>
    composites: {}
  }

  type MarketListingGetPayload<S extends boolean | null | undefined | MarketListingDefaultArgs> = $Result.GetResult<Prisma.$MarketListingPayload, S>

  type MarketListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketListingCountAggregateInputType | true
    }

  export interface MarketListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketListing'], meta: { name: 'MarketListing' } }
    /**
     * Find zero or one MarketListing that matches the filter.
     * @param {MarketListingFindUniqueArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketListingFindUniqueArgs>(args: SelectSubset<T, MarketListingFindUniqueArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketListingFindUniqueOrThrowArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketListingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindFirstArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketListingFindFirstArgs>(args?: SelectSubset<T, MarketListingFindFirstArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindFirstOrThrowArgs} args - Arguments to find a MarketListing
     * @example
     * // Get one MarketListing
     * const marketListing = await prisma.marketListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketListingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketListings
     * const marketListings = await prisma.marketListing.findMany()
     * 
     * // Get first 10 MarketListings
     * const marketListings = await prisma.marketListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketListingFindManyArgs>(args?: SelectSubset<T, MarketListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketListing.
     * @param {MarketListingCreateArgs} args - Arguments to create a MarketListing.
     * @example
     * // Create one MarketListing
     * const MarketListing = await prisma.marketListing.create({
     *   data: {
     *     // ... data to create a MarketListing
     *   }
     * })
     * 
     */
    create<T extends MarketListingCreateArgs>(args: SelectSubset<T, MarketListingCreateArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketListings.
     * @param {MarketListingCreateManyArgs} args - Arguments to create many MarketListings.
     * @example
     * // Create many MarketListings
     * const marketListing = await prisma.marketListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketListingCreateManyArgs>(args?: SelectSubset<T, MarketListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketListings and returns the data saved in the database.
     * @param {MarketListingCreateManyAndReturnArgs} args - Arguments to create many MarketListings.
     * @example
     * // Create many MarketListings
     * const marketListing = await prisma.marketListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketListings and only return the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketListingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketListing.
     * @param {MarketListingDeleteArgs} args - Arguments to delete one MarketListing.
     * @example
     * // Delete one MarketListing
     * const MarketListing = await prisma.marketListing.delete({
     *   where: {
     *     // ... filter to delete one MarketListing
     *   }
     * })
     * 
     */
    delete<T extends MarketListingDeleteArgs>(args: SelectSubset<T, MarketListingDeleteArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketListing.
     * @param {MarketListingUpdateArgs} args - Arguments to update one MarketListing.
     * @example
     * // Update one MarketListing
     * const marketListing = await prisma.marketListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketListingUpdateArgs>(args: SelectSubset<T, MarketListingUpdateArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketListings.
     * @param {MarketListingDeleteManyArgs} args - Arguments to filter MarketListings to delete.
     * @example
     * // Delete a few MarketListings
     * const { count } = await prisma.marketListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketListingDeleteManyArgs>(args?: SelectSubset<T, MarketListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketListings
     * const marketListing = await prisma.marketListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketListingUpdateManyArgs>(args: SelectSubset<T, MarketListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketListings and returns the data updated in the database.
     * @param {MarketListingUpdateManyAndReturnArgs} args - Arguments to update many MarketListings.
     * @example
     * // Update many MarketListings
     * const marketListing = await prisma.marketListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketListings and only return the `id`
     * const marketListingWithIdOnly = await prisma.marketListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketListingUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketListing.
     * @param {MarketListingUpsertArgs} args - Arguments to update or create a MarketListing.
     * @example
     * // Update or create a MarketListing
     * const marketListing = await prisma.marketListing.upsert({
     *   create: {
     *     // ... data to create a MarketListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketListing we want to update
     *   }
     * })
     */
    upsert<T extends MarketListingUpsertArgs>(args: SelectSubset<T, MarketListingUpsertArgs<ExtArgs>>): Prisma__MarketListingClient<$Result.GetResult<Prisma.$MarketListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingCountArgs} args - Arguments to filter MarketListings to count.
     * @example
     * // Count the number of MarketListings
     * const count = await prisma.marketListing.count({
     *   where: {
     *     // ... the filter for the MarketListings we want to count
     *   }
     * })
    **/
    count<T extends MarketListingCountArgs>(
      args?: Subset<T, MarketListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketListingAggregateArgs>(args: Subset<T, MarketListingAggregateArgs>): Prisma.PrismaPromise<GetMarketListingAggregateType<T>>

    /**
     * Group by MarketListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketListingGroupByArgs['orderBy'] }
        : { orderBy?: MarketListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketListing model
   */
  readonly fields: MarketListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketListing model
   */
  interface MarketListingFieldRefs {
    readonly id: FieldRef<"MarketListing", 'String'>
    readonly playerId: FieldRef<"MarketListing", 'String'>
    readonly itemId: FieldRef<"MarketListing", 'String'>
    readonly quantity: FieldRef<"MarketListing", 'Int'>
    readonly pricePerUnit: FieldRef<"MarketListing", 'Int'>
    readonly totalPrice: FieldRef<"MarketListing", 'Int'>
    readonly listingTax: FieldRef<"MarketListing", 'Int'>
    readonly isActive: FieldRef<"MarketListing", 'Boolean'>
    readonly expiresAt: FieldRef<"MarketListing", 'DateTime'>
    readonly createdAt: FieldRef<"MarketListing", 'DateTime'>
    readonly soldAt: FieldRef<"MarketListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketListing findUnique
   */
  export type MarketListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing findUniqueOrThrow
   */
  export type MarketListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing findFirst
   */
  export type MarketListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketListings.
     */
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing findFirstOrThrow
   */
  export type MarketListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListing to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketListings.
     */
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing findMany
   */
  export type MarketListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketListings to fetch.
     */
    where?: MarketListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketListings to fetch.
     */
    orderBy?: MarketListingOrderByWithRelationInput | MarketListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketListings.
     */
    cursor?: MarketListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketListings.
     */
    skip?: number
    distinct?: MarketListingScalarFieldEnum | MarketListingScalarFieldEnum[]
  }

  /**
   * MarketListing create
   */
  export type MarketListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketListing.
     */
    data: XOR<MarketListingCreateInput, MarketListingUncheckedCreateInput>
  }

  /**
   * MarketListing createMany
   */
  export type MarketListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketListings.
     */
    data: MarketListingCreateManyInput | MarketListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketListing createManyAndReturn
   */
  export type MarketListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * The data used to create many MarketListings.
     */
    data: MarketListingCreateManyInput | MarketListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketListing update
   */
  export type MarketListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketListing.
     */
    data: XOR<MarketListingUpdateInput, MarketListingUncheckedUpdateInput>
    /**
     * Choose, which MarketListing to update.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing updateMany
   */
  export type MarketListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketListings.
     */
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketListings to update
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to update.
     */
    limit?: number
  }

  /**
   * MarketListing updateManyAndReturn
   */
  export type MarketListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * The data used to update MarketListings.
     */
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketListings to update
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketListing upsert
   */
  export type MarketListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketListing to update in case it exists.
     */
    where: MarketListingWhereUniqueInput
    /**
     * In case the MarketListing found by the `where` argument doesn't exist, create a new MarketListing with this data.
     */
    create: XOR<MarketListingCreateInput, MarketListingUncheckedCreateInput>
    /**
     * In case the MarketListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketListingUpdateInput, MarketListingUncheckedUpdateInput>
  }

  /**
   * MarketListing delete
   */
  export type MarketListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
    /**
     * Filter which MarketListing to delete.
     */
    where: MarketListingWhereUniqueInput
  }

  /**
   * MarketListing deleteMany
   */
  export type MarketListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketListings to delete
     */
    where?: MarketListingWhereInput
    /**
     * Limit how many MarketListings to delete.
     */
    limit?: number
  }

  /**
   * MarketListing without action
   */
  export type MarketListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketListing
     */
    select?: MarketListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketListing
     */
    omit?: MarketListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketListingInclude<ExtArgs> | null
  }


  /**
   * Model MarketTransaction
   */

  export type AggregateMarketTransaction = {
    _count: MarketTransactionCountAggregateOutputType | null
    _avg: MarketTransactionAvgAggregateOutputType | null
    _sum: MarketTransactionSumAggregateOutputType | null
    _min: MarketTransactionMinAggregateOutputType | null
    _max: MarketTransactionMaxAggregateOutputType | null
  }

  export type MarketTransactionAvgAggregateOutputType = {
    quantity: number | null
    totalPrice: number | null
  }

  export type MarketTransactionSumAggregateOutputType = {
    quantity: number | null
    totalPrice: number | null
  }

  export type MarketTransactionMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    itemId: string | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
  }

  export type MarketTransactionMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    itemId: string | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
  }

  export type MarketTransactionCountAggregateOutputType = {
    id: number
    listingId: number
    buyerId: number
    sellerId: number
    itemId: number
    quantity: number
    totalPrice: number
    createdAt: number
    _all: number
  }


  export type MarketTransactionAvgAggregateInputType = {
    quantity?: true
    totalPrice?: true
  }

  export type MarketTransactionSumAggregateInputType = {
    quantity?: true
    totalPrice?: true
  }

  export type MarketTransactionMinAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    itemId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
  }

  export type MarketTransactionMaxAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    itemId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
  }

  export type MarketTransactionCountAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    itemId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    _all?: true
  }

  export type MarketTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTransaction to aggregate.
     */
    where?: MarketTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTransactions to fetch.
     */
    orderBy?: MarketTransactionOrderByWithRelationInput | MarketTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketTransactions
    **/
    _count?: true | MarketTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketTransactionMaxAggregateInputType
  }

  export type GetMarketTransactionAggregateType<T extends MarketTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketTransaction[P]>
      : GetScalarType<T[P], AggregateMarketTransaction[P]>
  }




  export type MarketTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketTransactionWhereInput
    orderBy?: MarketTransactionOrderByWithAggregationInput | MarketTransactionOrderByWithAggregationInput[]
    by: MarketTransactionScalarFieldEnum[] | MarketTransactionScalarFieldEnum
    having?: MarketTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketTransactionCountAggregateInputType | true
    _avg?: MarketTransactionAvgAggregateInputType
    _sum?: MarketTransactionSumAggregateInputType
    _min?: MarketTransactionMinAggregateInputType
    _max?: MarketTransactionMaxAggregateInputType
  }

  export type MarketTransactionGroupByOutputType = {
    id: string
    listingId: string
    buyerId: string
    sellerId: string
    itemId: string
    quantity: number
    totalPrice: number
    createdAt: Date
    _count: MarketTransactionCountAggregateOutputType | null
    _avg: MarketTransactionAvgAggregateOutputType | null
    _sum: MarketTransactionSumAggregateOutputType | null
    _min: MarketTransactionMinAggregateOutputType | null
    _max: MarketTransactionMaxAggregateOutputType | null
  }

  type GetMarketTransactionGroupByPayload<T extends MarketTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], MarketTransactionGroupByOutputType[P]>
        }
      >
    >


  export type MarketTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    itemId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["marketTransaction"]>

  export type MarketTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    itemId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["marketTransaction"]>

  export type MarketTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    itemId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["marketTransaction"]>

  export type MarketTransactionSelectScalar = {
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    itemId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
  }

  export type MarketTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "buyerId" | "sellerId" | "itemId" | "quantity" | "totalPrice" | "createdAt", ExtArgs["result"]["marketTransaction"]>

  export type $MarketTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      buyerId: string
      sellerId: string
      itemId: string
      quantity: number
      totalPrice: number
      createdAt: Date
    }, ExtArgs["result"]["marketTransaction"]>
    composites: {}
  }

  type MarketTransactionGetPayload<S extends boolean | null | undefined | MarketTransactionDefaultArgs> = $Result.GetResult<Prisma.$MarketTransactionPayload, S>

  type MarketTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketTransactionCountAggregateInputType | true
    }

  export interface MarketTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketTransaction'], meta: { name: 'MarketTransaction' } }
    /**
     * Find zero or one MarketTransaction that matches the filter.
     * @param {MarketTransactionFindUniqueArgs} args - Arguments to find a MarketTransaction
     * @example
     * // Get one MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketTransactionFindUniqueArgs>(args: SelectSubset<T, MarketTransactionFindUniqueArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketTransactionFindUniqueOrThrowArgs} args - Arguments to find a MarketTransaction
     * @example
     * // Get one MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionFindFirstArgs} args - Arguments to find a MarketTransaction
     * @example
     * // Get one MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketTransactionFindFirstArgs>(args?: SelectSubset<T, MarketTransactionFindFirstArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionFindFirstOrThrowArgs} args - Arguments to find a MarketTransaction
     * @example
     * // Get one MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketTransactions
     * const marketTransactions = await prisma.marketTransaction.findMany()
     * 
     * // Get first 10 MarketTransactions
     * const marketTransactions = await prisma.marketTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketTransactionWithIdOnly = await prisma.marketTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketTransactionFindManyArgs>(args?: SelectSubset<T, MarketTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketTransaction.
     * @param {MarketTransactionCreateArgs} args - Arguments to create a MarketTransaction.
     * @example
     * // Create one MarketTransaction
     * const MarketTransaction = await prisma.marketTransaction.create({
     *   data: {
     *     // ... data to create a MarketTransaction
     *   }
     * })
     * 
     */
    create<T extends MarketTransactionCreateArgs>(args: SelectSubset<T, MarketTransactionCreateArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketTransactions.
     * @param {MarketTransactionCreateManyArgs} args - Arguments to create many MarketTransactions.
     * @example
     * // Create many MarketTransactions
     * const marketTransaction = await prisma.marketTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketTransactionCreateManyArgs>(args?: SelectSubset<T, MarketTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketTransactions and returns the data saved in the database.
     * @param {MarketTransactionCreateManyAndReturnArgs} args - Arguments to create many MarketTransactions.
     * @example
     * // Create many MarketTransactions
     * const marketTransaction = await prisma.marketTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketTransactions and only return the `id`
     * const marketTransactionWithIdOnly = await prisma.marketTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketTransaction.
     * @param {MarketTransactionDeleteArgs} args - Arguments to delete one MarketTransaction.
     * @example
     * // Delete one MarketTransaction
     * const MarketTransaction = await prisma.marketTransaction.delete({
     *   where: {
     *     // ... filter to delete one MarketTransaction
     *   }
     * })
     * 
     */
    delete<T extends MarketTransactionDeleteArgs>(args: SelectSubset<T, MarketTransactionDeleteArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketTransaction.
     * @param {MarketTransactionUpdateArgs} args - Arguments to update one MarketTransaction.
     * @example
     * // Update one MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketTransactionUpdateArgs>(args: SelectSubset<T, MarketTransactionUpdateArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketTransactions.
     * @param {MarketTransactionDeleteManyArgs} args - Arguments to filter MarketTransactions to delete.
     * @example
     * // Delete a few MarketTransactions
     * const { count } = await prisma.marketTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketTransactionDeleteManyArgs>(args?: SelectSubset<T, MarketTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketTransactions
     * const marketTransaction = await prisma.marketTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketTransactionUpdateManyArgs>(args: SelectSubset<T, MarketTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketTransactions and returns the data updated in the database.
     * @param {MarketTransactionUpdateManyAndReturnArgs} args - Arguments to update many MarketTransactions.
     * @example
     * // Update many MarketTransactions
     * const marketTransaction = await prisma.marketTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketTransactions and only return the `id`
     * const marketTransactionWithIdOnly = await prisma.marketTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketTransaction.
     * @param {MarketTransactionUpsertArgs} args - Arguments to update or create a MarketTransaction.
     * @example
     * // Update or create a MarketTransaction
     * const marketTransaction = await prisma.marketTransaction.upsert({
     *   create: {
     *     // ... data to create a MarketTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketTransaction we want to update
     *   }
     * })
     */
    upsert<T extends MarketTransactionUpsertArgs>(args: SelectSubset<T, MarketTransactionUpsertArgs<ExtArgs>>): Prisma__MarketTransactionClient<$Result.GetResult<Prisma.$MarketTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionCountArgs} args - Arguments to filter MarketTransactions to count.
     * @example
     * // Count the number of MarketTransactions
     * const count = await prisma.marketTransaction.count({
     *   where: {
     *     // ... the filter for the MarketTransactions we want to count
     *   }
     * })
    **/
    count<T extends MarketTransactionCountArgs>(
      args?: Subset<T, MarketTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketTransactionAggregateArgs>(args: Subset<T, MarketTransactionAggregateArgs>): Prisma.PrismaPromise<GetMarketTransactionAggregateType<T>>

    /**
     * Group by MarketTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketTransactionGroupByArgs['orderBy'] }
        : { orderBy?: MarketTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketTransaction model
   */
  readonly fields: MarketTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketTransaction model
   */
  interface MarketTransactionFieldRefs {
    readonly id: FieldRef<"MarketTransaction", 'String'>
    readonly listingId: FieldRef<"MarketTransaction", 'String'>
    readonly buyerId: FieldRef<"MarketTransaction", 'String'>
    readonly sellerId: FieldRef<"MarketTransaction", 'String'>
    readonly itemId: FieldRef<"MarketTransaction", 'String'>
    readonly quantity: FieldRef<"MarketTransaction", 'Int'>
    readonly totalPrice: FieldRef<"MarketTransaction", 'Int'>
    readonly createdAt: FieldRef<"MarketTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketTransaction findUnique
   */
  export type MarketTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter, which MarketTransaction to fetch.
     */
    where: MarketTransactionWhereUniqueInput
  }

  /**
   * MarketTransaction findUniqueOrThrow
   */
  export type MarketTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter, which MarketTransaction to fetch.
     */
    where: MarketTransactionWhereUniqueInput
  }

  /**
   * MarketTransaction findFirst
   */
  export type MarketTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter, which MarketTransaction to fetch.
     */
    where?: MarketTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTransactions to fetch.
     */
    orderBy?: MarketTransactionOrderByWithRelationInput | MarketTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTransactions.
     */
    cursor?: MarketTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTransactions.
     */
    distinct?: MarketTransactionScalarFieldEnum | MarketTransactionScalarFieldEnum[]
  }

  /**
   * MarketTransaction findFirstOrThrow
   */
  export type MarketTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter, which MarketTransaction to fetch.
     */
    where?: MarketTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTransactions to fetch.
     */
    orderBy?: MarketTransactionOrderByWithRelationInput | MarketTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTransactions.
     */
    cursor?: MarketTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTransactions.
     */
    distinct?: MarketTransactionScalarFieldEnum | MarketTransactionScalarFieldEnum[]
  }

  /**
   * MarketTransaction findMany
   */
  export type MarketTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter, which MarketTransactions to fetch.
     */
    where?: MarketTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTransactions to fetch.
     */
    orderBy?: MarketTransactionOrderByWithRelationInput | MarketTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketTransactions.
     */
    cursor?: MarketTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTransactions.
     */
    skip?: number
    distinct?: MarketTransactionScalarFieldEnum | MarketTransactionScalarFieldEnum[]
  }

  /**
   * MarketTransaction create
   */
  export type MarketTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketTransaction.
     */
    data: XOR<MarketTransactionCreateInput, MarketTransactionUncheckedCreateInput>
  }

  /**
   * MarketTransaction createMany
   */
  export type MarketTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketTransactions.
     */
    data: MarketTransactionCreateManyInput | MarketTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketTransaction createManyAndReturn
   */
  export type MarketTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many MarketTransactions.
     */
    data: MarketTransactionCreateManyInput | MarketTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketTransaction update
   */
  export type MarketTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketTransaction.
     */
    data: XOR<MarketTransactionUpdateInput, MarketTransactionUncheckedUpdateInput>
    /**
     * Choose, which MarketTransaction to update.
     */
    where: MarketTransactionWhereUniqueInput
  }

  /**
   * MarketTransaction updateMany
   */
  export type MarketTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketTransactions.
     */
    data: XOR<MarketTransactionUpdateManyMutationInput, MarketTransactionUncheckedUpdateManyInput>
    /**
     * Filter which MarketTransactions to update
     */
    where?: MarketTransactionWhereInput
    /**
     * Limit how many MarketTransactions to update.
     */
    limit?: number
  }

  /**
   * MarketTransaction updateManyAndReturn
   */
  export type MarketTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * The data used to update MarketTransactions.
     */
    data: XOR<MarketTransactionUpdateManyMutationInput, MarketTransactionUncheckedUpdateManyInput>
    /**
     * Filter which MarketTransactions to update
     */
    where?: MarketTransactionWhereInput
    /**
     * Limit how many MarketTransactions to update.
     */
    limit?: number
  }

  /**
   * MarketTransaction upsert
   */
  export type MarketTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketTransaction to update in case it exists.
     */
    where: MarketTransactionWhereUniqueInput
    /**
     * In case the MarketTransaction found by the `where` argument doesn't exist, create a new MarketTransaction with this data.
     */
    create: XOR<MarketTransactionCreateInput, MarketTransactionUncheckedCreateInput>
    /**
     * In case the MarketTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketTransactionUpdateInput, MarketTransactionUncheckedUpdateInput>
  }

  /**
   * MarketTransaction delete
   */
  export type MarketTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
    /**
     * Filter which MarketTransaction to delete.
     */
    where: MarketTransactionWhereUniqueInput
  }

  /**
   * MarketTransaction deleteMany
   */
  export type MarketTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTransactions to delete
     */
    where?: MarketTransactionWhereInput
    /**
     * Limit how many MarketTransactions to delete.
     */
    limit?: number
  }

  /**
   * MarketTransaction without action
   */
  export type MarketTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTransaction
     */
    select?: MarketTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTransaction
     */
    omit?: MarketTransactionOmit<ExtArgs> | null
  }


  /**
   * Model Quest
   */

  export type AggregateQuest = {
    _count: QuestCountAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  export type QuestMinAggregateOutputType = {
    id: string | null
    npcId: string | null
    title: string | null
    description: string | null
    questType: $Enums.QuestType | null
    reward: string | null
    requirements: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type QuestMaxAggregateOutputType = {
    id: string | null
    npcId: string | null
    title: string | null
    description: string | null
    questType: $Enums.QuestType | null
    reward: string | null
    requirements: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type QuestCountAggregateOutputType = {
    id: number
    npcId: number
    title: number
    description: number
    questType: number
    reward: number
    requirements: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type QuestMinAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    description?: true
    questType?: true
    reward?: true
    requirements?: true
    isActive?: true
    createdAt?: true
  }

  export type QuestMaxAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    description?: true
    questType?: true
    reward?: true
    requirements?: true
    isActive?: true
    createdAt?: true
  }

  export type QuestCountAggregateInputType = {
    id?: true
    npcId?: true
    title?: true
    description?: true
    questType?: true
    reward?: true
    requirements?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type QuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quest to aggregate.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestMaxAggregateInputType
  }

  export type GetQuestAggregateType<T extends QuestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuest[P]>
      : GetScalarType<T[P], AggregateQuest[P]>
  }




  export type QuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithAggregationInput | QuestOrderByWithAggregationInput[]
    by: QuestScalarFieldEnum[] | QuestScalarFieldEnum
    having?: QuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestCountAggregateInputType | true
    _min?: QuestMinAggregateInputType
    _max?: QuestMaxAggregateInputType
  }

  export type QuestGroupByOutputType = {
    id: string
    npcId: string | null
    title: string
    description: string
    questType: $Enums.QuestType
    reward: string | null
    requirements: string | null
    isActive: boolean
    createdAt: Date
    _count: QuestCountAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  type GetQuestGroupByPayload<T extends QuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestGroupByOutputType[P]>
            : GetScalarType<T[P], QuestGroupByOutputType[P]>
        }
      >
    >


  export type QuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    description?: boolean
    questType?: boolean
    reward?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    description?: boolean
    questType?: boolean
    reward?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    npcId?: boolean
    title?: boolean
    description?: boolean
    questType?: boolean
    reward?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectScalar = {
    id?: boolean
    npcId?: boolean
    title?: boolean
    description?: boolean
    questType?: boolean
    reward?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type QuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "npcId" | "title" | "description" | "questType" | "reward" | "requirements" | "isActive" | "createdAt", ExtArgs["result"]["quest"]>
  export type QuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }
  export type QuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }
  export type QuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | Quest$npcArgs<ExtArgs>
  }

  export type $QuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quest"
    objects: {
      npc: Prisma.$NPCPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      npcId: string | null
      title: string
      description: string
      questType: $Enums.QuestType
      reward: string | null
      requirements: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["quest"]>
    composites: {}
  }

  type QuestGetPayload<S extends boolean | null | undefined | QuestDefaultArgs> = $Result.GetResult<Prisma.$QuestPayload, S>

  type QuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestCountAggregateInputType | true
    }

  export interface QuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quest'], meta: { name: 'Quest' } }
    /**
     * Find zero or one Quest that matches the filter.
     * @param {QuestFindUniqueArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestFindUniqueArgs>(args: SelectSubset<T, QuestFindUniqueArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestFindUniqueOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestFindFirstArgs>(args?: SelectSubset<T, QuestFindFirstArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quest.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questWithIdOnly = await prisma.quest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestFindManyArgs>(args?: SelectSubset<T, QuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quest.
     * @param {QuestCreateArgs} args - Arguments to create a Quest.
     * @example
     * // Create one Quest
     * const Quest = await prisma.quest.create({
     *   data: {
     *     // ... data to create a Quest
     *   }
     * })
     * 
     */
    create<T extends QuestCreateArgs>(args: SelectSubset<T, QuestCreateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quests.
     * @param {QuestCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestCreateManyArgs>(args?: SelectSubset<T, QuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quests and returns the data saved in the database.
     * @param {QuestCreateManyAndReturnArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quest.
     * @param {QuestDeleteArgs} args - Arguments to delete one Quest.
     * @example
     * // Delete one Quest
     * const Quest = await prisma.quest.delete({
     *   where: {
     *     // ... filter to delete one Quest
     *   }
     * })
     * 
     */
    delete<T extends QuestDeleteArgs>(args: SelectSubset<T, QuestDeleteArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quest.
     * @param {QuestUpdateArgs} args - Arguments to update one Quest.
     * @example
     * // Update one Quest
     * const quest = await prisma.quest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestUpdateArgs>(args: SelectSubset<T, QuestUpdateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quests.
     * @param {QuestDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestDeleteManyArgs>(args?: SelectSubset<T, QuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestUpdateManyArgs>(args: SelectSubset<T, QuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests and returns the data updated in the database.
     * @param {QuestUpdateManyAndReturnArgs} args - Arguments to update many Quests.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quest.
     * @param {QuestUpsertArgs} args - Arguments to update or create a Quest.
     * @example
     * // Update or create a Quest
     * const quest = await prisma.quest.upsert({
     *   create: {
     *     // ... data to create a Quest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quest we want to update
     *   }
     * })
     */
    upsert<T extends QuestUpsertArgs>(args: SelectSubset<T, QuestUpsertArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quest.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestCountArgs>(
      args?: Subset<T, QuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestAggregateArgs>(args: Subset<T, QuestAggregateArgs>): Prisma.PrismaPromise<GetQuestAggregateType<T>>

    /**
     * Group by Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestGroupByArgs['orderBy'] }
        : { orderBy?: QuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quest model
   */
  readonly fields: QuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npc<T extends Quest$npcArgs<ExtArgs> = {}>(args?: Subset<T, Quest$npcArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quest model
   */
  interface QuestFieldRefs {
    readonly id: FieldRef<"Quest", 'String'>
    readonly npcId: FieldRef<"Quest", 'String'>
    readonly title: FieldRef<"Quest", 'String'>
    readonly description: FieldRef<"Quest", 'String'>
    readonly questType: FieldRef<"Quest", 'QuestType'>
    readonly reward: FieldRef<"Quest", 'String'>
    readonly requirements: FieldRef<"Quest", 'String'>
    readonly isActive: FieldRef<"Quest", 'Boolean'>
    readonly createdAt: FieldRef<"Quest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quest findUnique
   */
  export type QuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findUniqueOrThrow
   */
  export type QuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findFirst
   */
  export type QuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findFirstOrThrow
   */
  export type QuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findMany
   */
  export type QuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest create
   */
  export type QuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Quest.
     */
    data: XOR<QuestCreateInput, QuestUncheckedCreateInput>
  }

  /**
   * Quest createMany
   */
  export type QuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quest createManyAndReturn
   */
  export type QuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest update
   */
  export type QuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Quest.
     */
    data: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
    /**
     * Choose, which Quest to update.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest updateMany
   */
  export type QuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
  }

  /**
   * Quest updateManyAndReturn
   */
  export type QuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest upsert
   */
  export type QuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Quest to update in case it exists.
     */
    where: QuestWhereUniqueInput
    /**
     * In case the Quest found by the `where` argument doesn't exist, create a new Quest with this data.
     */
    create: XOR<QuestCreateInput, QuestUncheckedCreateInput>
    /**
     * In case the Quest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
  }

  /**
   * Quest delete
   */
  export type QuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter which Quest to delete.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest deleteMany
   */
  export type QuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to delete.
     */
    limit?: number
  }

  /**
   * Quest.npc
   */
  export type Quest$npcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
  }

  /**
   * Quest without action
   */
  export type QuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PostScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    refresh_token_expires_in: 'refresh_token_expires_in'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    characterName: 'characterName',
    level: 'level',
    experience: 'experience',
    gold: 'gold',
    deathCount: 'deathCount',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const PlayerStatsScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    vitality: 'vitality',
    strength: 'strength',
    speed: 'speed',
    dexterity: 'dexterity',
    maxHP: 'maxHP',
    currentHP: 'currentHP',
    maxSP: 'maxSP',
    currentSP: 'currentSP',
    statPoints: 'statPoints',
    updatedAt: 'updatedAt'
  };

  export type PlayerStatsScalarFieldEnum = (typeof PlayerStatsScalarFieldEnum)[keyof typeof PlayerStatsScalarFieldEnum]


  export const MapTileScalarFieldEnum: {
    id: 'id',
    x: 'x',
    y: 'y',
    tileType: 'tileType',
    zoneType: 'zoneType',
    isSafeZone: 'isSafeZone',
    hasResource: 'hasResource',
    resourceType: 'resourceType',
    description: 'description'
  };

  export type MapTileScalarFieldEnum = (typeof MapTileScalarFieldEnum)[keyof typeof MapTileScalarFieldEnum]


  export const MapPositionScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    tileX: 'tileX',
    tileY: 'tileY',
    tileId: 'tileId',
    updatedAt: 'updatedAt'
  };

  export type MapPositionScalarFieldEnum = (typeof MapPositionScalarFieldEnum)[keyof typeof MapPositionScalarFieldEnum]


  export const NPCScalarFieldEnum: {
    id: 'id',
    name: 'name',
    npcType: 'npcType',
    tileX: 'tileX',
    tileY: 'tileY',
    tileId: 'tileId',
    dialogue: 'dialogue',
    createdAt: 'createdAt'
  };

  export type NPCScalarFieldEnum = (typeof NPCScalarFieldEnum)[keyof typeof NPCScalarFieldEnum]


  export const ShopItemScalarFieldEnum: {
    id: 'id',
    npcId: 'npcId',
    itemId: 'itemId',
    price: 'price',
    stock: 'stock',
    createdAt: 'createdAt'
  };

  export type ShopItemScalarFieldEnum = (typeof ShopItemScalarFieldEnum)[keyof typeof ShopItemScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    itemType: 'itemType',
    itemRarity: 'itemRarity',
    tier: 'tier',
    value: 'value',
    stackable: 'stackable',
    maxStack: 'maxStack',
    equipmentSlot: 'equipmentSlot',
    vitalityBonus: 'vitalityBonus',
    strengthBonus: 'strengthBonus',
    speedBonus: 'speedBonus',
    dexterityBonus: 'dexterityBonus',
    hpBonus: 'hpBonus',
    spBonus: 'spBonus',
    createdAt: 'createdAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    itemId: 'itemId',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    weaponId: 'weaponId',
    headId: 'headId',
    chestId: 'chestId',
    legsId: 'legsId',
    feetId: 'feetId',
    accessory1Id: 'accessory1Id',
    accessory2Id: 'accessory2Id',
    updatedAt: 'updatedAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const OccupationScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    primaryJob: 'primaryJob',
    secondaryJob: 'secondaryJob',
    level: 'level',
    experience: 'experience',
    updatedAt: 'updatedAt'
  };

  export type OccupationScalarFieldEnum = (typeof OccupationScalarFieldEnum)[keyof typeof OccupationScalarFieldEnum]


  export const PlayerSkillScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    skillName: 'skillName',
    level: 'level',
    experience: 'experience',
    createdAt: 'createdAt'
  };

  export type PlayerSkillScalarFieldEnum = (typeof PlayerSkillScalarFieldEnum)[keyof typeof PlayerSkillScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    tileX: 'tileX',
    tileY: 'tileY',
    tileId: 'tileId',
    enemyType: 'enemyType',
    enemyLevel: 'enemyLevel',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const CombatLogScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    encounterId: 'encounterId',
    turnNumber: 'turnNumber',
    action: 'action',
    result: 'result',
    createdAt: 'createdAt'
  };

  export type CombatLogScalarFieldEnum = (typeof CombatLogScalarFieldEnum)[keyof typeof CombatLogScalarFieldEnum]


  export const DeathLogScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    deathCount: 'deathCount',
    cause: 'cause',
    locationX: 'locationX',
    locationY: 'locationY',
    createdAt: 'createdAt'
  };

  export type DeathLogScalarFieldEnum = (typeof DeathLogScalarFieldEnum)[keyof typeof DeathLogScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    level: 'level',
    gold: 'gold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const GuildMemberScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    guildId: 'guildId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type GuildMemberScalarFieldEnum = (typeof GuildMemberScalarFieldEnum)[keyof typeof GuildMemberScalarFieldEnum]


  export const GuildBankScalarFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    gold: 'gold',
    updatedAt: 'updatedAt'
  };

  export type GuildBankScalarFieldEnum = (typeof GuildBankScalarFieldEnum)[keyof typeof GuildBankScalarFieldEnum]


  export const GuildQuestScalarFieldEnum: {
    id: 'id',
    guildId: 'guildId',
    title: 'title',
    description: 'description',
    reward: 'reward',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type GuildQuestScalarFieldEnum = (typeof GuildQuestScalarFieldEnum)[keyof typeof GuildQuestScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    gold: 'gold',
    vaultLevel: 'vaultLevel',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const BankVaultItemScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    itemId: 'itemId',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type BankVaultItemScalarFieldEnum = (typeof BankVaultItemScalarFieldEnum)[keyof typeof BankVaultItemScalarFieldEnum]


  export const MarketListingScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    itemId: 'itemId',
    quantity: 'quantity',
    pricePerUnit: 'pricePerUnit',
    totalPrice: 'totalPrice',
    listingTax: 'listingTax',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    soldAt: 'soldAt'
  };

  export type MarketListingScalarFieldEnum = (typeof MarketListingScalarFieldEnum)[keyof typeof MarketListingScalarFieldEnum]


  export const MarketTransactionScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    itemId: 'itemId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt'
  };

  export type MarketTransactionScalarFieldEnum = (typeof MarketTransactionScalarFieldEnum)[keyof typeof MarketTransactionScalarFieldEnum]


  export const QuestScalarFieldEnum: {
    id: 'id',
    npcId: 'npcId',
    title: 'title',
    description: 'description',
    questType: 'questType',
    reward: 'reward',
    requirements: 'requirements',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type QuestScalarFieldEnum = (typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TileType'
   */
  export type EnumTileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TileType'>
    


  /**
   * Reference to a field of type 'TileType[]'
   */
  export type ListEnumTileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TileType[]'>
    


  /**
   * Reference to a field of type 'ZoneType'
   */
  export type EnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType'>
    


  /**
   * Reference to a field of type 'ZoneType[]'
   */
  export type ListEnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'NPCType'
   */
  export type EnumNPCTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NPCType'>
    


  /**
   * Reference to a field of type 'NPCType[]'
   */
  export type ListEnumNPCTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NPCType[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'ItemRarity'
   */
  export type EnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity'>
    


  /**
   * Reference to a field of type 'ItemRarity[]'
   */
  export type ListEnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity[]'>
    


  /**
   * Reference to a field of type 'EquipmentSlot'
   */
  export type EnumEquipmentSlotFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentSlot'>
    


  /**
   * Reference to a field of type 'EquipmentSlot[]'
   */
  export type ListEnumEquipmentSlotFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentSlot[]'>
    


  /**
   * Reference to a field of type 'PrimaryOccupation'
   */
  export type EnumPrimaryOccupationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrimaryOccupation'>
    


  /**
   * Reference to a field of type 'PrimaryOccupation[]'
   */
  export type ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrimaryOccupation[]'>
    


  /**
   * Reference to a field of type 'SecondaryOccupation'
   */
  export type EnumSecondaryOccupationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecondaryOccupation'>
    


  /**
   * Reference to a field of type 'SecondaryOccupation[]'
   */
  export type ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecondaryOccupation[]'>
    


  /**
   * Reference to a field of type 'GuildRole'
   */
  export type EnumGuildRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuildRole'>
    


  /**
   * Reference to a field of type 'GuildRole[]'
   */
  export type ListEnumGuildRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuildRole[]'>
    


  /**
   * Reference to a field of type 'QuestType'
   */
  export type EnumQuestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestType'>
    


  /**
   * Reference to a field of type 'QuestType[]'
   */
  export type ListEnumQuestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    name?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    createdById?: StringWithAggregatesFilter<"Post"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    player?: PlayerOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    userId?: StringFilter<"Player"> | string
    characterName?: StringFilter<"Player"> | string
    level?: IntFilter<"Player"> | number
    experience?: IntFilter<"Player"> | number
    gold?: IntFilter<"Player"> | number
    deathCount?: IntFilter<"Player"> | number
    isDeleted?: BoolFilter<"Player"> | boolean
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stats?: XOR<PlayerStatsNullableScalarRelationFilter, PlayerStatsWhereInput> | null
    position?: XOR<MapPositionNullableScalarRelationFilter, MapPositionWhereInput> | null
    inventory?: InventoryItemListRelationFilter
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    occupation?: XOR<OccupationNullableScalarRelationFilter, OccupationWhereInput> | null
    guildMember?: XOR<GuildMemberNullableScalarRelationFilter, GuildMemberWhereInput> | null
    bankAccount?: XOR<BankAccountNullableScalarRelationFilter, BankAccountWhereInput> | null
    marketListings?: MarketListingListRelationFilter
    combatLogs?: CombatLogListRelationFilter
    deathLogs?: DeathLogListRelationFilter
    skills?: PlayerSkillListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    stats?: PlayerStatsOrderByWithRelationInput
    position?: MapPositionOrderByWithRelationInput
    inventory?: InventoryItemOrderByRelationAggregateInput
    equipment?: EquipmentOrderByWithRelationInput
    occupation?: OccupationOrderByWithRelationInput
    guildMember?: GuildMemberOrderByWithRelationInput
    bankAccount?: BankAccountOrderByWithRelationInput
    marketListings?: MarketListingOrderByRelationAggregateInput
    combatLogs?: CombatLogOrderByRelationAggregateInput
    deathLogs?: DeathLogOrderByRelationAggregateInput
    skills?: PlayerSkillOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    characterName?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    level?: IntFilter<"Player"> | number
    experience?: IntFilter<"Player"> | number
    gold?: IntFilter<"Player"> | number
    deathCount?: IntFilter<"Player"> | number
    isDeleted?: BoolFilter<"Player"> | boolean
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stats?: XOR<PlayerStatsNullableScalarRelationFilter, PlayerStatsWhereInput> | null
    position?: XOR<MapPositionNullableScalarRelationFilter, MapPositionWhereInput> | null
    inventory?: InventoryItemListRelationFilter
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    occupation?: XOR<OccupationNullableScalarRelationFilter, OccupationWhereInput> | null
    guildMember?: XOR<GuildMemberNullableScalarRelationFilter, GuildMemberWhereInput> | null
    bankAccount?: XOR<BankAccountNullableScalarRelationFilter, BankAccountWhereInput> | null
    marketListings?: MarketListingListRelationFilter
    combatLogs?: CombatLogListRelationFilter
    deathLogs?: DeathLogListRelationFilter
    skills?: PlayerSkillListRelationFilter
  }, "id" | "userId" | "characterName">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    userId?: StringWithAggregatesFilter<"Player"> | string
    characterName?: StringWithAggregatesFilter<"Player"> | string
    level?: IntWithAggregatesFilter<"Player"> | number
    experience?: IntWithAggregatesFilter<"Player"> | number
    gold?: IntWithAggregatesFilter<"Player"> | number
    deathCount?: IntWithAggregatesFilter<"Player"> | number
    isDeleted?: BoolWithAggregatesFilter<"Player"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type PlayerStatsWhereInput = {
    AND?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    OR?: PlayerStatsWhereInput[]
    NOT?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    id?: StringFilter<"PlayerStats"> | string
    playerId?: StringFilter<"PlayerStats"> | string
    vitality?: IntFilter<"PlayerStats"> | number
    strength?: IntFilter<"PlayerStats"> | number
    speed?: IntFilter<"PlayerStats"> | number
    dexterity?: IntFilter<"PlayerStats"> | number
    maxHP?: IntFilter<"PlayerStats"> | number
    currentHP?: IntFilter<"PlayerStats"> | number
    maxSP?: IntFilter<"PlayerStats"> | number
    currentSP?: IntFilter<"PlayerStats"> | number
    statPoints?: IntFilter<"PlayerStats"> | number
    updatedAt?: DateTimeFilter<"PlayerStats"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type PlayerStatsOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type PlayerStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    OR?: PlayerStatsWhereInput[]
    NOT?: PlayerStatsWhereInput | PlayerStatsWhereInput[]
    vitality?: IntFilter<"PlayerStats"> | number
    strength?: IntFilter<"PlayerStats"> | number
    speed?: IntFilter<"PlayerStats"> | number
    dexterity?: IntFilter<"PlayerStats"> | number
    maxHP?: IntFilter<"PlayerStats"> | number
    currentHP?: IntFilter<"PlayerStats"> | number
    maxSP?: IntFilter<"PlayerStats"> | number
    currentSP?: IntFilter<"PlayerStats"> | number
    statPoints?: IntFilter<"PlayerStats"> | number
    updatedAt?: DateTimeFilter<"PlayerStats"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId">

  export type PlayerStatsOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerStatsCountOrderByAggregateInput
    _avg?: PlayerStatsAvgOrderByAggregateInput
    _max?: PlayerStatsMaxOrderByAggregateInput
    _min?: PlayerStatsMinOrderByAggregateInput
    _sum?: PlayerStatsSumOrderByAggregateInput
  }

  export type PlayerStatsScalarWhereWithAggregatesInput = {
    AND?: PlayerStatsScalarWhereWithAggregatesInput | PlayerStatsScalarWhereWithAggregatesInput[]
    OR?: PlayerStatsScalarWhereWithAggregatesInput[]
    NOT?: PlayerStatsScalarWhereWithAggregatesInput | PlayerStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerStats"> | string
    playerId?: StringWithAggregatesFilter<"PlayerStats"> | string
    vitality?: IntWithAggregatesFilter<"PlayerStats"> | number
    strength?: IntWithAggregatesFilter<"PlayerStats"> | number
    speed?: IntWithAggregatesFilter<"PlayerStats"> | number
    dexterity?: IntWithAggregatesFilter<"PlayerStats"> | number
    maxHP?: IntWithAggregatesFilter<"PlayerStats"> | number
    currentHP?: IntWithAggregatesFilter<"PlayerStats"> | number
    maxSP?: IntWithAggregatesFilter<"PlayerStats"> | number
    currentSP?: IntWithAggregatesFilter<"PlayerStats"> | number
    statPoints?: IntWithAggregatesFilter<"PlayerStats"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerStats"> | Date | string
  }

  export type MapTileWhereInput = {
    AND?: MapTileWhereInput | MapTileWhereInput[]
    OR?: MapTileWhereInput[]
    NOT?: MapTileWhereInput | MapTileWhereInput[]
    id?: IntFilter<"MapTile"> | number
    x?: IntFilter<"MapTile"> | number
    y?: IntFilter<"MapTile"> | number
    tileType?: EnumTileTypeFilter<"MapTile"> | $Enums.TileType
    zoneType?: EnumZoneTypeFilter<"MapTile"> | $Enums.ZoneType
    isSafeZone?: BoolFilter<"MapTile"> | boolean
    hasResource?: BoolFilter<"MapTile"> | boolean
    resourceType?: EnumResourceTypeNullableFilter<"MapTile"> | $Enums.ResourceType | null
    description?: StringNullableFilter<"MapTile"> | string | null
    positions?: MapPositionListRelationFilter
    npcs?: NPCListRelationFilter
    encounters?: EncounterListRelationFilter
  }

  export type MapTileOrderByWithRelationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    tileType?: SortOrder
    zoneType?: SortOrder
    isSafeZone?: SortOrder
    hasResource?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    positions?: MapPositionOrderByRelationAggregateInput
    npcs?: NPCOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
  }

  export type MapTileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    x_y?: MapTileXYCompoundUniqueInput
    AND?: MapTileWhereInput | MapTileWhereInput[]
    OR?: MapTileWhereInput[]
    NOT?: MapTileWhereInput | MapTileWhereInput[]
    x?: IntFilter<"MapTile"> | number
    y?: IntFilter<"MapTile"> | number
    tileType?: EnumTileTypeFilter<"MapTile"> | $Enums.TileType
    zoneType?: EnumZoneTypeFilter<"MapTile"> | $Enums.ZoneType
    isSafeZone?: BoolFilter<"MapTile"> | boolean
    hasResource?: BoolFilter<"MapTile"> | boolean
    resourceType?: EnumResourceTypeNullableFilter<"MapTile"> | $Enums.ResourceType | null
    description?: StringNullableFilter<"MapTile"> | string | null
    positions?: MapPositionListRelationFilter
    npcs?: NPCListRelationFilter
    encounters?: EncounterListRelationFilter
  }, "id" | "x_y">

  export type MapTileOrderByWithAggregationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    tileType?: SortOrder
    zoneType?: SortOrder
    isSafeZone?: SortOrder
    hasResource?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: MapTileCountOrderByAggregateInput
    _avg?: MapTileAvgOrderByAggregateInput
    _max?: MapTileMaxOrderByAggregateInput
    _min?: MapTileMinOrderByAggregateInput
    _sum?: MapTileSumOrderByAggregateInput
  }

  export type MapTileScalarWhereWithAggregatesInput = {
    AND?: MapTileScalarWhereWithAggregatesInput | MapTileScalarWhereWithAggregatesInput[]
    OR?: MapTileScalarWhereWithAggregatesInput[]
    NOT?: MapTileScalarWhereWithAggregatesInput | MapTileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MapTile"> | number
    x?: IntWithAggregatesFilter<"MapTile"> | number
    y?: IntWithAggregatesFilter<"MapTile"> | number
    tileType?: EnumTileTypeWithAggregatesFilter<"MapTile"> | $Enums.TileType
    zoneType?: EnumZoneTypeWithAggregatesFilter<"MapTile"> | $Enums.ZoneType
    isSafeZone?: BoolWithAggregatesFilter<"MapTile"> | boolean
    hasResource?: BoolWithAggregatesFilter<"MapTile"> | boolean
    resourceType?: EnumResourceTypeNullableWithAggregatesFilter<"MapTile"> | $Enums.ResourceType | null
    description?: StringNullableWithAggregatesFilter<"MapTile"> | string | null
  }

  export type MapPositionWhereInput = {
    AND?: MapPositionWhereInput | MapPositionWhereInput[]
    OR?: MapPositionWhereInput[]
    NOT?: MapPositionWhereInput | MapPositionWhereInput[]
    id?: StringFilter<"MapPosition"> | string
    playerId?: StringFilter<"MapPosition"> | string
    tileX?: IntFilter<"MapPosition"> | number
    tileY?: IntFilter<"MapPosition"> | number
    tileId?: IntNullableFilter<"MapPosition"> | number | null
    updatedAt?: DateTimeFilter<"MapPosition"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
  }

  export type MapPositionOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    tile?: MapTileOrderByWithRelationInput
  }

  export type MapPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: MapPositionWhereInput | MapPositionWhereInput[]
    OR?: MapPositionWhereInput[]
    NOT?: MapPositionWhereInput | MapPositionWhereInput[]
    tileX?: IntFilter<"MapPosition"> | number
    tileY?: IntFilter<"MapPosition"> | number
    tileId?: IntNullableFilter<"MapPosition"> | number | null
    updatedAt?: DateTimeFilter<"MapPosition"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
  }, "id" | "playerId">

  export type MapPositionOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: MapPositionCountOrderByAggregateInput
    _avg?: MapPositionAvgOrderByAggregateInput
    _max?: MapPositionMaxOrderByAggregateInput
    _min?: MapPositionMinOrderByAggregateInput
    _sum?: MapPositionSumOrderByAggregateInput
  }

  export type MapPositionScalarWhereWithAggregatesInput = {
    AND?: MapPositionScalarWhereWithAggregatesInput | MapPositionScalarWhereWithAggregatesInput[]
    OR?: MapPositionScalarWhereWithAggregatesInput[]
    NOT?: MapPositionScalarWhereWithAggregatesInput | MapPositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MapPosition"> | string
    playerId?: StringWithAggregatesFilter<"MapPosition"> | string
    tileX?: IntWithAggregatesFilter<"MapPosition"> | number
    tileY?: IntWithAggregatesFilter<"MapPosition"> | number
    tileId?: IntNullableWithAggregatesFilter<"MapPosition"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"MapPosition"> | Date | string
  }

  export type NPCWhereInput = {
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    id?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    npcType?: EnumNPCTypeFilter<"NPC"> | $Enums.NPCType
    tileX?: IntFilter<"NPC"> | number
    tileY?: IntFilter<"NPC"> | number
    tileId?: IntNullableFilter<"NPC"> | number | null
    dialogue?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
    shopItems?: ShopItemListRelationFilter
    quests?: QuestListRelationFilter
  }

  export type NPCOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    npcType?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    dialogue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tile?: MapTileOrderByWithRelationInput
    shopItems?: ShopItemOrderByRelationAggregateInput
    quests?: QuestOrderByRelationAggregateInput
  }

  export type NPCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    name?: StringFilter<"NPC"> | string
    npcType?: EnumNPCTypeFilter<"NPC"> | $Enums.NPCType
    tileX?: IntFilter<"NPC"> | number
    tileY?: IntFilter<"NPC"> | number
    tileId?: IntNullableFilter<"NPC"> | number | null
    dialogue?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
    shopItems?: ShopItemListRelationFilter
    quests?: QuestListRelationFilter
  }, "id">

  export type NPCOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    npcType?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    dialogue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NPCCountOrderByAggregateInput
    _avg?: NPCAvgOrderByAggregateInput
    _max?: NPCMaxOrderByAggregateInput
    _min?: NPCMinOrderByAggregateInput
    _sum?: NPCSumOrderByAggregateInput
  }

  export type NPCScalarWhereWithAggregatesInput = {
    AND?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    OR?: NPCScalarWhereWithAggregatesInput[]
    NOT?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NPC"> | string
    name?: StringWithAggregatesFilter<"NPC"> | string
    npcType?: EnumNPCTypeWithAggregatesFilter<"NPC"> | $Enums.NPCType
    tileX?: IntWithAggregatesFilter<"NPC"> | number
    tileY?: IntWithAggregatesFilter<"NPC"> | number
    tileId?: IntNullableWithAggregatesFilter<"NPC"> | number | null
    dialogue?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NPC"> | Date | string
  }

  export type ShopItemWhereInput = {
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    npcId?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    price?: IntFilter<"ShopItem"> | number
    stock?: IntNullableFilter<"ShopItem"> | number | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ShopItemOrderByWithRelationInput = {
    id?: SortOrder
    npcId?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    npc?: NPCOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ShopItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopItemWhereInput | ShopItemWhereInput[]
    OR?: ShopItemWhereInput[]
    NOT?: ShopItemWhereInput | ShopItemWhereInput[]
    npcId?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    price?: IntFilter<"ShopItem"> | number
    stock?: IntNullableFilter<"ShopItem"> | number | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type ShopItemOrderByWithAggregationInput = {
    id?: SortOrder
    npcId?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShopItemCountOrderByAggregateInput
    _avg?: ShopItemAvgOrderByAggregateInput
    _max?: ShopItemMaxOrderByAggregateInput
    _min?: ShopItemMinOrderByAggregateInput
    _sum?: ShopItemSumOrderByAggregateInput
  }

  export type ShopItemScalarWhereWithAggregatesInput = {
    AND?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    OR?: ShopItemScalarWhereWithAggregatesInput[]
    NOT?: ShopItemScalarWhereWithAggregatesInput | ShopItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopItem"> | string
    npcId?: StringWithAggregatesFilter<"ShopItem"> | string
    itemId?: StringWithAggregatesFilter<"ShopItem"> | string
    price?: IntWithAggregatesFilter<"ShopItem"> | number
    stock?: IntNullableWithAggregatesFilter<"ShopItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopItem"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    itemType?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    itemRarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    tier?: IntFilter<"Item"> | number
    value?: IntFilter<"Item"> | number
    stackable?: BoolFilter<"Item"> | boolean
    maxStack?: IntFilter<"Item"> | number
    equipmentSlot?: EnumEquipmentSlotNullableFilter<"Item"> | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFilter<"Item"> | number
    strengthBonus?: IntFilter<"Item"> | number
    speedBonus?: IntFilter<"Item"> | number
    dexterityBonus?: IntFilter<"Item"> | number
    hpBonus?: IntFilter<"Item"> | number
    spBonus?: IntFilter<"Item"> | number
    createdAt?: DateTimeFilter<"Item"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    shopItems?: ShopItemListRelationFilter
    marketListings?: MarketListingListRelationFilter
    equippedAsWeapon?: EquipmentListRelationFilter
    equippedAsHead?: EquipmentListRelationFilter
    equippedAsChest?: EquipmentListRelationFilter
    equippedAsLegs?: EquipmentListRelationFilter
    equippedAsFeet?: EquipmentListRelationFilter
    equippedAsAccessory1?: EquipmentListRelationFilter
    equippedAsAccessory2?: EquipmentListRelationFilter
    bankVaultItems?: BankVaultItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    itemType?: SortOrder
    itemRarity?: SortOrder
    tier?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    maxStack?: SortOrder
    equipmentSlot?: SortOrderInput | SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
    createdAt?: SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    shopItems?: ShopItemOrderByRelationAggregateInput
    marketListings?: MarketListingOrderByRelationAggregateInput
    equippedAsWeapon?: EquipmentOrderByRelationAggregateInput
    equippedAsHead?: EquipmentOrderByRelationAggregateInput
    equippedAsChest?: EquipmentOrderByRelationAggregateInput
    equippedAsLegs?: EquipmentOrderByRelationAggregateInput
    equippedAsFeet?: EquipmentOrderByRelationAggregateInput
    equippedAsAccessory1?: EquipmentOrderByRelationAggregateInput
    equippedAsAccessory2?: EquipmentOrderByRelationAggregateInput
    bankVaultItems?: BankVaultItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    itemType?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    itemRarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    tier?: IntFilter<"Item"> | number
    value?: IntFilter<"Item"> | number
    stackable?: BoolFilter<"Item"> | boolean
    maxStack?: IntFilter<"Item"> | number
    equipmentSlot?: EnumEquipmentSlotNullableFilter<"Item"> | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFilter<"Item"> | number
    strengthBonus?: IntFilter<"Item"> | number
    speedBonus?: IntFilter<"Item"> | number
    dexterityBonus?: IntFilter<"Item"> | number
    hpBonus?: IntFilter<"Item"> | number
    spBonus?: IntFilter<"Item"> | number
    createdAt?: DateTimeFilter<"Item"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    shopItems?: ShopItemListRelationFilter
    marketListings?: MarketListingListRelationFilter
    equippedAsWeapon?: EquipmentListRelationFilter
    equippedAsHead?: EquipmentListRelationFilter
    equippedAsChest?: EquipmentListRelationFilter
    equippedAsLegs?: EquipmentListRelationFilter
    equippedAsFeet?: EquipmentListRelationFilter
    equippedAsAccessory1?: EquipmentListRelationFilter
    equippedAsAccessory2?: EquipmentListRelationFilter
    bankVaultItems?: BankVaultItemListRelationFilter
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    itemType?: SortOrder
    itemRarity?: SortOrder
    tier?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    maxStack?: SortOrder
    equipmentSlot?: SortOrderInput | SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
    createdAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    itemType?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    itemRarity?: EnumItemRarityWithAggregatesFilter<"Item"> | $Enums.ItemRarity
    tier?: IntWithAggregatesFilter<"Item"> | number
    value?: IntWithAggregatesFilter<"Item"> | number
    stackable?: BoolWithAggregatesFilter<"Item"> | boolean
    maxStack?: IntWithAggregatesFilter<"Item"> | number
    equipmentSlot?: EnumEquipmentSlotNullableWithAggregatesFilter<"Item"> | $Enums.EquipmentSlot | null
    vitalityBonus?: IntWithAggregatesFilter<"Item"> | number
    strengthBonus?: IntWithAggregatesFilter<"Item"> | number
    speedBonus?: IntWithAggregatesFilter<"Item"> | number
    dexterityBonus?: IntWithAggregatesFilter<"Item"> | number
    hpBonus?: IntWithAggregatesFilter<"Item"> | number
    spBonus?: IntWithAggregatesFilter<"Item"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    playerId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    playerId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    playerId?: StringWithAggregatesFilter<"InventoryItem"> | string
    itemId?: StringWithAggregatesFilter<"InventoryItem"> | string
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    playerId?: StringFilter<"Equipment"> | string
    weaponId?: StringNullableFilter<"Equipment"> | string | null
    headId?: StringNullableFilter<"Equipment"> | string | null
    chestId?: StringNullableFilter<"Equipment"> | string | null
    legsId?: StringNullableFilter<"Equipment"> | string | null
    feetId?: StringNullableFilter<"Equipment"> | string | null
    accessory1Id?: StringNullableFilter<"Equipment"> | string | null
    accessory2Id?: StringNullableFilter<"Equipment"> | string | null
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    weapon?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    head?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    chest?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    legs?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    feet?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    accessory1?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    accessory2?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    weaponId?: SortOrderInput | SortOrder
    headId?: SortOrderInput | SortOrder
    chestId?: SortOrderInput | SortOrder
    legsId?: SortOrderInput | SortOrder
    feetId?: SortOrderInput | SortOrder
    accessory1Id?: SortOrderInput | SortOrder
    accessory2Id?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    weapon?: ItemOrderByWithRelationInput
    head?: ItemOrderByWithRelationInput
    chest?: ItemOrderByWithRelationInput
    legs?: ItemOrderByWithRelationInput
    feet?: ItemOrderByWithRelationInput
    accessory1?: ItemOrderByWithRelationInput
    accessory2?: ItemOrderByWithRelationInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    weaponId?: StringNullableFilter<"Equipment"> | string | null
    headId?: StringNullableFilter<"Equipment"> | string | null
    chestId?: StringNullableFilter<"Equipment"> | string | null
    legsId?: StringNullableFilter<"Equipment"> | string | null
    feetId?: StringNullableFilter<"Equipment"> | string | null
    accessory1Id?: StringNullableFilter<"Equipment"> | string | null
    accessory2Id?: StringNullableFilter<"Equipment"> | string | null
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    weapon?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    head?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    chest?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    legs?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    feet?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    accessory1?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
    accessory2?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }, "id" | "playerId">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    weaponId?: SortOrderInput | SortOrder
    headId?: SortOrderInput | SortOrder
    chestId?: SortOrderInput | SortOrder
    legsId?: SortOrderInput | SortOrder
    feetId?: SortOrderInput | SortOrder
    accessory1Id?: SortOrderInput | SortOrder
    accessory2Id?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    playerId?: StringWithAggregatesFilter<"Equipment"> | string
    weaponId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    headId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    chestId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    legsId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    feetId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    accessory1Id?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    accessory2Id?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type OccupationWhereInput = {
    AND?: OccupationWhereInput | OccupationWhereInput[]
    OR?: OccupationWhereInput[]
    NOT?: OccupationWhereInput | OccupationWhereInput[]
    id?: StringFilter<"Occupation"> | string
    playerId?: StringFilter<"Occupation"> | string
    primaryJob?: EnumPrimaryOccupationNullableFilter<"Occupation"> | $Enums.PrimaryOccupation | null
    secondaryJob?: EnumSecondaryOccupationNullableFilter<"Occupation"> | $Enums.SecondaryOccupation | null
    level?: IntFilter<"Occupation"> | number
    experience?: IntFilter<"Occupation"> | number
    updatedAt?: DateTimeFilter<"Occupation"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type OccupationOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    primaryJob?: SortOrderInput | SortOrder
    secondaryJob?: SortOrderInput | SortOrder
    level?: SortOrder
    experience?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type OccupationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: OccupationWhereInput | OccupationWhereInput[]
    OR?: OccupationWhereInput[]
    NOT?: OccupationWhereInput | OccupationWhereInput[]
    primaryJob?: EnumPrimaryOccupationNullableFilter<"Occupation"> | $Enums.PrimaryOccupation | null
    secondaryJob?: EnumSecondaryOccupationNullableFilter<"Occupation"> | $Enums.SecondaryOccupation | null
    level?: IntFilter<"Occupation"> | number
    experience?: IntFilter<"Occupation"> | number
    updatedAt?: DateTimeFilter<"Occupation"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId">

  export type OccupationOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    primaryJob?: SortOrderInput | SortOrder
    secondaryJob?: SortOrderInput | SortOrder
    level?: SortOrder
    experience?: SortOrder
    updatedAt?: SortOrder
    _count?: OccupationCountOrderByAggregateInput
    _avg?: OccupationAvgOrderByAggregateInput
    _max?: OccupationMaxOrderByAggregateInput
    _min?: OccupationMinOrderByAggregateInput
    _sum?: OccupationSumOrderByAggregateInput
  }

  export type OccupationScalarWhereWithAggregatesInput = {
    AND?: OccupationScalarWhereWithAggregatesInput | OccupationScalarWhereWithAggregatesInput[]
    OR?: OccupationScalarWhereWithAggregatesInput[]
    NOT?: OccupationScalarWhereWithAggregatesInput | OccupationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Occupation"> | string
    playerId?: StringWithAggregatesFilter<"Occupation"> | string
    primaryJob?: EnumPrimaryOccupationNullableWithAggregatesFilter<"Occupation"> | $Enums.PrimaryOccupation | null
    secondaryJob?: EnumSecondaryOccupationNullableWithAggregatesFilter<"Occupation"> | $Enums.SecondaryOccupation | null
    level?: IntWithAggregatesFilter<"Occupation"> | number
    experience?: IntWithAggregatesFilter<"Occupation"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Occupation"> | Date | string
  }

  export type PlayerSkillWhereInput = {
    AND?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    OR?: PlayerSkillWhereInput[]
    NOT?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    id?: StringFilter<"PlayerSkill"> | string
    playerId?: StringFilter<"PlayerSkill"> | string
    skillName?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    experience?: IntFilter<"PlayerSkill"> | number
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type PlayerSkillOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type PlayerSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_skillName?: PlayerSkillPlayerIdSkillNameCompoundUniqueInput
    AND?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    OR?: PlayerSkillWhereInput[]
    NOT?: PlayerSkillWhereInput | PlayerSkillWhereInput[]
    playerId?: StringFilter<"PlayerSkill"> | string
    skillName?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    experience?: IntFilter<"PlayerSkill"> | number
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId_skillName">

  export type PlayerSkillOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    _count?: PlayerSkillCountOrderByAggregateInput
    _avg?: PlayerSkillAvgOrderByAggregateInput
    _max?: PlayerSkillMaxOrderByAggregateInput
    _min?: PlayerSkillMinOrderByAggregateInput
    _sum?: PlayerSkillSumOrderByAggregateInput
  }

  export type PlayerSkillScalarWhereWithAggregatesInput = {
    AND?: PlayerSkillScalarWhereWithAggregatesInput | PlayerSkillScalarWhereWithAggregatesInput[]
    OR?: PlayerSkillScalarWhereWithAggregatesInput[]
    NOT?: PlayerSkillScalarWhereWithAggregatesInput | PlayerSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerSkill"> | string
    playerId?: StringWithAggregatesFilter<"PlayerSkill"> | string
    skillName?: StringWithAggregatesFilter<"PlayerSkill"> | string
    level?: IntWithAggregatesFilter<"PlayerSkill"> | number
    experience?: IntWithAggregatesFilter<"PlayerSkill"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlayerSkill"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    tileX?: IntFilter<"Encounter"> | number
    tileY?: IntFilter<"Encounter"> | number
    tileId?: IntNullableFilter<"Encounter"> | number | null
    enemyType?: StringFilter<"Encounter"> | string
    enemyLevel?: IntFilter<"Encounter"> | number
    isActive?: BoolFilter<"Encounter"> | boolean
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    enemyType?: SortOrder
    enemyLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    tile?: MapTileOrderByWithRelationInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    tileX?: IntFilter<"Encounter"> | number
    tileY?: IntFilter<"Encounter"> | number
    tileId?: IntNullableFilter<"Encounter"> | number | null
    enemyType?: StringFilter<"Encounter"> | string
    enemyLevel?: IntFilter<"Encounter"> | number
    isActive?: BoolFilter<"Encounter"> | boolean
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    tile?: XOR<MapTileNullableScalarRelationFilter, MapTileWhereInput> | null
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrderInput | SortOrder
    enemyType?: SortOrder
    enemyLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _avg?: EncounterAvgOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
    _sum?: EncounterSumOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    tileX?: IntWithAggregatesFilter<"Encounter"> | number
    tileY?: IntWithAggregatesFilter<"Encounter"> | number
    tileId?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    enemyType?: StringWithAggregatesFilter<"Encounter"> | string
    enemyLevel?: IntWithAggregatesFilter<"Encounter"> | number
    isActive?: BoolWithAggregatesFilter<"Encounter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type CombatLogWhereInput = {
    AND?: CombatLogWhereInput | CombatLogWhereInput[]
    OR?: CombatLogWhereInput[]
    NOT?: CombatLogWhereInput | CombatLogWhereInput[]
    id?: StringFilter<"CombatLog"> | string
    playerId?: StringFilter<"CombatLog"> | string
    encounterId?: StringNullableFilter<"CombatLog"> | string | null
    turnNumber?: IntFilter<"CombatLog"> | number
    action?: StringFilter<"CombatLog"> | string
    result?: StringFilter<"CombatLog"> | string
    createdAt?: DateTimeFilter<"CombatLog"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type CombatLogOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    turnNumber?: SortOrder
    action?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type CombatLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CombatLogWhereInput | CombatLogWhereInput[]
    OR?: CombatLogWhereInput[]
    NOT?: CombatLogWhereInput | CombatLogWhereInput[]
    playerId?: StringFilter<"CombatLog"> | string
    encounterId?: StringNullableFilter<"CombatLog"> | string | null
    turnNumber?: IntFilter<"CombatLog"> | number
    action?: StringFilter<"CombatLog"> | string
    result?: StringFilter<"CombatLog"> | string
    createdAt?: DateTimeFilter<"CombatLog"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type CombatLogOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    turnNumber?: SortOrder
    action?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    _count?: CombatLogCountOrderByAggregateInput
    _avg?: CombatLogAvgOrderByAggregateInput
    _max?: CombatLogMaxOrderByAggregateInput
    _min?: CombatLogMinOrderByAggregateInput
    _sum?: CombatLogSumOrderByAggregateInput
  }

  export type CombatLogScalarWhereWithAggregatesInput = {
    AND?: CombatLogScalarWhereWithAggregatesInput | CombatLogScalarWhereWithAggregatesInput[]
    OR?: CombatLogScalarWhereWithAggregatesInput[]
    NOT?: CombatLogScalarWhereWithAggregatesInput | CombatLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CombatLog"> | string
    playerId?: StringWithAggregatesFilter<"CombatLog"> | string
    encounterId?: StringNullableWithAggregatesFilter<"CombatLog"> | string | null
    turnNumber?: IntWithAggregatesFilter<"CombatLog"> | number
    action?: StringWithAggregatesFilter<"CombatLog"> | string
    result?: StringWithAggregatesFilter<"CombatLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CombatLog"> | Date | string
  }

  export type DeathLogWhereInput = {
    AND?: DeathLogWhereInput | DeathLogWhereInput[]
    OR?: DeathLogWhereInput[]
    NOT?: DeathLogWhereInput | DeathLogWhereInput[]
    id?: StringFilter<"DeathLog"> | string
    playerId?: StringFilter<"DeathLog"> | string
    deathCount?: IntFilter<"DeathLog"> | number
    cause?: StringNullableFilter<"DeathLog"> | string | null
    locationX?: IntNullableFilter<"DeathLog"> | number | null
    locationY?: IntNullableFilter<"DeathLog"> | number | null
    createdAt?: DateTimeFilter<"DeathLog"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type DeathLogOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    deathCount?: SortOrder
    cause?: SortOrderInput | SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type DeathLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeathLogWhereInput | DeathLogWhereInput[]
    OR?: DeathLogWhereInput[]
    NOT?: DeathLogWhereInput | DeathLogWhereInput[]
    playerId?: StringFilter<"DeathLog"> | string
    deathCount?: IntFilter<"DeathLog"> | number
    cause?: StringNullableFilter<"DeathLog"> | string | null
    locationX?: IntNullableFilter<"DeathLog"> | number | null
    locationY?: IntNullableFilter<"DeathLog"> | number | null
    createdAt?: DateTimeFilter<"DeathLog"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type DeathLogOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    deathCount?: SortOrder
    cause?: SortOrderInput | SortOrder
    locationX?: SortOrderInput | SortOrder
    locationY?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeathLogCountOrderByAggregateInput
    _avg?: DeathLogAvgOrderByAggregateInput
    _max?: DeathLogMaxOrderByAggregateInput
    _min?: DeathLogMinOrderByAggregateInput
    _sum?: DeathLogSumOrderByAggregateInput
  }

  export type DeathLogScalarWhereWithAggregatesInput = {
    AND?: DeathLogScalarWhereWithAggregatesInput | DeathLogScalarWhereWithAggregatesInput[]
    OR?: DeathLogScalarWhereWithAggregatesInput[]
    NOT?: DeathLogScalarWhereWithAggregatesInput | DeathLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeathLog"> | string
    playerId?: StringWithAggregatesFilter<"DeathLog"> | string
    deathCount?: IntWithAggregatesFilter<"DeathLog"> | number
    cause?: StringNullableWithAggregatesFilter<"DeathLog"> | string | null
    locationX?: IntNullableWithAggregatesFilter<"DeathLog"> | number | null
    locationY?: IntNullableWithAggregatesFilter<"DeathLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DeathLog"> | Date | string
  }

  export type GuildWhereInput = {
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    id?: StringFilter<"Guild"> | string
    name?: StringFilter<"Guild"> | string
    description?: StringNullableFilter<"Guild"> | string | null
    level?: IntFilter<"Guild"> | number
    gold?: IntFilter<"Guild"> | number
    createdAt?: DateTimeFilter<"Guild"> | Date | string
    updatedAt?: DateTimeFilter<"Guild"> | Date | string
    members?: GuildMemberListRelationFilter
    bank?: XOR<GuildBankNullableScalarRelationFilter, GuildBankWhereInput> | null
    quests?: GuildQuestListRelationFilter
  }

  export type GuildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    gold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GuildMemberOrderByRelationAggregateInput
    bank?: GuildBankOrderByWithRelationInput
    quests?: GuildQuestOrderByRelationAggregateInput
  }

  export type GuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    description?: StringNullableFilter<"Guild"> | string | null
    level?: IntFilter<"Guild"> | number
    gold?: IntFilter<"Guild"> | number
    createdAt?: DateTimeFilter<"Guild"> | Date | string
    updatedAt?: DateTimeFilter<"Guild"> | Date | string
    members?: GuildMemberListRelationFilter
    bank?: XOR<GuildBankNullableScalarRelationFilter, GuildBankWhereInput> | null
    quests?: GuildQuestListRelationFilter
  }, "id" | "name">

  export type GuildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    gold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuildCountOrderByAggregateInput
    _avg?: GuildAvgOrderByAggregateInput
    _max?: GuildMaxOrderByAggregateInput
    _min?: GuildMinOrderByAggregateInput
    _sum?: GuildSumOrderByAggregateInput
  }

  export type GuildScalarWhereWithAggregatesInput = {
    AND?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    OR?: GuildScalarWhereWithAggregatesInput[]
    NOT?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guild"> | string
    name?: StringWithAggregatesFilter<"Guild"> | string
    description?: StringNullableWithAggregatesFilter<"Guild"> | string | null
    level?: IntWithAggregatesFilter<"Guild"> | number
    gold?: IntWithAggregatesFilter<"Guild"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Guild"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guild"> | Date | string
  }

  export type GuildMemberWhereInput = {
    AND?: GuildMemberWhereInput | GuildMemberWhereInput[]
    OR?: GuildMemberWhereInput[]
    NOT?: GuildMemberWhereInput | GuildMemberWhereInput[]
    id?: StringFilter<"GuildMember"> | string
    playerId?: StringFilter<"GuildMember"> | string
    guildId?: StringFilter<"GuildMember"> | string
    role?: EnumGuildRoleFilter<"GuildMember"> | $Enums.GuildRole
    joinedAt?: DateTimeFilter<"GuildMember"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }

  export type GuildMemberOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    guildId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    guild?: GuildOrderByWithRelationInput
  }

  export type GuildMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: GuildMemberWhereInput | GuildMemberWhereInput[]
    OR?: GuildMemberWhereInput[]
    NOT?: GuildMemberWhereInput | GuildMemberWhereInput[]
    guildId?: StringFilter<"GuildMember"> | string
    role?: EnumGuildRoleFilter<"GuildMember"> | $Enums.GuildRole
    joinedAt?: DateTimeFilter<"GuildMember"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }, "id" | "playerId">

  export type GuildMemberOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    guildId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: GuildMemberCountOrderByAggregateInput
    _max?: GuildMemberMaxOrderByAggregateInput
    _min?: GuildMemberMinOrderByAggregateInput
  }

  export type GuildMemberScalarWhereWithAggregatesInput = {
    AND?: GuildMemberScalarWhereWithAggregatesInput | GuildMemberScalarWhereWithAggregatesInput[]
    OR?: GuildMemberScalarWhereWithAggregatesInput[]
    NOT?: GuildMemberScalarWhereWithAggregatesInput | GuildMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildMember"> | string
    playerId?: StringWithAggregatesFilter<"GuildMember"> | string
    guildId?: StringWithAggregatesFilter<"GuildMember"> | string
    role?: EnumGuildRoleWithAggregatesFilter<"GuildMember"> | $Enums.GuildRole
    joinedAt?: DateTimeWithAggregatesFilter<"GuildMember"> | Date | string
  }

  export type GuildBankWhereInput = {
    AND?: GuildBankWhereInput | GuildBankWhereInput[]
    OR?: GuildBankWhereInput[]
    NOT?: GuildBankWhereInput | GuildBankWhereInput[]
    id?: StringFilter<"GuildBank"> | string
    guildId?: StringFilter<"GuildBank"> | string
    gold?: IntFilter<"GuildBank"> | number
    updatedAt?: DateTimeFilter<"GuildBank"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }

  export type GuildBankOrderByWithRelationInput = {
    id?: SortOrder
    guildId?: SortOrder
    gold?: SortOrder
    updatedAt?: SortOrder
    guild?: GuildOrderByWithRelationInput
  }

  export type GuildBankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guildId?: string
    AND?: GuildBankWhereInput | GuildBankWhereInput[]
    OR?: GuildBankWhereInput[]
    NOT?: GuildBankWhereInput | GuildBankWhereInput[]
    gold?: IntFilter<"GuildBank"> | number
    updatedAt?: DateTimeFilter<"GuildBank"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }, "id" | "guildId">

  export type GuildBankOrderByWithAggregationInput = {
    id?: SortOrder
    guildId?: SortOrder
    gold?: SortOrder
    updatedAt?: SortOrder
    _count?: GuildBankCountOrderByAggregateInput
    _avg?: GuildBankAvgOrderByAggregateInput
    _max?: GuildBankMaxOrderByAggregateInput
    _min?: GuildBankMinOrderByAggregateInput
    _sum?: GuildBankSumOrderByAggregateInput
  }

  export type GuildBankScalarWhereWithAggregatesInput = {
    AND?: GuildBankScalarWhereWithAggregatesInput | GuildBankScalarWhereWithAggregatesInput[]
    OR?: GuildBankScalarWhereWithAggregatesInput[]
    NOT?: GuildBankScalarWhereWithAggregatesInput | GuildBankScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildBank"> | string
    guildId?: StringWithAggregatesFilter<"GuildBank"> | string
    gold?: IntWithAggregatesFilter<"GuildBank"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"GuildBank"> | Date | string
  }

  export type GuildQuestWhereInput = {
    AND?: GuildQuestWhereInput | GuildQuestWhereInput[]
    OR?: GuildQuestWhereInput[]
    NOT?: GuildQuestWhereInput | GuildQuestWhereInput[]
    id?: StringFilter<"GuildQuest"> | string
    guildId?: StringFilter<"GuildQuest"> | string
    title?: StringFilter<"GuildQuest"> | string
    description?: StringFilter<"GuildQuest"> | string
    reward?: StringNullableFilter<"GuildQuest"> | string | null
    isActive?: BoolFilter<"GuildQuest"> | boolean
    createdAt?: DateTimeFilter<"GuildQuest"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }

  export type GuildQuestOrderByWithRelationInput = {
    id?: SortOrder
    guildId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    guild?: GuildOrderByWithRelationInput
  }

  export type GuildQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuildQuestWhereInput | GuildQuestWhereInput[]
    OR?: GuildQuestWhereInput[]
    NOT?: GuildQuestWhereInput | GuildQuestWhereInput[]
    guildId?: StringFilter<"GuildQuest"> | string
    title?: StringFilter<"GuildQuest"> | string
    description?: StringFilter<"GuildQuest"> | string
    reward?: StringNullableFilter<"GuildQuest"> | string | null
    isActive?: BoolFilter<"GuildQuest"> | boolean
    createdAt?: DateTimeFilter<"GuildQuest"> | Date | string
    guild?: XOR<GuildScalarRelationFilter, GuildWhereInput>
  }, "id">

  export type GuildQuestOrderByWithAggregationInput = {
    id?: SortOrder
    guildId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: GuildQuestCountOrderByAggregateInput
    _max?: GuildQuestMaxOrderByAggregateInput
    _min?: GuildQuestMinOrderByAggregateInput
  }

  export type GuildQuestScalarWhereWithAggregatesInput = {
    AND?: GuildQuestScalarWhereWithAggregatesInput | GuildQuestScalarWhereWithAggregatesInput[]
    OR?: GuildQuestScalarWhereWithAggregatesInput[]
    NOT?: GuildQuestScalarWhereWithAggregatesInput | GuildQuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuildQuest"> | string
    guildId?: StringWithAggregatesFilter<"GuildQuest"> | string
    title?: StringWithAggregatesFilter<"GuildQuest"> | string
    description?: StringWithAggregatesFilter<"GuildQuest"> | string
    reward?: StringNullableWithAggregatesFilter<"GuildQuest"> | string | null
    isActive?: BoolWithAggregatesFilter<"GuildQuest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GuildQuest"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    playerId?: StringFilter<"BankAccount"> | string
    gold?: IntFilter<"BankAccount"> | number
    vaultLevel?: IntFilter<"BankAccount"> | number
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    vaultItems?: BankVaultItemListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gold?: SortOrder
    vaultLevel?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
    vaultItems?: BankVaultItemOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    gold?: IntFilter<"BankAccount"> | number
    vaultLevel?: IntFilter<"BankAccount"> | number
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    vaultItems?: BankVaultItemListRelationFilter
  }, "id" | "playerId">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gold?: SortOrder
    vaultLevel?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    playerId?: StringWithAggregatesFilter<"BankAccount"> | string
    gold?: IntWithAggregatesFilter<"BankAccount"> | number
    vaultLevel?: IntWithAggregatesFilter<"BankAccount"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type BankVaultItemWhereInput = {
    AND?: BankVaultItemWhereInput | BankVaultItemWhereInput[]
    OR?: BankVaultItemWhereInput[]
    NOT?: BankVaultItemWhereInput | BankVaultItemWhereInput[]
    id?: StringFilter<"BankVaultItem"> | string
    accountId?: StringFilter<"BankVaultItem"> | string
    itemId?: StringFilter<"BankVaultItem"> | string
    quantity?: IntFilter<"BankVaultItem"> | number
    createdAt?: DateTimeFilter<"BankVaultItem"> | Date | string
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type BankVaultItemOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    account?: BankAccountOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type BankVaultItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankVaultItemWhereInput | BankVaultItemWhereInput[]
    OR?: BankVaultItemWhereInput[]
    NOT?: BankVaultItemWhereInput | BankVaultItemWhereInput[]
    accountId?: StringFilter<"BankVaultItem"> | string
    itemId?: StringFilter<"BankVaultItem"> | string
    quantity?: IntFilter<"BankVaultItem"> | number
    createdAt?: DateTimeFilter<"BankVaultItem"> | Date | string
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type BankVaultItemOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: BankVaultItemCountOrderByAggregateInput
    _avg?: BankVaultItemAvgOrderByAggregateInput
    _max?: BankVaultItemMaxOrderByAggregateInput
    _min?: BankVaultItemMinOrderByAggregateInput
    _sum?: BankVaultItemSumOrderByAggregateInput
  }

  export type BankVaultItemScalarWhereWithAggregatesInput = {
    AND?: BankVaultItemScalarWhereWithAggregatesInput | BankVaultItemScalarWhereWithAggregatesInput[]
    OR?: BankVaultItemScalarWhereWithAggregatesInput[]
    NOT?: BankVaultItemScalarWhereWithAggregatesInput | BankVaultItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankVaultItem"> | string
    accountId?: StringWithAggregatesFilter<"BankVaultItem"> | string
    itemId?: StringWithAggregatesFilter<"BankVaultItem"> | string
    quantity?: IntWithAggregatesFilter<"BankVaultItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BankVaultItem"> | Date | string
  }

  export type MarketListingWhereInput = {
    AND?: MarketListingWhereInput | MarketListingWhereInput[]
    OR?: MarketListingWhereInput[]
    NOT?: MarketListingWhereInput | MarketListingWhereInput[]
    id?: StringFilter<"MarketListing"> | string
    playerId?: StringFilter<"MarketListing"> | string
    itemId?: StringFilter<"MarketListing"> | string
    quantity?: IntFilter<"MarketListing"> | number
    pricePerUnit?: IntFilter<"MarketListing"> | number
    totalPrice?: IntFilter<"MarketListing"> | number
    listingTax?: IntFilter<"MarketListing"> | number
    isActive?: BoolFilter<"MarketListing"> | boolean
    expiresAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
    soldAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type MarketListingOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    soldAt?: SortOrderInput | SortOrder
    player?: PlayerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type MarketListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketListingWhereInput | MarketListingWhereInput[]
    OR?: MarketListingWhereInput[]
    NOT?: MarketListingWhereInput | MarketListingWhereInput[]
    playerId?: StringFilter<"MarketListing"> | string
    itemId?: StringFilter<"MarketListing"> | string
    quantity?: IntFilter<"MarketListing"> | number
    pricePerUnit?: IntFilter<"MarketListing"> | number
    totalPrice?: IntFilter<"MarketListing"> | number
    listingTax?: IntFilter<"MarketListing"> | number
    isActive?: BoolFilter<"MarketListing"> | boolean
    expiresAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
    soldAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type MarketListingOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    soldAt?: SortOrderInput | SortOrder
    _count?: MarketListingCountOrderByAggregateInput
    _avg?: MarketListingAvgOrderByAggregateInput
    _max?: MarketListingMaxOrderByAggregateInput
    _min?: MarketListingMinOrderByAggregateInput
    _sum?: MarketListingSumOrderByAggregateInput
  }

  export type MarketListingScalarWhereWithAggregatesInput = {
    AND?: MarketListingScalarWhereWithAggregatesInput | MarketListingScalarWhereWithAggregatesInput[]
    OR?: MarketListingScalarWhereWithAggregatesInput[]
    NOT?: MarketListingScalarWhereWithAggregatesInput | MarketListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketListing"> | string
    playerId?: StringWithAggregatesFilter<"MarketListing"> | string
    itemId?: StringWithAggregatesFilter<"MarketListing"> | string
    quantity?: IntWithAggregatesFilter<"MarketListing"> | number
    pricePerUnit?: IntWithAggregatesFilter<"MarketListing"> | number
    totalPrice?: IntWithAggregatesFilter<"MarketListing"> | number
    listingTax?: IntWithAggregatesFilter<"MarketListing"> | number
    isActive?: BoolWithAggregatesFilter<"MarketListing"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"MarketListing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketListing"> | Date | string
    soldAt?: DateTimeNullableWithAggregatesFilter<"MarketListing"> | Date | string | null
  }

  export type MarketTransactionWhereInput = {
    AND?: MarketTransactionWhereInput | MarketTransactionWhereInput[]
    OR?: MarketTransactionWhereInput[]
    NOT?: MarketTransactionWhereInput | MarketTransactionWhereInput[]
    id?: StringFilter<"MarketTransaction"> | string
    listingId?: StringFilter<"MarketTransaction"> | string
    buyerId?: StringFilter<"MarketTransaction"> | string
    sellerId?: StringFilter<"MarketTransaction"> | string
    itemId?: StringFilter<"MarketTransaction"> | string
    quantity?: IntFilter<"MarketTransaction"> | number
    totalPrice?: IntFilter<"MarketTransaction"> | number
    createdAt?: DateTimeFilter<"MarketTransaction"> | Date | string
  }

  export type MarketTransactionOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketTransactionWhereInput | MarketTransactionWhereInput[]
    OR?: MarketTransactionWhereInput[]
    NOT?: MarketTransactionWhereInput | MarketTransactionWhereInput[]
    listingId?: StringFilter<"MarketTransaction"> | string
    buyerId?: StringFilter<"MarketTransaction"> | string
    sellerId?: StringFilter<"MarketTransaction"> | string
    itemId?: StringFilter<"MarketTransaction"> | string
    quantity?: IntFilter<"MarketTransaction"> | number
    totalPrice?: IntFilter<"MarketTransaction"> | number
    createdAt?: DateTimeFilter<"MarketTransaction"> | Date | string
  }, "id">

  export type MarketTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    _count?: MarketTransactionCountOrderByAggregateInput
    _avg?: MarketTransactionAvgOrderByAggregateInput
    _max?: MarketTransactionMaxOrderByAggregateInput
    _min?: MarketTransactionMinOrderByAggregateInput
    _sum?: MarketTransactionSumOrderByAggregateInput
  }

  export type MarketTransactionScalarWhereWithAggregatesInput = {
    AND?: MarketTransactionScalarWhereWithAggregatesInput | MarketTransactionScalarWhereWithAggregatesInput[]
    OR?: MarketTransactionScalarWhereWithAggregatesInput[]
    NOT?: MarketTransactionScalarWhereWithAggregatesInput | MarketTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketTransaction"> | string
    listingId?: StringWithAggregatesFilter<"MarketTransaction"> | string
    buyerId?: StringWithAggregatesFilter<"MarketTransaction"> | string
    sellerId?: StringWithAggregatesFilter<"MarketTransaction"> | string
    itemId?: StringWithAggregatesFilter<"MarketTransaction"> | string
    quantity?: IntWithAggregatesFilter<"MarketTransaction"> | number
    totalPrice?: IntWithAggregatesFilter<"MarketTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MarketTransaction"> | Date | string
  }

  export type QuestWhereInput = {
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    id?: StringFilter<"Quest"> | string
    npcId?: StringNullableFilter<"Quest"> | string | null
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    questType?: EnumQuestTypeFilter<"Quest"> | $Enums.QuestType
    reward?: StringNullableFilter<"Quest"> | string | null
    requirements?: StringNullableFilter<"Quest"> | string | null
    isActive?: BoolFilter<"Quest"> | boolean
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    npc?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
  }

  export type QuestOrderByWithRelationInput = {
    id?: SortOrder
    npcId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    questType?: SortOrder
    reward?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    npc?: NPCOrderByWithRelationInput
  }

  export type QuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    npcId?: StringNullableFilter<"Quest"> | string | null
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    questType?: EnumQuestTypeFilter<"Quest"> | $Enums.QuestType
    reward?: StringNullableFilter<"Quest"> | string | null
    requirements?: StringNullableFilter<"Quest"> | string | null
    isActive?: BoolFilter<"Quest"> | boolean
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    npc?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
  }, "id">

  export type QuestOrderByWithAggregationInput = {
    id?: SortOrder
    npcId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    questType?: SortOrder
    reward?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: QuestCountOrderByAggregateInput
    _max?: QuestMaxOrderByAggregateInput
    _min?: QuestMinOrderByAggregateInput
  }

  export type QuestScalarWhereWithAggregatesInput = {
    AND?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    OR?: QuestScalarWhereWithAggregatesInput[]
    NOT?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quest"> | string
    npcId?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    title?: StringWithAggregatesFilter<"Quest"> | string
    description?: StringWithAggregatesFilter<"Quest"> | string
    questType?: EnumQuestTypeWithAggregatesFilter<"Quest"> | $Enums.QuestType
    reward?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    isActive?: BoolWithAggregatesFilter<"Quest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
  }

  export type PostCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PostUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PostUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
    player?: PlayerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsCreateInput = {
    id?: string
    vitality?: number
    strength?: number
    speed?: number
    dexterity?: number
    maxHP?: number
    currentHP?: number
    maxSP?: number
    currentSP?: number
    statPoints?: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutStatsInput
  }

  export type PlayerStatsUncheckedCreateInput = {
    id?: string
    playerId: string
    vitality?: number
    strength?: number
    speed?: number
    dexterity?: number
    maxHP?: number
    currentHP?: number
    maxSP?: number
    currentSP?: number
    statPoints?: number
    updatedAt?: Date | string
  }

  export type PlayerStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutStatsNestedInput
  }

  export type PlayerStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsCreateManyInput = {
    id?: string
    playerId: string
    vitality?: number
    strength?: number
    speed?: number
    dexterity?: number
    maxHP?: number
    currentHP?: number
    maxSP?: number
    currentSP?: number
    statPoints?: number
    updatedAt?: Date | string
  }

  export type PlayerStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapTileCreateInput = {
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionCreateNestedManyWithoutTileInput
    npcs?: NPCCreateNestedManyWithoutTileInput
    encounters?: EncounterCreateNestedManyWithoutTileInput
  }

  export type MapTileUncheckedCreateInput = {
    id?: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionUncheckedCreateNestedManyWithoutTileInput
    npcs?: NPCUncheckedCreateNestedManyWithoutTileInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutTileInput
  }

  export type MapTileUpdateInput = {
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUpdateManyWithoutTileNestedInput
    npcs?: NPCUpdateManyWithoutTileNestedInput
    encounters?: EncounterUpdateManyWithoutTileNestedInput
  }

  export type MapTileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUncheckedUpdateManyWithoutTileNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutTileNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutTileNestedInput
  }

  export type MapTileCreateManyInput = {
    id?: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
  }

  export type MapTileUpdateManyMutationInput = {
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapTileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapPositionCreateInput = {
    id?: string
    tileX: number
    tileY: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPositionInput
    tile?: MapTileCreateNestedOneWithoutPositionsInput
  }

  export type MapPositionUncheckedCreateInput = {
    id?: string
    playerId: string
    tileX: number
    tileY: number
    tileId?: number | null
    updatedAt?: Date | string
  }

  export type MapPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPositionNestedInput
    tile?: MapTileUpdateOneWithoutPositionsNestedInput
  }

  export type MapPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapPositionCreateManyInput = {
    id?: string
    playerId: string
    tileX: number
    tileY: number
    tileId?: number | null
    updatedAt?: Date | string
  }

  export type MapPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCCreateInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
    tile?: MapTileCreateNestedOneWithoutNpcsInput
    shopItems?: ShopItemCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    tileId?: number | null
    dialogue?: string | null
    createdAt?: Date | string
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tile?: MapTileUpdateOneWithoutNpcsNestedInput
    shopItems?: ShopItemUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCCreateManyInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    tileId?: number | null
    dialogue?: string | null
    createdAt?: Date | string
  }

  export type NPCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateInput = {
    id?: string
    price: number
    stock?: number | null
    createdAt?: Date | string
    npc: NPCCreateNestedOneWithoutShopItemsInput
    item: ItemCreateNestedOneWithoutShopItemsInput
  }

  export type ShopItemUncheckedCreateInput = {
    id?: string
    npcId: string
    itemId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type ShopItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npc?: NPCUpdateOneRequiredWithoutShopItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutShopItemsNestedInput
  }

  export type ShopItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateManyInput = {
    id?: string
    npcId: string
    itemId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type ShopItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutInventoryInput
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    playerId: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutInventoryNestedInput
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    playerId: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateManyInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationCreateInput = {
    id?: string
    primaryJob?: $Enums.PrimaryOccupation | null
    secondaryJob?: $Enums.SecondaryOccupation | null
    level?: number
    experience?: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutOccupationInput
  }

  export type OccupationUncheckedCreateInput = {
    id?: string
    playerId: string
    primaryJob?: $Enums.PrimaryOccupation | null
    secondaryJob?: $Enums.SecondaryOccupation | null
    level?: number
    experience?: number
    updatedAt?: Date | string
  }

  export type OccupationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutOccupationNestedInput
  }

  export type OccupationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationCreateManyInput = {
    id?: string
    playerId: string
    primaryJob?: $Enums.PrimaryOccupation | null
    secondaryJob?: $Enums.SecondaryOccupation | null
    level?: number
    experience?: number
    updatedAt?: Date | string
  }

  export type OccupationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateInput = {
    id?: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutSkillsInput
  }

  export type PlayerSkillUncheckedCreateInput = {
    id?: string
    playerId: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
  }

  export type PlayerSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type PlayerSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillCreateManyInput = {
    id?: string
    playerId: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
  }

  export type PlayerSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    tileX: number
    tileY: number
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
    tile?: MapTileCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    tileX: number
    tileY: number
    tileId?: number | null
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tile?: MapTileUpdateOneWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyInput = {
    id?: string
    tileX: number
    tileY: number
    tileId?: number | null
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogCreateInput = {
    id?: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutCombatLogsInput
  }

  export type CombatLogUncheckedCreateInput = {
    id?: string
    playerId: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
  }

  export type CombatLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutCombatLogsNestedInput
  }

  export type CombatLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogCreateManyInput = {
    id?: string
    playerId: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
  }

  export type CombatLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogCreateInput = {
    id?: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutDeathLogsInput
  }

  export type DeathLogUncheckedCreateInput = {
    id?: string
    playerId: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
  }

  export type DeathLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutDeathLogsNestedInput
  }

  export type DeathLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogCreateManyInput = {
    id?: string
    playerId: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
  }

  export type DeathLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildCreateInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberCreateNestedManyWithoutGuildInput
    bank?: GuildBankCreateNestedOneWithoutGuildInput
    quests?: GuildQuestCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberUncheckedCreateNestedManyWithoutGuildInput
    bank?: GuildBankUncheckedCreateNestedOneWithoutGuildInput
    quests?: GuildQuestUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUpdateManyWithoutGuildNestedInput
    bank?: GuildBankUpdateOneWithoutGuildNestedInput
    quests?: GuildQuestUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUncheckedUpdateManyWithoutGuildNestedInput
    bank?: GuildBankUncheckedUpdateOneWithoutGuildNestedInput
    quests?: GuildQuestUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type GuildCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberCreateInput = {
    id?: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
    player: PlayerCreateNestedOneWithoutGuildMemberInput
    guild: GuildCreateNestedOneWithoutMembersInput
  }

  export type GuildMemberUncheckedCreateInput = {
    id?: string
    playerId: string
    guildId: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
  }

  export type GuildMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutGuildMemberNestedInput
    guild?: GuildUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GuildMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberCreateManyInput = {
    id?: string
    playerId: string
    guildId: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
  }

  export type GuildMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildBankCreateInput = {
    id?: string
    gold?: number
    updatedAt?: Date | string
    guild: GuildCreateNestedOneWithoutBankInput
  }

  export type GuildBankUncheckedCreateInput = {
    id?: string
    guildId: string
    gold?: number
    updatedAt?: Date | string
  }

  export type GuildBankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: GuildUpdateOneRequiredWithoutBankNestedInput
  }

  export type GuildBankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildBankCreateManyInput = {
    id?: string
    guildId: string
    gold?: number
    updatedAt?: Date | string
  }

  export type GuildBankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildBankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestCreateInput = {
    id?: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
    guild: GuildCreateNestedOneWithoutQuestsInput
  }

  export type GuildQuestUncheckedCreateInput = {
    id?: string
    guildId: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuildQuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: GuildUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type GuildQuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestCreateManyInput = {
    id?: string
    guildId: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuildQuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutBankAccountInput
    vaultItems?: BankVaultItemCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    playerId: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
    vaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBankAccountNestedInput
    vaultItems?: BankVaultItemUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultItems?: BankVaultItemUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    playerId: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemCreateInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    account: BankAccountCreateNestedOneWithoutVaultItemsInput
    item: ItemCreateNestedOneWithoutBankVaultItemsInput
  }

  export type BankVaultItemUncheckedCreateInput = {
    id?: string
    accountId: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type BankVaultItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutVaultItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutBankVaultItemsNestedInput
  }

  export type BankVaultItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemCreateManyInput = {
    id?: string
    accountId: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type BankVaultItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingCreateInput = {
    id?: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
    player: PlayerCreateNestedOneWithoutMarketListingsInput
    item: ItemCreateNestedOneWithoutMarketListingsInput
  }

  export type MarketListingUncheckedCreateInput = {
    id?: string
    playerId: string
    itemId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type MarketListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: PlayerUpdateOneRequiredWithoutMarketListingsNestedInput
    item?: ItemUpdateOneRequiredWithoutMarketListingsNestedInput
  }

  export type MarketListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketListingCreateManyInput = {
    id?: string
    playerId: string
    itemId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type MarketListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketTransactionCreateInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    itemId: string
    quantity: number
    totalPrice: number
    createdAt?: Date | string
  }

  export type MarketTransactionUncheckedCreateInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    itemId: string
    quantity: number
    totalPrice: number
    createdAt?: Date | string
  }

  export type MarketTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTransactionCreateManyInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    itemId: string
    quantity: number
    totalPrice: number
    createdAt?: Date | string
  }

  export type MarketTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestCreateInput = {
    id?: string
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
    npc?: NPCCreateNestedOneWithoutQuestsInput
  }

  export type QuestUncheckedCreateInput = {
    id?: string
    npcId?: string | null
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npc?: NPCUpdateOneWithoutQuestsNestedInput
  }

  export type QuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestCreateManyInput = {
    id?: string
    npcId?: string | null
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PlayerNullableScalarRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PlayerStatsNullableScalarRelationFilter = {
    is?: PlayerStatsWhereInput | null
    isNot?: PlayerStatsWhereInput | null
  }

  export type MapPositionNullableScalarRelationFilter = {
    is?: MapPositionWhereInput | null
    isNot?: MapPositionWhereInput | null
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type EquipmentNullableScalarRelationFilter = {
    is?: EquipmentWhereInput | null
    isNot?: EquipmentWhereInput | null
  }

  export type OccupationNullableScalarRelationFilter = {
    is?: OccupationWhereInput | null
    isNot?: OccupationWhereInput | null
  }

  export type GuildMemberNullableScalarRelationFilter = {
    is?: GuildMemberWhereInput | null
    isNot?: GuildMemberWhereInput | null
  }

  export type BankAccountNullableScalarRelationFilter = {
    is?: BankAccountWhereInput | null
    isNot?: BankAccountWhereInput | null
  }

  export type MarketListingListRelationFilter = {
    every?: MarketListingWhereInput
    some?: MarketListingWhereInput
    none?: MarketListingWhereInput
  }

  export type CombatLogListRelationFilter = {
    every?: CombatLogWhereInput
    some?: CombatLogWhereInput
    none?: CombatLogWhereInput
  }

  export type DeathLogListRelationFilter = {
    every?: DeathLogWhereInput
    some?: DeathLogWhereInput
    none?: DeathLogWhereInput
  }

  export type PlayerSkillListRelationFilter = {
    every?: PlayerSkillWhereInput
    some?: PlayerSkillWhereInput
    none?: PlayerSkillWhereInput
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CombatLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeathLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    gold?: SortOrder
    deathCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type PlayerStatsCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsAvgOrderByAggregateInput = {
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
  }

  export type PlayerStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatsSumOrderByAggregateInput = {
    vitality?: SortOrder
    strength?: SortOrder
    speed?: SortOrder
    dexterity?: SortOrder
    maxHP?: SortOrder
    currentHP?: SortOrder
    maxSP?: SortOrder
    currentSP?: SortOrder
    statPoints?: SortOrder
  }

  export type EnumTileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TileType | EnumTileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTileTypeFilter<$PrismaModel> | $Enums.TileType
  }

  export type EnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type EnumResourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableFilter<$PrismaModel> | $Enums.ResourceType | null
  }

  export type MapPositionListRelationFilter = {
    every?: MapPositionWhereInput
    some?: MapPositionWhereInput
    none?: MapPositionWhereInput
  }

  export type NPCListRelationFilter = {
    every?: NPCWhereInput
    some?: NPCWhereInput
    none?: NPCWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type MapPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapTileXYCompoundUniqueInput = {
    x: number
    y: number
  }

  export type MapTileCountOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    tileType?: SortOrder
    zoneType?: SortOrder
    isSafeZone?: SortOrder
    hasResource?: SortOrder
    resourceType?: SortOrder
    description?: SortOrder
  }

  export type MapTileAvgOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type MapTileMaxOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    tileType?: SortOrder
    zoneType?: SortOrder
    isSafeZone?: SortOrder
    hasResource?: SortOrder
    resourceType?: SortOrder
    description?: SortOrder
  }

  export type MapTileMinOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    tileType?: SortOrder
    zoneType?: SortOrder
    isSafeZone?: SortOrder
    hasResource?: SortOrder
    resourceType?: SortOrder
    description?: SortOrder
  }

  export type MapTileSumOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type EnumTileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TileType | EnumTileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTileTypeWithAggregatesFilter<$PrismaModel> | $Enums.TileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTileTypeFilter<$PrismaModel>
    _max?: NestedEnumTileTypeFilter<$PrismaModel>
  }

  export type EnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type EnumResourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
  }

  export type MapTileNullableScalarRelationFilter = {
    is?: MapTileWhereInput | null
    isNot?: MapTileWhereInput | null
  }

  export type MapPositionCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapPositionAvgOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
  }

  export type MapPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapPositionMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapPositionSumOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
  }

  export type EnumNPCTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCType | EnumNPCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNPCTypeFilter<$PrismaModel> | $Enums.NPCType
  }

  export type ShopItemListRelationFilter = {
    every?: ShopItemWhereInput
    some?: ShopItemWhereInput
    none?: ShopItemWhereInput
  }

  export type QuestListRelationFilter = {
    every?: QuestWhereInput
    some?: QuestWhereInput
    none?: QuestWhereInput
  }

  export type ShopItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NPCCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npcType?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    dialogue?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCAvgOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
  }

  export type NPCMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npcType?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    dialogue?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    npcType?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    dialogue?: SortOrder
    createdAt?: SortOrder
  }

  export type NPCSumOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
  }

  export type EnumNPCTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCType | EnumNPCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNPCTypeWithAggregatesFilter<$PrismaModel> | $Enums.NPCType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNPCTypeFilter<$PrismaModel>
    _max?: NestedEnumNPCTypeFilter<$PrismaModel>
  }

  export type NPCScalarRelationFilter = {
    is?: NPCWhereInput
    isNot?: NPCWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ShopItemCountOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopItemAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ShopItemMaxOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopItemMinOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    itemId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
  }

  export type ShopItemSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type EnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type EnumEquipmentSlotNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel> | $Enums.EquipmentSlot | null
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type BankVaultItemListRelationFilter = {
    every?: BankVaultItemWhereInput
    some?: BankVaultItemWhereInput
    none?: BankVaultItemWhereInput
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankVaultItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    itemType?: SortOrder
    itemRarity?: SortOrder
    tier?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    maxStack?: SortOrder
    equipmentSlot?: SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    tier?: SortOrder
    value?: SortOrder
    maxStack?: SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    itemType?: SortOrder
    itemRarity?: SortOrder
    tier?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    maxStack?: SortOrder
    equipmentSlot?: SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    itemType?: SortOrder
    itemRarity?: SortOrder
    tier?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    maxStack?: SortOrder
    equipmentSlot?: SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    tier?: SortOrder
    value?: SortOrder
    maxStack?: SortOrder
    vitalityBonus?: SortOrder
    strengthBonus?: SortOrder
    speedBonus?: SortOrder
    dexterityBonus?: SortOrder
    hpBonus?: SortOrder
    spBonus?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type EnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type EnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentSlot | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
    _max?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ItemNullableScalarRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    weaponId?: SortOrder
    headId?: SortOrder
    chestId?: SortOrder
    legsId?: SortOrder
    feetId?: SortOrder
    accessory1Id?: SortOrder
    accessory2Id?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    weaponId?: SortOrder
    headId?: SortOrder
    chestId?: SortOrder
    legsId?: SortOrder
    feetId?: SortOrder
    accessory1Id?: SortOrder
    accessory2Id?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    weaponId?: SortOrder
    headId?: SortOrder
    chestId?: SortOrder
    legsId?: SortOrder
    feetId?: SortOrder
    accessory1Id?: SortOrder
    accessory2Id?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPrimaryOccupationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PrimaryOccupation | EnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel> | $Enums.PrimaryOccupation | null
  }

  export type EnumSecondaryOccupationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SecondaryOccupation | EnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel> | $Enums.SecondaryOccupation | null
  }

  export type OccupationCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    primaryJob?: SortOrder
    secondaryJob?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type OccupationMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    primaryJob?: SortOrder
    secondaryJob?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    primaryJob?: SortOrder
    secondaryJob?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccupationSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type EnumPrimaryOccupationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrimaryOccupation | EnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrimaryOccupationNullableWithAggregatesFilter<$PrismaModel> | $Enums.PrimaryOccupation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel>
    _max?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel>
  }

  export type EnumSecondaryOccupationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecondaryOccupation | EnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSecondaryOccupationNullableWithAggregatesFilter<$PrismaModel> | $Enums.SecondaryOccupation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel>
    _max?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel>
  }

  export type PlayerSkillPlayerIdSkillNameCompoundUniqueInput = {
    playerId: string
    skillName: string
  }

  export type PlayerSkillCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerSkillAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type PlayerSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerSkillMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    skillName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerSkillSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    enemyType?: SortOrder
    enemyLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterAvgOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    enemyLevel?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    enemyType?: SortOrder
    enemyLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    enemyType?: SortOrder
    enemyLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterSumOrderByAggregateInput = {
    tileX?: SortOrder
    tileY?: SortOrder
    tileId?: SortOrder
    enemyLevel?: SortOrder
  }

  export type CombatLogCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    encounterId?: SortOrder
    turnNumber?: SortOrder
    action?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CombatLogAvgOrderByAggregateInput = {
    turnNumber?: SortOrder
  }

  export type CombatLogMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    encounterId?: SortOrder
    turnNumber?: SortOrder
    action?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CombatLogMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    encounterId?: SortOrder
    turnNumber?: SortOrder
    action?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CombatLogSumOrderByAggregateInput = {
    turnNumber?: SortOrder
  }

  export type DeathLogCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    deathCount?: SortOrder
    cause?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    createdAt?: SortOrder
  }

  export type DeathLogAvgOrderByAggregateInput = {
    deathCount?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type DeathLogMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    deathCount?: SortOrder
    cause?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    createdAt?: SortOrder
  }

  export type DeathLogMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    deathCount?: SortOrder
    cause?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
    createdAt?: SortOrder
  }

  export type DeathLogSumOrderByAggregateInput = {
    deathCount?: SortOrder
    locationX?: SortOrder
    locationY?: SortOrder
  }

  export type GuildMemberListRelationFilter = {
    every?: GuildMemberWhereInput
    some?: GuildMemberWhereInput
    none?: GuildMemberWhereInput
  }

  export type GuildBankNullableScalarRelationFilter = {
    is?: GuildBankWhereInput | null
    isNot?: GuildBankWhereInput | null
  }

  export type GuildQuestListRelationFilter = {
    every?: GuildQuestWhereInput
    some?: GuildQuestWhereInput
    none?: GuildQuestWhereInput
  }

  export type GuildMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildQuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    gold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildAvgOrderByAggregateInput = {
    level?: SortOrder
    gold?: SortOrder
  }

  export type GuildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    gold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    gold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildSumOrderByAggregateInput = {
    level?: SortOrder
    gold?: SortOrder
  }

  export type EnumGuildRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildRole | EnumGuildRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGuildRoleFilter<$PrismaModel> | $Enums.GuildRole
  }

  export type GuildScalarRelationFilter = {
    is?: GuildWhereInput
    isNot?: GuildWhereInput
  }

  export type GuildMemberCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    guildId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GuildMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    guildId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GuildMemberMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    guildId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumGuildRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildRole | EnumGuildRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGuildRoleWithAggregatesFilter<$PrismaModel> | $Enums.GuildRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuildRoleFilter<$PrismaModel>
    _max?: NestedEnumGuildRoleFilter<$PrismaModel>
  }

  export type GuildBankCountOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    gold?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildBankAvgOrderByAggregateInput = {
    gold?: SortOrder
  }

  export type GuildBankMaxOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    gold?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildBankMinOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    gold?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuildBankSumOrderByAggregateInput = {
    gold?: SortOrder
  }

  export type GuildQuestCountOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GuildQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type GuildQuestMinOrderByAggregateInput = {
    id?: SortOrder
    guildId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gold?: SortOrder
    vaultLevel?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    gold?: SortOrder
    vaultLevel?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gold?: SortOrder
    vaultLevel?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gold?: SortOrder
    vaultLevel?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    gold?: SortOrder
    vaultLevel?: SortOrder
  }

  export type BankAccountScalarRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type BankVaultItemCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type BankVaultItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type BankVaultItemMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type BankVaultItemMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type BankVaultItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type MarketListingCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    soldAt?: SortOrder
  }

  export type MarketListingAvgOrderByAggregateInput = {
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
  }

  export type MarketListingMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    soldAt?: SortOrder
  }

  export type MarketListingMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    soldAt?: SortOrder
  }

  export type MarketListingSumOrderByAggregateInput = {
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalPrice?: SortOrder
    listingTax?: SortOrder
  }

  export type MarketTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type MarketTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumQuestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestType | EnumQuestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestTypeFilter<$PrismaModel> | $Enums.QuestType
  }

  export type NPCNullableScalarRelationFilter = {
    is?: NPCWhereInput | null
    isNot?: NPCWhereInput | null
  }

  export type QuestCountOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    questType?: SortOrder
    reward?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestMaxOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    questType?: SortOrder
    reward?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestMinOrderByAggregateInput = {
    id?: SortOrder
    npcId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    questType?: SortOrder
    reward?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumQuestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestType | EnumQuestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PlayerCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    connect?: PlayerWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    connect?: PlayerWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCreatedByInput | PostUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCreatedByInput | PostUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCreatedByInput | PostUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PlayerUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    upsert?: PlayerUpsertWithoutUserInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutUserInput, PlayerUpdateWithoutUserInput>, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCreatedByInput | PostUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCreatedByInput | PostUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCreatedByInput | PostUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput
    upsert?: PlayerUpsertWithoutUserInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutUserInput, PlayerUpdateWithoutUserInput>, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutPlayerInput = {
    create?: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerStatsCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    connect?: PlayerStatsWhereUniqueInput
  }

  export type MapPositionCreateNestedOneWithoutPlayerInput = {
    create?: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MapPositionCreateOrConnectWithoutPlayerInput
    connect?: MapPositionWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutPlayerInput = {
    create?: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput> | InventoryItemCreateWithoutPlayerInput[] | InventoryItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPlayerInput | InventoryItemCreateOrConnectWithoutPlayerInput[]
    createMany?: InventoryItemCreateManyPlayerInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type EquipmentCreateNestedOneWithoutPlayerInput = {
    create?: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerInput
    connect?: EquipmentWhereUniqueInput
  }

  export type OccupationCreateNestedOneWithoutPlayerInput = {
    create?: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: OccupationCreateOrConnectWithoutPlayerInput
    connect?: OccupationWhereUniqueInput
  }

  export type GuildMemberCreateNestedOneWithoutPlayerInput = {
    create?: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: GuildMemberCreateOrConnectWithoutPlayerInput
    connect?: GuildMemberWhereUniqueInput
  }

  export type BankAccountCreateNestedOneWithoutPlayerInput = {
    create?: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutPlayerInput
    connect?: BankAccountWhereUniqueInput
  }

  export type MarketListingCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput> | MarketListingCreateWithoutPlayerInput[] | MarketListingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutPlayerInput | MarketListingCreateOrConnectWithoutPlayerInput[]
    createMany?: MarketListingCreateManyPlayerInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type CombatLogCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput> | CombatLogCreateWithoutPlayerInput[] | CombatLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutPlayerInput | CombatLogCreateOrConnectWithoutPlayerInput[]
    createMany?: CombatLogCreateManyPlayerInputEnvelope
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
  }

  export type DeathLogCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput> | DeathLogCreateWithoutPlayerInput[] | DeathLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DeathLogCreateOrConnectWithoutPlayerInput | DeathLogCreateOrConnectWithoutPlayerInput[]
    createMany?: DeathLogCreateManyPlayerInputEnvelope
    connect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
  }

  export type PlayerSkillCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    connect?: PlayerStatsWhereUniqueInput
  }

  export type MapPositionUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MapPositionCreateOrConnectWithoutPlayerInput
    connect?: MapPositionWhereUniqueInput
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput> | InventoryItemCreateWithoutPlayerInput[] | InventoryItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPlayerInput | InventoryItemCreateOrConnectWithoutPlayerInput[]
    createMany?: InventoryItemCreateManyPlayerInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerInput
    connect?: EquipmentWhereUniqueInput
  }

  export type OccupationUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: OccupationCreateOrConnectWithoutPlayerInput
    connect?: OccupationWhereUniqueInput
  }

  export type GuildMemberUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: GuildMemberCreateOrConnectWithoutPlayerInput
    connect?: GuildMemberWhereUniqueInput
  }

  export type BankAccountUncheckedCreateNestedOneWithoutPlayerInput = {
    create?: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutPlayerInput
    connect?: BankAccountWhereUniqueInput
  }

  export type MarketListingUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput> | MarketListingCreateWithoutPlayerInput[] | MarketListingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutPlayerInput | MarketListingCreateOrConnectWithoutPlayerInput[]
    createMany?: MarketListingCreateManyPlayerInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type CombatLogUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput> | CombatLogCreateWithoutPlayerInput[] | CombatLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutPlayerInput | CombatLogCreateOrConnectWithoutPlayerInput[]
    createMany?: CombatLogCreateManyPlayerInputEnvelope
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
  }

  export type DeathLogUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput> | DeathLogCreateWithoutPlayerInput[] | DeathLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DeathLogCreateOrConnectWithoutPlayerInput | DeathLogCreateOrConnectWithoutPlayerInput[]
    createMany?: DeathLogCreateManyPlayerInputEnvelope
    connect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
  }

  export type PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPlayerNestedInput = {
    create?: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerInput
    upsert?: UserUpsertWithoutPlayerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerInput, UserUpdateWithoutPlayerInput>, UserUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerStatsUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    upsert?: PlayerStatsUpsertWithoutPlayerInput
    disconnect?: PlayerStatsWhereInput | boolean
    delete?: PlayerStatsWhereInput | boolean
    connect?: PlayerStatsWhereUniqueInput
    update?: XOR<XOR<PlayerStatsUpdateToOneWithWhereWithoutPlayerInput, PlayerStatsUpdateWithoutPlayerInput>, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type MapPositionUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MapPositionCreateOrConnectWithoutPlayerInput
    upsert?: MapPositionUpsertWithoutPlayerInput
    disconnect?: MapPositionWhereInput | boolean
    delete?: MapPositionWhereInput | boolean
    connect?: MapPositionWhereUniqueInput
    update?: XOR<XOR<MapPositionUpdateToOneWithWhereWithoutPlayerInput, MapPositionUpdateWithoutPlayerInput>, MapPositionUncheckedUpdateWithoutPlayerInput>
  }

  export type InventoryItemUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput> | InventoryItemCreateWithoutPlayerInput[] | InventoryItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPlayerInput | InventoryItemCreateOrConnectWithoutPlayerInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutPlayerInput | InventoryItemUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: InventoryItemCreateManyPlayerInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutPlayerInput | InventoryItemUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutPlayerInput | InventoryItemUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type EquipmentUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerInput
    upsert?: EquipmentUpsertWithoutPlayerInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutPlayerInput, EquipmentUpdateWithoutPlayerInput>, EquipmentUncheckedUpdateWithoutPlayerInput>
  }

  export type OccupationUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: OccupationCreateOrConnectWithoutPlayerInput
    upsert?: OccupationUpsertWithoutPlayerInput
    disconnect?: OccupationWhereInput | boolean
    delete?: OccupationWhereInput | boolean
    connect?: OccupationWhereUniqueInput
    update?: XOR<XOR<OccupationUpdateToOneWithWhereWithoutPlayerInput, OccupationUpdateWithoutPlayerInput>, OccupationUncheckedUpdateWithoutPlayerInput>
  }

  export type GuildMemberUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: GuildMemberCreateOrConnectWithoutPlayerInput
    upsert?: GuildMemberUpsertWithoutPlayerInput
    disconnect?: GuildMemberWhereInput | boolean
    delete?: GuildMemberWhereInput | boolean
    connect?: GuildMemberWhereUniqueInput
    update?: XOR<XOR<GuildMemberUpdateToOneWithWhereWithoutPlayerInput, GuildMemberUpdateWithoutPlayerInput>, GuildMemberUncheckedUpdateWithoutPlayerInput>
  }

  export type BankAccountUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutPlayerInput
    upsert?: BankAccountUpsertWithoutPlayerInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutPlayerInput, BankAccountUpdateWithoutPlayerInput>, BankAccountUncheckedUpdateWithoutPlayerInput>
  }

  export type MarketListingUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput> | MarketListingCreateWithoutPlayerInput[] | MarketListingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutPlayerInput | MarketListingCreateOrConnectWithoutPlayerInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutPlayerInput | MarketListingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MarketListingCreateManyPlayerInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutPlayerInput | MarketListingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutPlayerInput | MarketListingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type CombatLogUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput> | CombatLogCreateWithoutPlayerInput[] | CombatLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutPlayerInput | CombatLogCreateOrConnectWithoutPlayerInput[]
    upsert?: CombatLogUpsertWithWhereUniqueWithoutPlayerInput | CombatLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CombatLogCreateManyPlayerInputEnvelope
    set?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    disconnect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    delete?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    update?: CombatLogUpdateWithWhereUniqueWithoutPlayerInput | CombatLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CombatLogUpdateManyWithWhereWithoutPlayerInput | CombatLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
  }

  export type DeathLogUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput> | DeathLogCreateWithoutPlayerInput[] | DeathLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DeathLogCreateOrConnectWithoutPlayerInput | DeathLogCreateOrConnectWithoutPlayerInput[]
    upsert?: DeathLogUpsertWithWhereUniqueWithoutPlayerInput | DeathLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DeathLogCreateManyPlayerInputEnvelope
    set?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    disconnect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    delete?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    connect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    update?: DeathLogUpdateWithWhereUniqueWithoutPlayerInput | DeathLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DeathLogUpdateManyWithWhereWithoutPlayerInput | DeathLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DeathLogScalarWhereInput | DeathLogScalarWhereInput[]
  }

  export type PlayerSkillUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutPlayerInput | PlayerSkillUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: PlayerStatsCreateOrConnectWithoutPlayerInput
    upsert?: PlayerStatsUpsertWithoutPlayerInput
    disconnect?: PlayerStatsWhereInput | boolean
    delete?: PlayerStatsWhereInput | boolean
    connect?: PlayerStatsWhereUniqueInput
    update?: XOR<XOR<PlayerStatsUpdateToOneWithWhereWithoutPlayerInput, PlayerStatsUpdateWithoutPlayerInput>, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type MapPositionUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: MapPositionCreateOrConnectWithoutPlayerInput
    upsert?: MapPositionUpsertWithoutPlayerInput
    disconnect?: MapPositionWhereInput | boolean
    delete?: MapPositionWhereInput | boolean
    connect?: MapPositionWhereUniqueInput
    update?: XOR<XOR<MapPositionUpdateToOneWithWhereWithoutPlayerInput, MapPositionUpdateWithoutPlayerInput>, MapPositionUncheckedUpdateWithoutPlayerInput>
  }

  export type InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput> | InventoryItemCreateWithoutPlayerInput[] | InventoryItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutPlayerInput | InventoryItemCreateOrConnectWithoutPlayerInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutPlayerInput | InventoryItemUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: InventoryItemCreateManyPlayerInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutPlayerInput | InventoryItemUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutPlayerInput | InventoryItemUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlayerInput
    upsert?: EquipmentUpsertWithoutPlayerInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutPlayerInput, EquipmentUpdateWithoutPlayerInput>, EquipmentUncheckedUpdateWithoutPlayerInput>
  }

  export type OccupationUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: OccupationCreateOrConnectWithoutPlayerInput
    upsert?: OccupationUpsertWithoutPlayerInput
    disconnect?: OccupationWhereInput | boolean
    delete?: OccupationWhereInput | boolean
    connect?: OccupationWhereUniqueInput
    update?: XOR<XOR<OccupationUpdateToOneWithWhereWithoutPlayerInput, OccupationUpdateWithoutPlayerInput>, OccupationUncheckedUpdateWithoutPlayerInput>
  }

  export type GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: GuildMemberCreateOrConnectWithoutPlayerInput
    upsert?: GuildMemberUpsertWithoutPlayerInput
    disconnect?: GuildMemberWhereInput | boolean
    delete?: GuildMemberWhereInput | boolean
    connect?: GuildMemberWhereUniqueInput
    update?: XOR<XOR<GuildMemberUpdateToOneWithWhereWithoutPlayerInput, GuildMemberUpdateWithoutPlayerInput>, GuildMemberUncheckedUpdateWithoutPlayerInput>
  }

  export type BankAccountUncheckedUpdateOneWithoutPlayerNestedInput = {
    create?: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutPlayerInput
    upsert?: BankAccountUpsertWithoutPlayerInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutPlayerInput, BankAccountUpdateWithoutPlayerInput>, BankAccountUncheckedUpdateWithoutPlayerInput>
  }

  export type MarketListingUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput> | MarketListingCreateWithoutPlayerInput[] | MarketListingUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutPlayerInput | MarketListingCreateOrConnectWithoutPlayerInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutPlayerInput | MarketListingUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MarketListingCreateManyPlayerInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutPlayerInput | MarketListingUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutPlayerInput | MarketListingUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type CombatLogUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput> | CombatLogCreateWithoutPlayerInput[] | CombatLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutPlayerInput | CombatLogCreateOrConnectWithoutPlayerInput[]
    upsert?: CombatLogUpsertWithWhereUniqueWithoutPlayerInput | CombatLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CombatLogCreateManyPlayerInputEnvelope
    set?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    disconnect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    delete?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    update?: CombatLogUpdateWithWhereUniqueWithoutPlayerInput | CombatLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CombatLogUpdateManyWithWhereWithoutPlayerInput | CombatLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
  }

  export type DeathLogUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput> | DeathLogCreateWithoutPlayerInput[] | DeathLogUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DeathLogCreateOrConnectWithoutPlayerInput | DeathLogCreateOrConnectWithoutPlayerInput[]
    upsert?: DeathLogUpsertWithWhereUniqueWithoutPlayerInput | DeathLogUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DeathLogCreateManyPlayerInputEnvelope
    set?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    disconnect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    delete?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    connect?: DeathLogWhereUniqueInput | DeathLogWhereUniqueInput[]
    update?: DeathLogUpdateWithWhereUniqueWithoutPlayerInput | DeathLogUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DeathLogUpdateManyWithWhereWithoutPlayerInput | DeathLogUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DeathLogScalarWhereInput | DeathLogScalarWhereInput[]
  }

  export type PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput> | PlayerSkillCreateWithoutPlayerInput[] | PlayerSkillUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerSkillCreateOrConnectWithoutPlayerInput | PlayerSkillCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput | PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerSkillCreateManyPlayerInputEnvelope
    set?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    disconnect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    delete?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    connect?: PlayerSkillWhereUniqueInput | PlayerSkillWhereUniqueInput[]
    update?: PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput | PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerSkillUpdateManyWithWhereWithoutPlayerInput | PlayerSkillUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutStatsInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutStatsInput
    upsert?: PlayerUpsertWithoutStatsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutStatsInput, PlayerUpdateWithoutStatsInput>, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type MapPositionCreateNestedManyWithoutTileInput = {
    create?: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput> | MapPositionCreateWithoutTileInput[] | MapPositionUncheckedCreateWithoutTileInput[]
    connectOrCreate?: MapPositionCreateOrConnectWithoutTileInput | MapPositionCreateOrConnectWithoutTileInput[]
    createMany?: MapPositionCreateManyTileInputEnvelope
    connect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
  }

  export type NPCCreateNestedManyWithoutTileInput = {
    create?: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput> | NPCCreateWithoutTileInput[] | NPCUncheckedCreateWithoutTileInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutTileInput | NPCCreateOrConnectWithoutTileInput[]
    createMany?: NPCCreateManyTileInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutTileInput = {
    create?: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput> | EncounterCreateWithoutTileInput[] | EncounterUncheckedCreateWithoutTileInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutTileInput | EncounterCreateOrConnectWithoutTileInput[]
    createMany?: EncounterCreateManyTileInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type MapPositionUncheckedCreateNestedManyWithoutTileInput = {
    create?: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput> | MapPositionCreateWithoutTileInput[] | MapPositionUncheckedCreateWithoutTileInput[]
    connectOrCreate?: MapPositionCreateOrConnectWithoutTileInput | MapPositionCreateOrConnectWithoutTileInput[]
    createMany?: MapPositionCreateManyTileInputEnvelope
    connect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
  }

  export type NPCUncheckedCreateNestedManyWithoutTileInput = {
    create?: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput> | NPCCreateWithoutTileInput[] | NPCUncheckedCreateWithoutTileInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutTileInput | NPCCreateOrConnectWithoutTileInput[]
    createMany?: NPCCreateManyTileInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutTileInput = {
    create?: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput> | EncounterCreateWithoutTileInput[] | EncounterUncheckedCreateWithoutTileInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutTileInput | EncounterCreateOrConnectWithoutTileInput[]
    createMany?: EncounterCreateManyTileInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EnumTileTypeFieldUpdateOperationsInput = {
    set?: $Enums.TileType
  }

  export type EnumZoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZoneType
  }

  export type NullableEnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType | null
  }

  export type MapPositionUpdateManyWithoutTileNestedInput = {
    create?: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput> | MapPositionCreateWithoutTileInput[] | MapPositionUncheckedCreateWithoutTileInput[]
    connectOrCreate?: MapPositionCreateOrConnectWithoutTileInput | MapPositionCreateOrConnectWithoutTileInput[]
    upsert?: MapPositionUpsertWithWhereUniqueWithoutTileInput | MapPositionUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: MapPositionCreateManyTileInputEnvelope
    set?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    disconnect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    delete?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    connect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    update?: MapPositionUpdateWithWhereUniqueWithoutTileInput | MapPositionUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: MapPositionUpdateManyWithWhereWithoutTileInput | MapPositionUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: MapPositionScalarWhereInput | MapPositionScalarWhereInput[]
  }

  export type NPCUpdateManyWithoutTileNestedInput = {
    create?: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput> | NPCCreateWithoutTileInput[] | NPCUncheckedCreateWithoutTileInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutTileInput | NPCCreateOrConnectWithoutTileInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutTileInput | NPCUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: NPCCreateManyTileInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutTileInput | NPCUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutTileInput | NPCUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutTileNestedInput = {
    create?: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput> | EncounterCreateWithoutTileInput[] | EncounterUncheckedCreateWithoutTileInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutTileInput | EncounterCreateOrConnectWithoutTileInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutTileInput | EncounterUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: EncounterCreateManyTileInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutTileInput | EncounterUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutTileInput | EncounterUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type MapPositionUncheckedUpdateManyWithoutTileNestedInput = {
    create?: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput> | MapPositionCreateWithoutTileInput[] | MapPositionUncheckedCreateWithoutTileInput[]
    connectOrCreate?: MapPositionCreateOrConnectWithoutTileInput | MapPositionCreateOrConnectWithoutTileInput[]
    upsert?: MapPositionUpsertWithWhereUniqueWithoutTileInput | MapPositionUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: MapPositionCreateManyTileInputEnvelope
    set?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    disconnect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    delete?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    connect?: MapPositionWhereUniqueInput | MapPositionWhereUniqueInput[]
    update?: MapPositionUpdateWithWhereUniqueWithoutTileInput | MapPositionUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: MapPositionUpdateManyWithWhereWithoutTileInput | MapPositionUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: MapPositionScalarWhereInput | MapPositionScalarWhereInput[]
  }

  export type NPCUncheckedUpdateManyWithoutTileNestedInput = {
    create?: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput> | NPCCreateWithoutTileInput[] | NPCUncheckedCreateWithoutTileInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutTileInput | NPCCreateOrConnectWithoutTileInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutTileInput | NPCUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: NPCCreateManyTileInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutTileInput | NPCUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutTileInput | NPCUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutTileNestedInput = {
    create?: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput> | EncounterCreateWithoutTileInput[] | EncounterUncheckedCreateWithoutTileInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutTileInput | EncounterCreateOrConnectWithoutTileInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutTileInput | EncounterUpsertWithWhereUniqueWithoutTileInput[]
    createMany?: EncounterCreateManyTileInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutTileInput | EncounterUpdateWithWhereUniqueWithoutTileInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutTileInput | EncounterUpdateManyWithWhereWithoutTileInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutPositionInput = {
    create?: XOR<PlayerCreateWithoutPositionInput, PlayerUncheckedCreateWithoutPositionInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPositionInput
    connect?: PlayerWhereUniqueInput
  }

  export type MapTileCreateNestedOneWithoutPositionsInput = {
    create?: XOR<MapTileCreateWithoutPositionsInput, MapTileUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutPositionsInput
    connect?: MapTileWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPositionNestedInput = {
    create?: XOR<PlayerCreateWithoutPositionInput, PlayerUncheckedCreateWithoutPositionInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPositionInput
    upsert?: PlayerUpsertWithoutPositionInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPositionInput, PlayerUpdateWithoutPositionInput>, PlayerUncheckedUpdateWithoutPositionInput>
  }

  export type MapTileUpdateOneWithoutPositionsNestedInput = {
    create?: XOR<MapTileCreateWithoutPositionsInput, MapTileUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutPositionsInput
    upsert?: MapTileUpsertWithoutPositionsInput
    disconnect?: MapTileWhereInput | boolean
    delete?: MapTileWhereInput | boolean
    connect?: MapTileWhereUniqueInput
    update?: XOR<XOR<MapTileUpdateToOneWithWhereWithoutPositionsInput, MapTileUpdateWithoutPositionsInput>, MapTileUncheckedUpdateWithoutPositionsInput>
  }

  export type MapTileCreateNestedOneWithoutNpcsInput = {
    create?: XOR<MapTileCreateWithoutNpcsInput, MapTileUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutNpcsInput
    connect?: MapTileWhereUniqueInput
  }

  export type ShopItemCreateNestedManyWithoutNpcInput = {
    create?: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput> | ShopItemCreateWithoutNpcInput[] | ShopItemUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutNpcInput | ShopItemCreateOrConnectWithoutNpcInput[]
    createMany?: ShopItemCreateManyNpcInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutNpcInput = {
    create?: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput> | QuestCreateWithoutNpcInput[] | QuestUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutNpcInput | QuestCreateOrConnectWithoutNpcInput[]
    createMany?: QuestCreateManyNpcInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type ShopItemUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput> | ShopItemCreateWithoutNpcInput[] | ShopItemUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutNpcInput | ShopItemCreateOrConnectWithoutNpcInput[]
    createMany?: ShopItemCreateManyNpcInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput> | QuestCreateWithoutNpcInput[] | QuestUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutNpcInput | QuestCreateOrConnectWithoutNpcInput[]
    createMany?: QuestCreateManyNpcInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type EnumNPCTypeFieldUpdateOperationsInput = {
    set?: $Enums.NPCType
  }

  export type MapTileUpdateOneWithoutNpcsNestedInput = {
    create?: XOR<MapTileCreateWithoutNpcsInput, MapTileUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutNpcsInput
    upsert?: MapTileUpsertWithoutNpcsInput
    disconnect?: MapTileWhereInput | boolean
    delete?: MapTileWhereInput | boolean
    connect?: MapTileWhereUniqueInput
    update?: XOR<XOR<MapTileUpdateToOneWithWhereWithoutNpcsInput, MapTileUpdateWithoutNpcsInput>, MapTileUncheckedUpdateWithoutNpcsInput>
  }

  export type ShopItemUpdateManyWithoutNpcNestedInput = {
    create?: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput> | ShopItemCreateWithoutNpcInput[] | ShopItemUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutNpcInput | ShopItemCreateOrConnectWithoutNpcInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutNpcInput | ShopItemUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: ShopItemCreateManyNpcInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutNpcInput | ShopItemUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutNpcInput | ShopItemUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutNpcNestedInput = {
    create?: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput> | QuestCreateWithoutNpcInput[] | QuestUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutNpcInput | QuestCreateOrConnectWithoutNpcInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutNpcInput | QuestUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: QuestCreateManyNpcInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutNpcInput | QuestUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutNpcInput | QuestUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type ShopItemUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput> | ShopItemCreateWithoutNpcInput[] | ShopItemUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutNpcInput | ShopItemCreateOrConnectWithoutNpcInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutNpcInput | ShopItemUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: ShopItemCreateManyNpcInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutNpcInput | ShopItemUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutNpcInput | ShopItemUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput> | QuestCreateWithoutNpcInput[] | QuestUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutNpcInput | QuestCreateOrConnectWithoutNpcInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutNpcInput | QuestUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: QuestCreateManyNpcInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutNpcInput | QuestUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutNpcInput | QuestUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type NPCCreateNestedOneWithoutShopItemsInput = {
    create?: XOR<NPCCreateWithoutShopItemsInput, NPCUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutShopItemsInput
    connect?: NPCWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutShopItemsInput = {
    create?: XOR<ItemCreateWithoutShopItemsInput, ItemUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutShopItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type NPCUpdateOneRequiredWithoutShopItemsNestedInput = {
    create?: XOR<NPCCreateWithoutShopItemsInput, NPCUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutShopItemsInput
    upsert?: NPCUpsertWithoutShopItemsInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutShopItemsInput, NPCUpdateWithoutShopItemsInput>, NPCUncheckedUpdateWithoutShopItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutShopItemsNestedInput = {
    create?: XOR<ItemCreateWithoutShopItemsInput, ItemUncheckedCreateWithoutShopItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutShopItemsInput
    upsert?: ItemUpsertWithoutShopItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutShopItemsInput, ItemUpdateWithoutShopItemsInput>, ItemUncheckedUpdateWithoutShopItemsInput>
  }

  export type InventoryItemCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ShopItemCreateNestedManyWithoutItemInput = {
    create?: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput> | ShopItemCreateWithoutItemInput[] | ShopItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutItemInput | ShopItemCreateOrConnectWithoutItemInput[]
    createMany?: ShopItemCreateManyItemInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type MarketListingCreateNestedManyWithoutItemInput = {
    create?: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput> | MarketListingCreateWithoutItemInput[] | MarketListingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutItemInput | MarketListingCreateOrConnectWithoutItemInput[]
    createMany?: MarketListingCreateManyItemInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutWeaponInput = {
    create?: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput> | EquipmentCreateWithoutWeaponInput[] | EquipmentUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutWeaponInput | EquipmentCreateOrConnectWithoutWeaponInput[]
    createMany?: EquipmentCreateManyWeaponInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutHeadInput = {
    create?: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput> | EquipmentCreateWithoutHeadInput[] | EquipmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutHeadInput | EquipmentCreateOrConnectWithoutHeadInput[]
    createMany?: EquipmentCreateManyHeadInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutChestInput = {
    create?: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput> | EquipmentCreateWithoutChestInput[] | EquipmentUncheckedCreateWithoutChestInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutChestInput | EquipmentCreateOrConnectWithoutChestInput[]
    createMany?: EquipmentCreateManyChestInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutLegsInput = {
    create?: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput> | EquipmentCreateWithoutLegsInput[] | EquipmentUncheckedCreateWithoutLegsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLegsInput | EquipmentCreateOrConnectWithoutLegsInput[]
    createMany?: EquipmentCreateManyLegsInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutFeetInput = {
    create?: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput> | EquipmentCreateWithoutFeetInput[] | EquipmentUncheckedCreateWithoutFeetInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutFeetInput | EquipmentCreateOrConnectWithoutFeetInput[]
    createMany?: EquipmentCreateManyFeetInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutAccessory1Input = {
    create?: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input> | EquipmentCreateWithoutAccessory1Input[] | EquipmentUncheckedCreateWithoutAccessory1Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory1Input | EquipmentCreateOrConnectWithoutAccessory1Input[]
    createMany?: EquipmentCreateManyAccessory1InputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutAccessory2Input = {
    create?: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input> | EquipmentCreateWithoutAccessory2Input[] | EquipmentUncheckedCreateWithoutAccessory2Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory2Input | EquipmentCreateOrConnectWithoutAccessory2Input[]
    createMany?: EquipmentCreateManyAccessory2InputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type BankVaultItemCreateNestedManyWithoutItemInput = {
    create?: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput> | BankVaultItemCreateWithoutItemInput[] | BankVaultItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutItemInput | BankVaultItemCreateOrConnectWithoutItemInput[]
    createMany?: BankVaultItemCreateManyItemInputEnvelope
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ShopItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput> | ShopItemCreateWithoutItemInput[] | ShopItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutItemInput | ShopItemCreateOrConnectWithoutItemInput[]
    createMany?: ShopItemCreateManyItemInputEnvelope
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
  }

  export type MarketListingUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput> | MarketListingCreateWithoutItemInput[] | MarketListingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutItemInput | MarketListingCreateOrConnectWithoutItemInput[]
    createMany?: MarketListingCreateManyItemInputEnvelope
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput> | EquipmentCreateWithoutWeaponInput[] | EquipmentUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutWeaponInput | EquipmentCreateOrConnectWithoutWeaponInput[]
    createMany?: EquipmentCreateManyWeaponInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutHeadInput = {
    create?: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput> | EquipmentCreateWithoutHeadInput[] | EquipmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutHeadInput | EquipmentCreateOrConnectWithoutHeadInput[]
    createMany?: EquipmentCreateManyHeadInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutChestInput = {
    create?: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput> | EquipmentCreateWithoutChestInput[] | EquipmentUncheckedCreateWithoutChestInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutChestInput | EquipmentCreateOrConnectWithoutChestInput[]
    createMany?: EquipmentCreateManyChestInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutLegsInput = {
    create?: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput> | EquipmentCreateWithoutLegsInput[] | EquipmentUncheckedCreateWithoutLegsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLegsInput | EquipmentCreateOrConnectWithoutLegsInput[]
    createMany?: EquipmentCreateManyLegsInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutFeetInput = {
    create?: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput> | EquipmentCreateWithoutFeetInput[] | EquipmentUncheckedCreateWithoutFeetInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutFeetInput | EquipmentCreateOrConnectWithoutFeetInput[]
    createMany?: EquipmentCreateManyFeetInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutAccessory1Input = {
    create?: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input> | EquipmentCreateWithoutAccessory1Input[] | EquipmentUncheckedCreateWithoutAccessory1Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory1Input | EquipmentCreateOrConnectWithoutAccessory1Input[]
    createMany?: EquipmentCreateManyAccessory1InputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutAccessory2Input = {
    create?: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input> | EquipmentCreateWithoutAccessory2Input[] | EquipmentUncheckedCreateWithoutAccessory2Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory2Input | EquipmentCreateOrConnectWithoutAccessory2Input[]
    createMany?: EquipmentCreateManyAccessory2InputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type BankVaultItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput> | BankVaultItemCreateWithoutItemInput[] | BankVaultItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutItemInput | BankVaultItemCreateOrConnectWithoutItemInput[]
    createMany?: BankVaultItemCreateManyItemInputEnvelope
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type EnumItemRarityFieldUpdateOperationsInput = {
    set?: $Enums.ItemRarity
  }

  export type NullableEnumEquipmentSlotFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentSlot | null
  }

  export type InventoryItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ShopItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput> | ShopItemCreateWithoutItemInput[] | ShopItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutItemInput | ShopItemCreateOrConnectWithoutItemInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutItemInput | ShopItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ShopItemCreateManyItemInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutItemInput | ShopItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutItemInput | ShopItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type MarketListingUpdateManyWithoutItemNestedInput = {
    create?: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput> | MarketListingCreateWithoutItemInput[] | MarketListingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutItemInput | MarketListingCreateOrConnectWithoutItemInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutItemInput | MarketListingUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MarketListingCreateManyItemInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutItemInput | MarketListingUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutItemInput | MarketListingUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput> | EquipmentCreateWithoutWeaponInput[] | EquipmentUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutWeaponInput | EquipmentCreateOrConnectWithoutWeaponInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutWeaponInput | EquipmentUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: EquipmentCreateManyWeaponInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutWeaponInput | EquipmentUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutWeaponInput | EquipmentUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutHeadNestedInput = {
    create?: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput> | EquipmentCreateWithoutHeadInput[] | EquipmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutHeadInput | EquipmentCreateOrConnectWithoutHeadInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutHeadInput | EquipmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: EquipmentCreateManyHeadInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutHeadInput | EquipmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutHeadInput | EquipmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutChestNestedInput = {
    create?: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput> | EquipmentCreateWithoutChestInput[] | EquipmentUncheckedCreateWithoutChestInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutChestInput | EquipmentCreateOrConnectWithoutChestInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutChestInput | EquipmentUpsertWithWhereUniqueWithoutChestInput[]
    createMany?: EquipmentCreateManyChestInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutChestInput | EquipmentUpdateWithWhereUniqueWithoutChestInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutChestInput | EquipmentUpdateManyWithWhereWithoutChestInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutLegsNestedInput = {
    create?: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput> | EquipmentCreateWithoutLegsInput[] | EquipmentUncheckedCreateWithoutLegsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLegsInput | EquipmentCreateOrConnectWithoutLegsInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutLegsInput | EquipmentUpsertWithWhereUniqueWithoutLegsInput[]
    createMany?: EquipmentCreateManyLegsInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutLegsInput | EquipmentUpdateWithWhereUniqueWithoutLegsInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutLegsInput | EquipmentUpdateManyWithWhereWithoutLegsInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutFeetNestedInput = {
    create?: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput> | EquipmentCreateWithoutFeetInput[] | EquipmentUncheckedCreateWithoutFeetInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutFeetInput | EquipmentCreateOrConnectWithoutFeetInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutFeetInput | EquipmentUpsertWithWhereUniqueWithoutFeetInput[]
    createMany?: EquipmentCreateManyFeetInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutFeetInput | EquipmentUpdateWithWhereUniqueWithoutFeetInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutFeetInput | EquipmentUpdateManyWithWhereWithoutFeetInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutAccessory1NestedInput = {
    create?: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input> | EquipmentCreateWithoutAccessory1Input[] | EquipmentUncheckedCreateWithoutAccessory1Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory1Input | EquipmentCreateOrConnectWithoutAccessory1Input[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAccessory1Input | EquipmentUpsertWithWhereUniqueWithoutAccessory1Input[]
    createMany?: EquipmentCreateManyAccessory1InputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAccessory1Input | EquipmentUpdateWithWhereUniqueWithoutAccessory1Input[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAccessory1Input | EquipmentUpdateManyWithWhereWithoutAccessory1Input[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutAccessory2NestedInput = {
    create?: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input> | EquipmentCreateWithoutAccessory2Input[] | EquipmentUncheckedCreateWithoutAccessory2Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory2Input | EquipmentCreateOrConnectWithoutAccessory2Input[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAccessory2Input | EquipmentUpsertWithWhereUniqueWithoutAccessory2Input[]
    createMany?: EquipmentCreateManyAccessory2InputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAccessory2Input | EquipmentUpdateWithWhereUniqueWithoutAccessory2Input[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAccessory2Input | EquipmentUpdateManyWithWhereWithoutAccessory2Input[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type BankVaultItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput> | BankVaultItemCreateWithoutItemInput[] | BankVaultItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutItemInput | BankVaultItemCreateOrConnectWithoutItemInput[]
    upsert?: BankVaultItemUpsertWithWhereUniqueWithoutItemInput | BankVaultItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BankVaultItemCreateManyItemInputEnvelope
    set?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    disconnect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    delete?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    update?: BankVaultItemUpdateWithWhereUniqueWithoutItemInput | BankVaultItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BankVaultItemUpdateManyWithWhereWithoutItemInput | BankVaultItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ShopItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput> | ShopItemCreateWithoutItemInput[] | ShopItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ShopItemCreateOrConnectWithoutItemInput | ShopItemCreateOrConnectWithoutItemInput[]
    upsert?: ShopItemUpsertWithWhereUniqueWithoutItemInput | ShopItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ShopItemCreateManyItemInputEnvelope
    set?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    disconnect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    delete?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    connect?: ShopItemWhereUniqueInput | ShopItemWhereUniqueInput[]
    update?: ShopItemUpdateWithWhereUniqueWithoutItemInput | ShopItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ShopItemUpdateManyWithWhereWithoutItemInput | ShopItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
  }

  export type MarketListingUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput> | MarketListingCreateWithoutItemInput[] | MarketListingUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketListingCreateOrConnectWithoutItemInput | MarketListingCreateOrConnectWithoutItemInput[]
    upsert?: MarketListingUpsertWithWhereUniqueWithoutItemInput | MarketListingUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MarketListingCreateManyItemInputEnvelope
    set?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    disconnect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    delete?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    connect?: MarketListingWhereUniqueInput | MarketListingWhereUniqueInput[]
    update?: MarketListingUpdateWithWhereUniqueWithoutItemInput | MarketListingUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MarketListingUpdateManyWithWhereWithoutItemInput | MarketListingUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput> | EquipmentCreateWithoutWeaponInput[] | EquipmentUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutWeaponInput | EquipmentCreateOrConnectWithoutWeaponInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutWeaponInput | EquipmentUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: EquipmentCreateManyWeaponInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutWeaponInput | EquipmentUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutWeaponInput | EquipmentUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutHeadNestedInput = {
    create?: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput> | EquipmentCreateWithoutHeadInput[] | EquipmentUncheckedCreateWithoutHeadInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutHeadInput | EquipmentCreateOrConnectWithoutHeadInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutHeadInput | EquipmentUpsertWithWhereUniqueWithoutHeadInput[]
    createMany?: EquipmentCreateManyHeadInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutHeadInput | EquipmentUpdateWithWhereUniqueWithoutHeadInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutHeadInput | EquipmentUpdateManyWithWhereWithoutHeadInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutChestNestedInput = {
    create?: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput> | EquipmentCreateWithoutChestInput[] | EquipmentUncheckedCreateWithoutChestInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutChestInput | EquipmentCreateOrConnectWithoutChestInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutChestInput | EquipmentUpsertWithWhereUniqueWithoutChestInput[]
    createMany?: EquipmentCreateManyChestInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutChestInput | EquipmentUpdateWithWhereUniqueWithoutChestInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutChestInput | EquipmentUpdateManyWithWhereWithoutChestInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutLegsNestedInput = {
    create?: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput> | EquipmentCreateWithoutLegsInput[] | EquipmentUncheckedCreateWithoutLegsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutLegsInput | EquipmentCreateOrConnectWithoutLegsInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutLegsInput | EquipmentUpsertWithWhereUniqueWithoutLegsInput[]
    createMany?: EquipmentCreateManyLegsInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutLegsInput | EquipmentUpdateWithWhereUniqueWithoutLegsInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutLegsInput | EquipmentUpdateManyWithWhereWithoutLegsInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutFeetNestedInput = {
    create?: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput> | EquipmentCreateWithoutFeetInput[] | EquipmentUncheckedCreateWithoutFeetInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutFeetInput | EquipmentCreateOrConnectWithoutFeetInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutFeetInput | EquipmentUpsertWithWhereUniqueWithoutFeetInput[]
    createMany?: EquipmentCreateManyFeetInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutFeetInput | EquipmentUpdateWithWhereUniqueWithoutFeetInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutFeetInput | EquipmentUpdateManyWithWhereWithoutFeetInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput = {
    create?: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input> | EquipmentCreateWithoutAccessory1Input[] | EquipmentUncheckedCreateWithoutAccessory1Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory1Input | EquipmentCreateOrConnectWithoutAccessory1Input[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAccessory1Input | EquipmentUpsertWithWhereUniqueWithoutAccessory1Input[]
    createMany?: EquipmentCreateManyAccessory1InputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAccessory1Input | EquipmentUpdateWithWhereUniqueWithoutAccessory1Input[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAccessory1Input | EquipmentUpdateManyWithWhereWithoutAccessory1Input[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput = {
    create?: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input> | EquipmentCreateWithoutAccessory2Input[] | EquipmentUncheckedCreateWithoutAccessory2Input[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAccessory2Input | EquipmentCreateOrConnectWithoutAccessory2Input[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAccessory2Input | EquipmentUpsertWithWhereUniqueWithoutAccessory2Input[]
    createMany?: EquipmentCreateManyAccessory2InputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAccessory2Input | EquipmentUpdateWithWhereUniqueWithoutAccessory2Input[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAccessory2Input | EquipmentUpdateManyWithWhereWithoutAccessory2Input[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type BankVaultItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput> | BankVaultItemCreateWithoutItemInput[] | BankVaultItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutItemInput | BankVaultItemCreateOrConnectWithoutItemInput[]
    upsert?: BankVaultItemUpsertWithWhereUniqueWithoutItemInput | BankVaultItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BankVaultItemCreateManyItemInputEnvelope
    set?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    disconnect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    delete?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    update?: BankVaultItemUpdateWithWhereUniqueWithoutItemInput | BankVaultItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BankVaultItemUpdateManyWithWhereWithoutItemInput | BankVaultItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutInventoryInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    upsert?: PlayerUpsertWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutInventoryInput, PlayerUpdateWithoutInventoryInput>, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    upsert?: ItemUpsertWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryItemsInput, ItemUpdateWithoutInventoryItemsInput>, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type PlayerCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<PlayerCreateWithoutEquipmentInput, PlayerUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEquipmentInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsWeaponInput = {
    create?: XOR<ItemCreateWithoutEquippedAsWeaponInput, ItemUncheckedCreateWithoutEquippedAsWeaponInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsWeaponInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsHeadInput = {
    create?: XOR<ItemCreateWithoutEquippedAsHeadInput, ItemUncheckedCreateWithoutEquippedAsHeadInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsHeadInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsChestInput = {
    create?: XOR<ItemCreateWithoutEquippedAsChestInput, ItemUncheckedCreateWithoutEquippedAsChestInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsChestInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsLegsInput = {
    create?: XOR<ItemCreateWithoutEquippedAsLegsInput, ItemUncheckedCreateWithoutEquippedAsLegsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsLegsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsFeetInput = {
    create?: XOR<ItemCreateWithoutEquippedAsFeetInput, ItemUncheckedCreateWithoutEquippedAsFeetInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsFeetInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsAccessory1Input = {
    create?: XOR<ItemCreateWithoutEquippedAsAccessory1Input, ItemUncheckedCreateWithoutEquippedAsAccessory1Input>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsAccessory1Input
    connect?: ItemWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutEquippedAsAccessory2Input = {
    create?: XOR<ItemCreateWithoutEquippedAsAccessory2Input, ItemUncheckedCreateWithoutEquippedAsAccessory2Input>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsAccessory2Input
    connect?: ItemWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<PlayerCreateWithoutEquipmentInput, PlayerUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEquipmentInput
    upsert?: PlayerUpsertWithoutEquipmentInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutEquipmentInput, PlayerUpdateWithoutEquipmentInput>, PlayerUncheckedUpdateWithoutEquipmentInput>
  }

  export type ItemUpdateOneWithoutEquippedAsWeaponNestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsWeaponInput, ItemUncheckedCreateWithoutEquippedAsWeaponInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsWeaponInput
    upsert?: ItemUpsertWithoutEquippedAsWeaponInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsWeaponInput, ItemUpdateWithoutEquippedAsWeaponInput>, ItemUncheckedUpdateWithoutEquippedAsWeaponInput>
  }

  export type ItemUpdateOneWithoutEquippedAsHeadNestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsHeadInput, ItemUncheckedCreateWithoutEquippedAsHeadInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsHeadInput
    upsert?: ItemUpsertWithoutEquippedAsHeadInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsHeadInput, ItemUpdateWithoutEquippedAsHeadInput>, ItemUncheckedUpdateWithoutEquippedAsHeadInput>
  }

  export type ItemUpdateOneWithoutEquippedAsChestNestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsChestInput, ItemUncheckedCreateWithoutEquippedAsChestInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsChestInput
    upsert?: ItemUpsertWithoutEquippedAsChestInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsChestInput, ItemUpdateWithoutEquippedAsChestInput>, ItemUncheckedUpdateWithoutEquippedAsChestInput>
  }

  export type ItemUpdateOneWithoutEquippedAsLegsNestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsLegsInput, ItemUncheckedCreateWithoutEquippedAsLegsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsLegsInput
    upsert?: ItemUpsertWithoutEquippedAsLegsInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsLegsInput, ItemUpdateWithoutEquippedAsLegsInput>, ItemUncheckedUpdateWithoutEquippedAsLegsInput>
  }

  export type ItemUpdateOneWithoutEquippedAsFeetNestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsFeetInput, ItemUncheckedCreateWithoutEquippedAsFeetInput>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsFeetInput
    upsert?: ItemUpsertWithoutEquippedAsFeetInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsFeetInput, ItemUpdateWithoutEquippedAsFeetInput>, ItemUncheckedUpdateWithoutEquippedAsFeetInput>
  }

  export type ItemUpdateOneWithoutEquippedAsAccessory1NestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsAccessory1Input, ItemUncheckedCreateWithoutEquippedAsAccessory1Input>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsAccessory1Input
    upsert?: ItemUpsertWithoutEquippedAsAccessory1Input
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsAccessory1Input, ItemUpdateWithoutEquippedAsAccessory1Input>, ItemUncheckedUpdateWithoutEquippedAsAccessory1Input>
  }

  export type ItemUpdateOneWithoutEquippedAsAccessory2NestedInput = {
    create?: XOR<ItemCreateWithoutEquippedAsAccessory2Input, ItemUncheckedCreateWithoutEquippedAsAccessory2Input>
    connectOrCreate?: ItemCreateOrConnectWithoutEquippedAsAccessory2Input
    upsert?: ItemUpsertWithoutEquippedAsAccessory2Input
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutEquippedAsAccessory2Input, ItemUpdateWithoutEquippedAsAccessory2Input>, ItemUncheckedUpdateWithoutEquippedAsAccessory2Input>
  }

  export type PlayerCreateNestedOneWithoutOccupationInput = {
    create?: XOR<PlayerCreateWithoutOccupationInput, PlayerUncheckedCreateWithoutOccupationInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutOccupationInput
    connect?: PlayerWhereUniqueInput
  }

  export type NullableEnumPrimaryOccupationFieldUpdateOperationsInput = {
    set?: $Enums.PrimaryOccupation | null
  }

  export type NullableEnumSecondaryOccupationFieldUpdateOperationsInput = {
    set?: $Enums.SecondaryOccupation | null
  }

  export type PlayerUpdateOneRequiredWithoutOccupationNestedInput = {
    create?: XOR<PlayerCreateWithoutOccupationInput, PlayerUncheckedCreateWithoutOccupationInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutOccupationInput
    upsert?: PlayerUpsertWithoutOccupationInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutOccupationInput, PlayerUpdateWithoutOccupationInput>, PlayerUncheckedUpdateWithoutOccupationInput>
  }

  export type PlayerCreateNestedOneWithoutSkillsInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSkillsInput
    upsert?: PlayerUpsertWithoutSkillsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSkillsInput, PlayerUpdateWithoutSkillsInput>, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type MapTileCreateNestedOneWithoutEncountersInput = {
    create?: XOR<MapTileCreateWithoutEncountersInput, MapTileUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutEncountersInput
    connect?: MapTileWhereUniqueInput
  }

  export type MapTileUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<MapTileCreateWithoutEncountersInput, MapTileUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: MapTileCreateOrConnectWithoutEncountersInput
    upsert?: MapTileUpsertWithoutEncountersInput
    disconnect?: MapTileWhereInput | boolean
    delete?: MapTileWhereInput | boolean
    connect?: MapTileWhereUniqueInput
    update?: XOR<XOR<MapTileUpdateToOneWithWhereWithoutEncountersInput, MapTileUpdateWithoutEncountersInput>, MapTileUncheckedUpdateWithoutEncountersInput>
  }

  export type PlayerCreateNestedOneWithoutCombatLogsInput = {
    create?: XOR<PlayerCreateWithoutCombatLogsInput, PlayerUncheckedCreateWithoutCombatLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCombatLogsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutCombatLogsNestedInput = {
    create?: XOR<PlayerCreateWithoutCombatLogsInput, PlayerUncheckedCreateWithoutCombatLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutCombatLogsInput
    upsert?: PlayerUpsertWithoutCombatLogsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutCombatLogsInput, PlayerUpdateWithoutCombatLogsInput>, PlayerUncheckedUpdateWithoutCombatLogsInput>
  }

  export type PlayerCreateNestedOneWithoutDeathLogsInput = {
    create?: XOR<PlayerCreateWithoutDeathLogsInput, PlayerUncheckedCreateWithoutDeathLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDeathLogsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutDeathLogsNestedInput = {
    create?: XOR<PlayerCreateWithoutDeathLogsInput, PlayerUncheckedCreateWithoutDeathLogsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDeathLogsInput
    upsert?: PlayerUpsertWithoutDeathLogsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutDeathLogsInput, PlayerUpdateWithoutDeathLogsInput>, PlayerUncheckedUpdateWithoutDeathLogsInput>
  }

  export type GuildMemberCreateNestedManyWithoutGuildInput = {
    create?: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput> | GuildMemberCreateWithoutGuildInput[] | GuildMemberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildMemberCreateOrConnectWithoutGuildInput | GuildMemberCreateOrConnectWithoutGuildInput[]
    createMany?: GuildMemberCreateManyGuildInputEnvelope
    connect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
  }

  export type GuildBankCreateNestedOneWithoutGuildInput = {
    create?: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildBankCreateOrConnectWithoutGuildInput
    connect?: GuildBankWhereUniqueInput
  }

  export type GuildQuestCreateNestedManyWithoutGuildInput = {
    create?: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput> | GuildQuestCreateWithoutGuildInput[] | GuildQuestUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildQuestCreateOrConnectWithoutGuildInput | GuildQuestCreateOrConnectWithoutGuildInput[]
    createMany?: GuildQuestCreateManyGuildInputEnvelope
    connect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
  }

  export type GuildMemberUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput> | GuildMemberCreateWithoutGuildInput[] | GuildMemberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildMemberCreateOrConnectWithoutGuildInput | GuildMemberCreateOrConnectWithoutGuildInput[]
    createMany?: GuildMemberCreateManyGuildInputEnvelope
    connect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
  }

  export type GuildBankUncheckedCreateNestedOneWithoutGuildInput = {
    create?: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildBankCreateOrConnectWithoutGuildInput
    connect?: GuildBankWhereUniqueInput
  }

  export type GuildQuestUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput> | GuildQuestCreateWithoutGuildInput[] | GuildQuestUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildQuestCreateOrConnectWithoutGuildInput | GuildQuestCreateOrConnectWithoutGuildInput[]
    createMany?: GuildQuestCreateManyGuildInputEnvelope
    connect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
  }

  export type GuildMemberUpdateManyWithoutGuildNestedInput = {
    create?: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput> | GuildMemberCreateWithoutGuildInput[] | GuildMemberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildMemberCreateOrConnectWithoutGuildInput | GuildMemberCreateOrConnectWithoutGuildInput[]
    upsert?: GuildMemberUpsertWithWhereUniqueWithoutGuildInput | GuildMemberUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: GuildMemberCreateManyGuildInputEnvelope
    set?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    disconnect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    delete?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    connect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    update?: GuildMemberUpdateWithWhereUniqueWithoutGuildInput | GuildMemberUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: GuildMemberUpdateManyWithWhereWithoutGuildInput | GuildMemberUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: GuildMemberScalarWhereInput | GuildMemberScalarWhereInput[]
  }

  export type GuildBankUpdateOneWithoutGuildNestedInput = {
    create?: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildBankCreateOrConnectWithoutGuildInput
    upsert?: GuildBankUpsertWithoutGuildInput
    disconnect?: GuildBankWhereInput | boolean
    delete?: GuildBankWhereInput | boolean
    connect?: GuildBankWhereUniqueInput
    update?: XOR<XOR<GuildBankUpdateToOneWithWhereWithoutGuildInput, GuildBankUpdateWithoutGuildInput>, GuildBankUncheckedUpdateWithoutGuildInput>
  }

  export type GuildQuestUpdateManyWithoutGuildNestedInput = {
    create?: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput> | GuildQuestCreateWithoutGuildInput[] | GuildQuestUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildQuestCreateOrConnectWithoutGuildInput | GuildQuestCreateOrConnectWithoutGuildInput[]
    upsert?: GuildQuestUpsertWithWhereUniqueWithoutGuildInput | GuildQuestUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: GuildQuestCreateManyGuildInputEnvelope
    set?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    disconnect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    delete?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    connect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    update?: GuildQuestUpdateWithWhereUniqueWithoutGuildInput | GuildQuestUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: GuildQuestUpdateManyWithWhereWithoutGuildInput | GuildQuestUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: GuildQuestScalarWhereInput | GuildQuestScalarWhereInput[]
  }

  export type GuildMemberUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput> | GuildMemberCreateWithoutGuildInput[] | GuildMemberUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildMemberCreateOrConnectWithoutGuildInput | GuildMemberCreateOrConnectWithoutGuildInput[]
    upsert?: GuildMemberUpsertWithWhereUniqueWithoutGuildInput | GuildMemberUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: GuildMemberCreateManyGuildInputEnvelope
    set?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    disconnect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    delete?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    connect?: GuildMemberWhereUniqueInput | GuildMemberWhereUniqueInput[]
    update?: GuildMemberUpdateWithWhereUniqueWithoutGuildInput | GuildMemberUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: GuildMemberUpdateManyWithWhereWithoutGuildInput | GuildMemberUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: GuildMemberScalarWhereInput | GuildMemberScalarWhereInput[]
  }

  export type GuildBankUncheckedUpdateOneWithoutGuildNestedInput = {
    create?: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildBankCreateOrConnectWithoutGuildInput
    upsert?: GuildBankUpsertWithoutGuildInput
    disconnect?: GuildBankWhereInput | boolean
    delete?: GuildBankWhereInput | boolean
    connect?: GuildBankWhereUniqueInput
    update?: XOR<XOR<GuildBankUpdateToOneWithWhereWithoutGuildInput, GuildBankUpdateWithoutGuildInput>, GuildBankUncheckedUpdateWithoutGuildInput>
  }

  export type GuildQuestUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput> | GuildQuestCreateWithoutGuildInput[] | GuildQuestUncheckedCreateWithoutGuildInput[]
    connectOrCreate?: GuildQuestCreateOrConnectWithoutGuildInput | GuildQuestCreateOrConnectWithoutGuildInput[]
    upsert?: GuildQuestUpsertWithWhereUniqueWithoutGuildInput | GuildQuestUpsertWithWhereUniqueWithoutGuildInput[]
    createMany?: GuildQuestCreateManyGuildInputEnvelope
    set?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    disconnect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    delete?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    connect?: GuildQuestWhereUniqueInput | GuildQuestWhereUniqueInput[]
    update?: GuildQuestUpdateWithWhereUniqueWithoutGuildInput | GuildQuestUpdateWithWhereUniqueWithoutGuildInput[]
    updateMany?: GuildQuestUpdateManyWithWhereWithoutGuildInput | GuildQuestUpdateManyWithWhereWithoutGuildInput[]
    deleteMany?: GuildQuestScalarWhereInput | GuildQuestScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutGuildMemberInput = {
    create?: XOR<PlayerCreateWithoutGuildMemberInput, PlayerUncheckedCreateWithoutGuildMemberInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuildMemberInput
    connect?: PlayerWhereUniqueInput
  }

  export type GuildCreateNestedOneWithoutMembersInput = {
    create?: XOR<GuildCreateWithoutMembersInput, GuildUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GuildCreateOrConnectWithoutMembersInput
    connect?: GuildWhereUniqueInput
  }

  export type EnumGuildRoleFieldUpdateOperationsInput = {
    set?: $Enums.GuildRole
  }

  export type PlayerUpdateOneRequiredWithoutGuildMemberNestedInput = {
    create?: XOR<PlayerCreateWithoutGuildMemberInput, PlayerUncheckedCreateWithoutGuildMemberInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuildMemberInput
    upsert?: PlayerUpsertWithoutGuildMemberInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutGuildMemberInput, PlayerUpdateWithoutGuildMemberInput>, PlayerUncheckedUpdateWithoutGuildMemberInput>
  }

  export type GuildUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GuildCreateWithoutMembersInput, GuildUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GuildCreateOrConnectWithoutMembersInput
    upsert?: GuildUpsertWithoutMembersInput
    connect?: GuildWhereUniqueInput
    update?: XOR<XOR<GuildUpdateToOneWithWhereWithoutMembersInput, GuildUpdateWithoutMembersInput>, GuildUncheckedUpdateWithoutMembersInput>
  }

  export type GuildCreateNestedOneWithoutBankInput = {
    create?: XOR<GuildCreateWithoutBankInput, GuildUncheckedCreateWithoutBankInput>
    connectOrCreate?: GuildCreateOrConnectWithoutBankInput
    connect?: GuildWhereUniqueInput
  }

  export type GuildUpdateOneRequiredWithoutBankNestedInput = {
    create?: XOR<GuildCreateWithoutBankInput, GuildUncheckedCreateWithoutBankInput>
    connectOrCreate?: GuildCreateOrConnectWithoutBankInput
    upsert?: GuildUpsertWithoutBankInput
    connect?: GuildWhereUniqueInput
    update?: XOR<XOR<GuildUpdateToOneWithWhereWithoutBankInput, GuildUpdateWithoutBankInput>, GuildUncheckedUpdateWithoutBankInput>
  }

  export type GuildCreateNestedOneWithoutQuestsInput = {
    create?: XOR<GuildCreateWithoutQuestsInput, GuildUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutQuestsInput
    connect?: GuildWhereUniqueInput
  }

  export type GuildUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<GuildCreateWithoutQuestsInput, GuildUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutQuestsInput
    upsert?: GuildUpsertWithoutQuestsInput
    connect?: GuildWhereUniqueInput
    update?: XOR<XOR<GuildUpdateToOneWithWhereWithoutQuestsInput, GuildUpdateWithoutQuestsInput>, GuildUncheckedUpdateWithoutQuestsInput>
  }

  export type PlayerCreateNestedOneWithoutBankAccountInput = {
    create?: XOR<PlayerCreateWithoutBankAccountInput, PlayerUncheckedCreateWithoutBankAccountInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBankAccountInput
    connect?: PlayerWhereUniqueInput
  }

  export type BankVaultItemCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput> | BankVaultItemCreateWithoutAccountInput[] | BankVaultItemUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutAccountInput | BankVaultItemCreateOrConnectWithoutAccountInput[]
    createMany?: BankVaultItemCreateManyAccountInputEnvelope
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
  }

  export type BankVaultItemUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput> | BankVaultItemCreateWithoutAccountInput[] | BankVaultItemUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutAccountInput | BankVaultItemCreateOrConnectWithoutAccountInput[]
    createMany?: BankVaultItemCreateManyAccountInputEnvelope
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
  }

  export type PlayerUpdateOneRequiredWithoutBankAccountNestedInput = {
    create?: XOR<PlayerCreateWithoutBankAccountInput, PlayerUncheckedCreateWithoutBankAccountInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutBankAccountInput
    upsert?: PlayerUpsertWithoutBankAccountInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutBankAccountInput, PlayerUpdateWithoutBankAccountInput>, PlayerUncheckedUpdateWithoutBankAccountInput>
  }

  export type BankVaultItemUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput> | BankVaultItemCreateWithoutAccountInput[] | BankVaultItemUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutAccountInput | BankVaultItemCreateOrConnectWithoutAccountInput[]
    upsert?: BankVaultItemUpsertWithWhereUniqueWithoutAccountInput | BankVaultItemUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankVaultItemCreateManyAccountInputEnvelope
    set?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    disconnect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    delete?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    update?: BankVaultItemUpdateWithWhereUniqueWithoutAccountInput | BankVaultItemUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankVaultItemUpdateManyWithWhereWithoutAccountInput | BankVaultItemUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
  }

  export type BankVaultItemUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput> | BankVaultItemCreateWithoutAccountInput[] | BankVaultItemUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankVaultItemCreateOrConnectWithoutAccountInput | BankVaultItemCreateOrConnectWithoutAccountInput[]
    upsert?: BankVaultItemUpsertWithWhereUniqueWithoutAccountInput | BankVaultItemUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankVaultItemCreateManyAccountInputEnvelope
    set?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    disconnect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    delete?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    connect?: BankVaultItemWhereUniqueInput | BankVaultItemWhereUniqueInput[]
    update?: BankVaultItemUpdateWithWhereUniqueWithoutAccountInput | BankVaultItemUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankVaultItemUpdateManyWithWhereWithoutAccountInput | BankVaultItemUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutVaultItemsInput = {
    create?: XOR<BankAccountCreateWithoutVaultItemsInput, BankAccountUncheckedCreateWithoutVaultItemsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutVaultItemsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutBankVaultItemsInput = {
    create?: XOR<ItemCreateWithoutBankVaultItemsInput, ItemUncheckedCreateWithoutBankVaultItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBankVaultItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type BankAccountUpdateOneRequiredWithoutVaultItemsNestedInput = {
    create?: XOR<BankAccountCreateWithoutVaultItemsInput, BankAccountUncheckedCreateWithoutVaultItemsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutVaultItemsInput
    upsert?: BankAccountUpsertWithoutVaultItemsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutVaultItemsInput, BankAccountUpdateWithoutVaultItemsInput>, BankAccountUncheckedUpdateWithoutVaultItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutBankVaultItemsNestedInput = {
    create?: XOR<ItemCreateWithoutBankVaultItemsInput, ItemUncheckedCreateWithoutBankVaultItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBankVaultItemsInput
    upsert?: ItemUpsertWithoutBankVaultItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBankVaultItemsInput, ItemUpdateWithoutBankVaultItemsInput>, ItemUncheckedUpdateWithoutBankVaultItemsInput>
  }

  export type PlayerCreateNestedOneWithoutMarketListingsInput = {
    create?: XOR<PlayerCreateWithoutMarketListingsInput, PlayerUncheckedCreateWithoutMarketListingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketListingsInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutMarketListingsInput = {
    create?: XOR<ItemCreateWithoutMarketListingsInput, ItemUncheckedCreateWithoutMarketListingsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMarketListingsInput
    connect?: ItemWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMarketListingsNestedInput = {
    create?: XOR<PlayerCreateWithoutMarketListingsInput, PlayerUncheckedCreateWithoutMarketListingsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarketListingsInput
    upsert?: PlayerUpsertWithoutMarketListingsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMarketListingsInput, PlayerUpdateWithoutMarketListingsInput>, PlayerUncheckedUpdateWithoutMarketListingsInput>
  }

  export type ItemUpdateOneRequiredWithoutMarketListingsNestedInput = {
    create?: XOR<ItemCreateWithoutMarketListingsInput, ItemUncheckedCreateWithoutMarketListingsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMarketListingsInput
    upsert?: ItemUpsertWithoutMarketListingsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutMarketListingsInput, ItemUpdateWithoutMarketListingsInput>, ItemUncheckedUpdateWithoutMarketListingsInput>
  }

  export type NPCCreateNestedOneWithoutQuestsInput = {
    create?: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInput
    connect?: NPCWhereUniqueInput
  }

  export type EnumQuestTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestType
  }

  export type NPCUpdateOneWithoutQuestsNestedInput = {
    create?: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInput
    upsert?: NPCUpsertWithoutQuestsInput
    disconnect?: NPCWhereInput | boolean
    delete?: NPCWhereInput | boolean
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutQuestsInput, NPCUpdateWithoutQuestsInput>, NPCUncheckedUpdateWithoutQuestsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TileType | EnumTileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTileTypeFilter<$PrismaModel> | $Enums.TileType
  }

  export type NestedEnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type NestedEnumResourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableFilter<$PrismaModel> | $Enums.ResourceType | null
  }

  export type NestedEnumTileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TileType | EnumTileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TileType[] | ListEnumTileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTileTypeWithAggregatesFilter<$PrismaModel> | $Enums.TileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTileTypeFilter<$PrismaModel>
    _max?: NestedEnumTileTypeFilter<$PrismaModel>
  }

  export type NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumResourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNPCTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCType | EnumNPCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNPCTypeFilter<$PrismaModel> | $Enums.NPCType
  }

  export type NestedEnumNPCTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCType | EnumNPCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NPCType[] | ListEnumNPCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNPCTypeWithAggregatesFilter<$PrismaModel> | $Enums.NPCType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNPCTypeFilter<$PrismaModel>
    _max?: NestedEnumNPCTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type NestedEnumEquipmentSlotNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel> | $Enums.EquipmentSlot | null
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentSlot | EnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    in?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EquipmentSlot[] | ListEnumEquipmentSlotFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEquipmentSlotNullableWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentSlot | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
    _max?: NestedEnumEquipmentSlotNullableFilter<$PrismaModel>
  }

  export type NestedEnumPrimaryOccupationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PrimaryOccupation | EnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel> | $Enums.PrimaryOccupation | null
  }

  export type NestedEnumSecondaryOccupationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SecondaryOccupation | EnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel> | $Enums.SecondaryOccupation | null
  }

  export type NestedEnumPrimaryOccupationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrimaryOccupation | EnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PrimaryOccupation[] | ListEnumPrimaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPrimaryOccupationNullableWithAggregatesFilter<$PrismaModel> | $Enums.PrimaryOccupation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel>
    _max?: NestedEnumPrimaryOccupationNullableFilter<$PrismaModel>
  }

  export type NestedEnumSecondaryOccupationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecondaryOccupation | EnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    in?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SecondaryOccupation[] | ListEnumSecondaryOccupationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSecondaryOccupationNullableWithAggregatesFilter<$PrismaModel> | $Enums.SecondaryOccupation | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel>
    _max?: NestedEnumSecondaryOccupationNullableFilter<$PrismaModel>
  }

  export type NestedEnumGuildRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildRole | EnumGuildRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGuildRoleFilter<$PrismaModel> | $Enums.GuildRole
  }

  export type NestedEnumGuildRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildRole | EnumGuildRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GuildRole[] | ListEnumGuildRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGuildRoleWithAggregatesFilter<$PrismaModel> | $Enums.GuildRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuildRoleFilter<$PrismaModel>
    _max?: NestedEnumGuildRoleFilter<$PrismaModel>
  }

  export type NestedEnumQuestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestType | EnumQuestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestTypeFilter<$PrismaModel> | $Enums.QuestType
  }

  export type NestedEnumQuestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestType | EnumQuestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestType[] | ListEnumQuestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    player?: PlayerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    player?: PlayerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
    player?: PlayerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
    player?: PlayerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
    player?: PlayerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
    player?: PlayerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput>
  }

  export type PostCreateManyCreatedByInputEnvelope = {
    data: PostCreateManyCreatedByInput | PostCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutUserInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutUserInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutUserInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCreatedByInput, PostUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCreatedByInput, PostUncheckedUpdateWithoutCreatedByInput>
  }

  export type PostUpdateManyWithWhereWithoutCreatedByInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
  }

  export type PlayerUpsertWithoutUserInput = {
    update: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutUserInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type PlayerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type UserCreateWithoutPlayerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutPlayerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutPlayerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerStatsCreateWithoutPlayerInput = {
    id?: string
    vitality?: number
    strength?: number
    speed?: number
    dexterity?: number
    maxHP?: number
    currentHP?: number
    maxSP?: number
    currentSP?: number
    statPoints?: number
    updatedAt?: Date | string
  }

  export type PlayerStatsUncheckedCreateWithoutPlayerInput = {
    id?: string
    vitality?: number
    strength?: number
    speed?: number
    dexterity?: number
    maxHP?: number
    currentHP?: number
    maxSP?: number
    currentSP?: number
    statPoints?: number
    updatedAt?: Date | string
  }

  export type PlayerStatsCreateOrConnectWithoutPlayerInput = {
    where: PlayerStatsWhereUniqueInput
    create: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
  }

  export type MapPositionCreateWithoutPlayerInput = {
    id?: string
    tileX: number
    tileY: number
    updatedAt?: Date | string
    tile?: MapTileCreateNestedOneWithoutPositionsInput
  }

  export type MapPositionUncheckedCreateWithoutPlayerInput = {
    id?: string
    tileX: number
    tileY: number
    tileId?: number | null
    updatedAt?: Date | string
  }

  export type MapPositionCreateOrConnectWithoutPlayerInput = {
    where: MapPositionWhereUniqueInput
    create: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
  }

  export type InventoryItemCreateWithoutPlayerInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutPlayerInput = {
    id?: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutPlayerInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput>
  }

  export type InventoryItemCreateManyPlayerInputEnvelope = {
    data: InventoryItemCreateManyPlayerInput | InventoryItemCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutPlayerInput = {
    id?: string
    updatedAt?: Date | string
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutPlayerInput = {
    id?: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutPlayerInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
  }

  export type OccupationCreateWithoutPlayerInput = {
    id?: string
    primaryJob?: $Enums.PrimaryOccupation | null
    secondaryJob?: $Enums.SecondaryOccupation | null
    level?: number
    experience?: number
    updatedAt?: Date | string
  }

  export type OccupationUncheckedCreateWithoutPlayerInput = {
    id?: string
    primaryJob?: $Enums.PrimaryOccupation | null
    secondaryJob?: $Enums.SecondaryOccupation | null
    level?: number
    experience?: number
    updatedAt?: Date | string
  }

  export type OccupationCreateOrConnectWithoutPlayerInput = {
    where: OccupationWhereUniqueInput
    create: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
  }

  export type GuildMemberCreateWithoutPlayerInput = {
    id?: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
    guild: GuildCreateNestedOneWithoutMembersInput
  }

  export type GuildMemberUncheckedCreateWithoutPlayerInput = {
    id?: string
    guildId: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
  }

  export type GuildMemberCreateOrConnectWithoutPlayerInput = {
    where: GuildMemberWhereUniqueInput
    create: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
  }

  export type BankAccountCreateWithoutPlayerInput = {
    id?: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
    vaultItems?: BankVaultItemCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUncheckedCreateWithoutPlayerInput = {
    id?: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
    vaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutAccountInput
  }

  export type BankAccountCreateOrConnectWithoutPlayerInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
  }

  export type MarketListingCreateWithoutPlayerInput = {
    id?: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
    item: ItemCreateNestedOneWithoutMarketListingsInput
  }

  export type MarketListingUncheckedCreateWithoutPlayerInput = {
    id?: string
    itemId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type MarketListingCreateOrConnectWithoutPlayerInput = {
    where: MarketListingWhereUniqueInput
    create: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput>
  }

  export type MarketListingCreateManyPlayerInputEnvelope = {
    data: MarketListingCreateManyPlayerInput | MarketListingCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type CombatLogCreateWithoutPlayerInput = {
    id?: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
  }

  export type CombatLogUncheckedCreateWithoutPlayerInput = {
    id?: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
  }

  export type CombatLogCreateOrConnectWithoutPlayerInput = {
    where: CombatLogWhereUniqueInput
    create: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput>
  }

  export type CombatLogCreateManyPlayerInputEnvelope = {
    data: CombatLogCreateManyPlayerInput | CombatLogCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type DeathLogCreateWithoutPlayerInput = {
    id?: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
  }

  export type DeathLogUncheckedCreateWithoutPlayerInput = {
    id?: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
  }

  export type DeathLogCreateOrConnectWithoutPlayerInput = {
    where: DeathLogWhereUniqueInput
    create: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput>
  }

  export type DeathLogCreateManyPlayerInputEnvelope = {
    data: DeathLogCreateManyPlayerInput | DeathLogCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerSkillCreateWithoutPlayerInput = {
    id?: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
  }

  export type PlayerSkillUncheckedCreateWithoutPlayerInput = {
    id?: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
  }

  export type PlayerSkillCreateOrConnectWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    create: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillCreateManyPlayerInputEnvelope = {
    data: PlayerSkillCreateManyPlayerInput | PlayerSkillCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlayerInput = {
    update: XOR<UserUpdateWithoutPlayerInput, UserUncheckedUpdateWithoutPlayerInput>
    create: XOR<UserCreateWithoutPlayerInput, UserUncheckedCreateWithoutPlayerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerInput, UserUncheckedUpdateWithoutPlayerInput>
  }

  export type UserUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type PlayerStatsUpsertWithoutPlayerInput = {
    update: XOR<PlayerStatsUpdateWithoutPlayerInput, PlayerStatsUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerStatsCreateWithoutPlayerInput, PlayerStatsUncheckedCreateWithoutPlayerInput>
    where?: PlayerStatsWhereInput
  }

  export type PlayerStatsUpdateToOneWithWhereWithoutPlayerInput = {
    where?: PlayerStatsWhereInput
    data: XOR<PlayerStatsUpdateWithoutPlayerInput, PlayerStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerStatsUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatsUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vitality?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    maxHP?: IntFieldUpdateOperationsInput | number
    currentHP?: IntFieldUpdateOperationsInput | number
    maxSP?: IntFieldUpdateOperationsInput | number
    currentSP?: IntFieldUpdateOperationsInput | number
    statPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapPositionUpsertWithoutPlayerInput = {
    update: XOR<MapPositionUpdateWithoutPlayerInput, MapPositionUncheckedUpdateWithoutPlayerInput>
    create: XOR<MapPositionCreateWithoutPlayerInput, MapPositionUncheckedCreateWithoutPlayerInput>
    where?: MapPositionWhereInput
  }

  export type MapPositionUpdateToOneWithWhereWithoutPlayerInput = {
    where?: MapPositionWhereInput
    data: XOR<MapPositionUpdateWithoutPlayerInput, MapPositionUncheckedUpdateWithoutPlayerInput>
  }

  export type MapPositionUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tile?: MapTileUpdateOneWithoutPositionsNestedInput
  }

  export type MapPositionUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutPlayerInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutPlayerInput, InventoryItemUncheckedUpdateWithoutPlayerInput>
    create: XOR<InventoryItemCreateWithoutPlayerInput, InventoryItemUncheckedCreateWithoutPlayerInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutPlayerInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutPlayerInput, InventoryItemUncheckedUpdateWithoutPlayerInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutPlayerInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutPlayerInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    playerId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type EquipmentUpsertWithoutPlayerInput = {
    update: XOR<EquipmentUpdateWithoutPlayerInput, EquipmentUncheckedUpdateWithoutPlayerInput>
    create: XOR<EquipmentCreateWithoutPlayerInput, EquipmentUncheckedCreateWithoutPlayerInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutPlayerInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutPlayerInput, EquipmentUncheckedUpdateWithoutPlayerInput>
  }

  export type EquipmentUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationUpsertWithoutPlayerInput = {
    update: XOR<OccupationUpdateWithoutPlayerInput, OccupationUncheckedUpdateWithoutPlayerInput>
    create: XOR<OccupationCreateWithoutPlayerInput, OccupationUncheckedCreateWithoutPlayerInput>
    where?: OccupationWhereInput
  }

  export type OccupationUpdateToOneWithWhereWithoutPlayerInput = {
    where?: OccupationWhereInput
    data: XOR<OccupationUpdateWithoutPlayerInput, OccupationUncheckedUpdateWithoutPlayerInput>
  }

  export type OccupationUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccupationUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryJob?: NullableEnumPrimaryOccupationFieldUpdateOperationsInput | $Enums.PrimaryOccupation | null
    secondaryJob?: NullableEnumSecondaryOccupationFieldUpdateOperationsInput | $Enums.SecondaryOccupation | null
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberUpsertWithoutPlayerInput = {
    update: XOR<GuildMemberUpdateWithoutPlayerInput, GuildMemberUncheckedUpdateWithoutPlayerInput>
    create: XOR<GuildMemberCreateWithoutPlayerInput, GuildMemberUncheckedCreateWithoutPlayerInput>
    where?: GuildMemberWhereInput
  }

  export type GuildMemberUpdateToOneWithWhereWithoutPlayerInput = {
    where?: GuildMemberWhereInput
    data: XOR<GuildMemberUpdateWithoutPlayerInput, GuildMemberUncheckedUpdateWithoutPlayerInput>
  }

  export type GuildMemberUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: GuildUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GuildMemberUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    guildId?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUpsertWithoutPlayerInput = {
    update: XOR<BankAccountUpdateWithoutPlayerInput, BankAccountUncheckedUpdateWithoutPlayerInput>
    create: XOR<BankAccountCreateWithoutPlayerInput, BankAccountUncheckedCreateWithoutPlayerInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutPlayerInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutPlayerInput, BankAccountUncheckedUpdateWithoutPlayerInput>
  }

  export type BankAccountUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultItems?: BankVaultItemUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultItems?: BankVaultItemUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type MarketListingUpsertWithWhereUniqueWithoutPlayerInput = {
    where: MarketListingWhereUniqueInput
    update: XOR<MarketListingUpdateWithoutPlayerInput, MarketListingUncheckedUpdateWithoutPlayerInput>
    create: XOR<MarketListingCreateWithoutPlayerInput, MarketListingUncheckedCreateWithoutPlayerInput>
  }

  export type MarketListingUpdateWithWhereUniqueWithoutPlayerInput = {
    where: MarketListingWhereUniqueInput
    data: XOR<MarketListingUpdateWithoutPlayerInput, MarketListingUncheckedUpdateWithoutPlayerInput>
  }

  export type MarketListingUpdateManyWithWhereWithoutPlayerInput = {
    where: MarketListingScalarWhereInput
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyWithoutPlayerInput>
  }

  export type MarketListingScalarWhereInput = {
    AND?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
    OR?: MarketListingScalarWhereInput[]
    NOT?: MarketListingScalarWhereInput | MarketListingScalarWhereInput[]
    id?: StringFilter<"MarketListing"> | string
    playerId?: StringFilter<"MarketListing"> | string
    itemId?: StringFilter<"MarketListing"> | string
    quantity?: IntFilter<"MarketListing"> | number
    pricePerUnit?: IntFilter<"MarketListing"> | number
    totalPrice?: IntFilter<"MarketListing"> | number
    listingTax?: IntFilter<"MarketListing"> | number
    isActive?: BoolFilter<"MarketListing"> | boolean
    expiresAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketListing"> | Date | string
    soldAt?: DateTimeNullableFilter<"MarketListing"> | Date | string | null
  }

  export type CombatLogUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CombatLogWhereUniqueInput
    update: XOR<CombatLogUpdateWithoutPlayerInput, CombatLogUncheckedUpdateWithoutPlayerInput>
    create: XOR<CombatLogCreateWithoutPlayerInput, CombatLogUncheckedCreateWithoutPlayerInput>
  }

  export type CombatLogUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CombatLogWhereUniqueInput
    data: XOR<CombatLogUpdateWithoutPlayerInput, CombatLogUncheckedUpdateWithoutPlayerInput>
  }

  export type CombatLogUpdateManyWithWhereWithoutPlayerInput = {
    where: CombatLogScalarWhereInput
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyWithoutPlayerInput>
  }

  export type CombatLogScalarWhereInput = {
    AND?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
    OR?: CombatLogScalarWhereInput[]
    NOT?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
    id?: StringFilter<"CombatLog"> | string
    playerId?: StringFilter<"CombatLog"> | string
    encounterId?: StringNullableFilter<"CombatLog"> | string | null
    turnNumber?: IntFilter<"CombatLog"> | number
    action?: StringFilter<"CombatLog"> | string
    result?: StringFilter<"CombatLog"> | string
    createdAt?: DateTimeFilter<"CombatLog"> | Date | string
  }

  export type DeathLogUpsertWithWhereUniqueWithoutPlayerInput = {
    where: DeathLogWhereUniqueInput
    update: XOR<DeathLogUpdateWithoutPlayerInput, DeathLogUncheckedUpdateWithoutPlayerInput>
    create: XOR<DeathLogCreateWithoutPlayerInput, DeathLogUncheckedCreateWithoutPlayerInput>
  }

  export type DeathLogUpdateWithWhereUniqueWithoutPlayerInput = {
    where: DeathLogWhereUniqueInput
    data: XOR<DeathLogUpdateWithoutPlayerInput, DeathLogUncheckedUpdateWithoutPlayerInput>
  }

  export type DeathLogUpdateManyWithWhereWithoutPlayerInput = {
    where: DeathLogScalarWhereInput
    data: XOR<DeathLogUpdateManyMutationInput, DeathLogUncheckedUpdateManyWithoutPlayerInput>
  }

  export type DeathLogScalarWhereInput = {
    AND?: DeathLogScalarWhereInput | DeathLogScalarWhereInput[]
    OR?: DeathLogScalarWhereInput[]
    NOT?: DeathLogScalarWhereInput | DeathLogScalarWhereInput[]
    id?: StringFilter<"DeathLog"> | string
    playerId?: StringFilter<"DeathLog"> | string
    deathCount?: IntFilter<"DeathLog"> | number
    cause?: StringNullableFilter<"DeathLog"> | string | null
    locationX?: IntNullableFilter<"DeathLog"> | number | null
    locationY?: IntNullableFilter<"DeathLog"> | number | null
    createdAt?: DateTimeFilter<"DeathLog"> | Date | string
  }

  export type PlayerSkillUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    update: XOR<PlayerSkillUpdateWithoutPlayerInput, PlayerSkillUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerSkillCreateWithoutPlayerInput, PlayerSkillUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillWhereUniqueInput
    data: XOR<PlayerSkillUpdateWithoutPlayerInput, PlayerSkillUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerSkillScalarWhereInput
    data: XOR<PlayerSkillUpdateManyMutationInput, PlayerSkillUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerSkillScalarWhereInput = {
    AND?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
    OR?: PlayerSkillScalarWhereInput[]
    NOT?: PlayerSkillScalarWhereInput | PlayerSkillScalarWhereInput[]
    id?: StringFilter<"PlayerSkill"> | string
    playerId?: StringFilter<"PlayerSkill"> | string
    skillName?: StringFilter<"PlayerSkill"> | string
    level?: IntFilter<"PlayerSkill"> | number
    experience?: IntFilter<"PlayerSkill"> | number
    createdAt?: DateTimeFilter<"PlayerSkill"> | Date | string
  }

  export type PlayerCreateWithoutStatsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutStatsInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
  }

  export type PlayerUpsertWithoutStatsInput = {
    update: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
    create: XOR<PlayerCreateWithoutStatsInput, PlayerUncheckedCreateWithoutStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutStatsInput, PlayerUncheckedUpdateWithoutStatsInput>
  }

  export type PlayerUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MapPositionCreateWithoutTileInput = {
    id?: string
    tileX: number
    tileY: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutPositionInput
  }

  export type MapPositionUncheckedCreateWithoutTileInput = {
    id?: string
    playerId: string
    tileX: number
    tileY: number
    updatedAt?: Date | string
  }

  export type MapPositionCreateOrConnectWithoutTileInput = {
    where: MapPositionWhereUniqueInput
    create: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput>
  }

  export type MapPositionCreateManyTileInputEnvelope = {
    data: MapPositionCreateManyTileInput | MapPositionCreateManyTileInput[]
    skipDuplicates?: boolean
  }

  export type NPCCreateWithoutTileInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
    shopItems?: ShopItemCreateNestedManyWithoutNpcInput
    quests?: QuestCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutTileInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutNpcInput
    quests?: QuestUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutTileInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput>
  }

  export type NPCCreateManyTileInputEnvelope = {
    data: NPCCreateManyTileInput | NPCCreateManyTileInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutTileInput = {
    id?: string
    tileX: number
    tileY: number
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EncounterUncheckedCreateWithoutTileInput = {
    id?: string
    tileX: number
    tileY: number
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type EncounterCreateOrConnectWithoutTileInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput>
  }

  export type EncounterCreateManyTileInputEnvelope = {
    data: EncounterCreateManyTileInput | EncounterCreateManyTileInput[]
    skipDuplicates?: boolean
  }

  export type MapPositionUpsertWithWhereUniqueWithoutTileInput = {
    where: MapPositionWhereUniqueInput
    update: XOR<MapPositionUpdateWithoutTileInput, MapPositionUncheckedUpdateWithoutTileInput>
    create: XOR<MapPositionCreateWithoutTileInput, MapPositionUncheckedCreateWithoutTileInput>
  }

  export type MapPositionUpdateWithWhereUniqueWithoutTileInput = {
    where: MapPositionWhereUniqueInput
    data: XOR<MapPositionUpdateWithoutTileInput, MapPositionUncheckedUpdateWithoutTileInput>
  }

  export type MapPositionUpdateManyWithWhereWithoutTileInput = {
    where: MapPositionScalarWhereInput
    data: XOR<MapPositionUpdateManyMutationInput, MapPositionUncheckedUpdateManyWithoutTileInput>
  }

  export type MapPositionScalarWhereInput = {
    AND?: MapPositionScalarWhereInput | MapPositionScalarWhereInput[]
    OR?: MapPositionScalarWhereInput[]
    NOT?: MapPositionScalarWhereInput | MapPositionScalarWhereInput[]
    id?: StringFilter<"MapPosition"> | string
    playerId?: StringFilter<"MapPosition"> | string
    tileX?: IntFilter<"MapPosition"> | number
    tileY?: IntFilter<"MapPosition"> | number
    tileId?: IntNullableFilter<"MapPosition"> | number | null
    updatedAt?: DateTimeFilter<"MapPosition"> | Date | string
  }

  export type NPCUpsertWithWhereUniqueWithoutTileInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutTileInput, NPCUncheckedUpdateWithoutTileInput>
    create: XOR<NPCCreateWithoutTileInput, NPCUncheckedCreateWithoutTileInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutTileInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutTileInput, NPCUncheckedUpdateWithoutTileInput>
  }

  export type NPCUpdateManyWithWhereWithoutTileInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutTileInput>
  }

  export type NPCScalarWhereInput = {
    AND?: NPCScalarWhereInput | NPCScalarWhereInput[]
    OR?: NPCScalarWhereInput[]
    NOT?: NPCScalarWhereInput | NPCScalarWhereInput[]
    id?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    npcType?: EnumNPCTypeFilter<"NPC"> | $Enums.NPCType
    tileX?: IntFilter<"NPC"> | number
    tileY?: IntFilter<"NPC"> | number
    tileId?: IntNullableFilter<"NPC"> | number | null
    dialogue?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
  }

  export type EncounterUpsertWithWhereUniqueWithoutTileInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutTileInput, EncounterUncheckedUpdateWithoutTileInput>
    create: XOR<EncounterCreateWithoutTileInput, EncounterUncheckedCreateWithoutTileInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutTileInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutTileInput, EncounterUncheckedUpdateWithoutTileInput>
  }

  export type EncounterUpdateManyWithWhereWithoutTileInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutTileInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    tileX?: IntFilter<"Encounter"> | number
    tileY?: IntFilter<"Encounter"> | number
    tileId?: IntNullableFilter<"Encounter"> | number | null
    enemyType?: StringFilter<"Encounter"> | string
    enemyLevel?: IntFilter<"Encounter"> | number
    isActive?: BoolFilter<"Encounter"> | boolean
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type PlayerCreateWithoutPositionInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPositionInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPositionInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPositionInput, PlayerUncheckedCreateWithoutPositionInput>
  }

  export type MapTileCreateWithoutPositionsInput = {
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    npcs?: NPCCreateNestedManyWithoutTileInput
    encounters?: EncounterCreateNestedManyWithoutTileInput
  }

  export type MapTileUncheckedCreateWithoutPositionsInput = {
    id?: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    npcs?: NPCUncheckedCreateNestedManyWithoutTileInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutTileInput
  }

  export type MapTileCreateOrConnectWithoutPositionsInput = {
    where: MapTileWhereUniqueInput
    create: XOR<MapTileCreateWithoutPositionsInput, MapTileUncheckedCreateWithoutPositionsInput>
  }

  export type PlayerUpsertWithoutPositionInput = {
    update: XOR<PlayerUpdateWithoutPositionInput, PlayerUncheckedUpdateWithoutPositionInput>
    create: XOR<PlayerCreateWithoutPositionInput, PlayerUncheckedCreateWithoutPositionInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPositionInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPositionInput, PlayerUncheckedUpdateWithoutPositionInput>
  }

  export type PlayerUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MapTileUpsertWithoutPositionsInput = {
    update: XOR<MapTileUpdateWithoutPositionsInput, MapTileUncheckedUpdateWithoutPositionsInput>
    create: XOR<MapTileCreateWithoutPositionsInput, MapTileUncheckedCreateWithoutPositionsInput>
    where?: MapTileWhereInput
  }

  export type MapTileUpdateToOneWithWhereWithoutPositionsInput = {
    where?: MapTileWhereInput
    data: XOR<MapTileUpdateWithoutPositionsInput, MapTileUncheckedUpdateWithoutPositionsInput>
  }

  export type MapTileUpdateWithoutPositionsInput = {
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    npcs?: NPCUpdateManyWithoutTileNestedInput
    encounters?: EncounterUpdateManyWithoutTileNestedInput
  }

  export type MapTileUncheckedUpdateWithoutPositionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    npcs?: NPCUncheckedUpdateManyWithoutTileNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutTileNestedInput
  }

  export type MapTileCreateWithoutNpcsInput = {
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionCreateNestedManyWithoutTileInput
    encounters?: EncounterCreateNestedManyWithoutTileInput
  }

  export type MapTileUncheckedCreateWithoutNpcsInput = {
    id?: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionUncheckedCreateNestedManyWithoutTileInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutTileInput
  }

  export type MapTileCreateOrConnectWithoutNpcsInput = {
    where: MapTileWhereUniqueInput
    create: XOR<MapTileCreateWithoutNpcsInput, MapTileUncheckedCreateWithoutNpcsInput>
  }

  export type ShopItemCreateWithoutNpcInput = {
    id?: string
    price: number
    stock?: number | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutShopItemsInput
  }

  export type ShopItemUncheckedCreateWithoutNpcInput = {
    id?: string
    itemId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type ShopItemCreateOrConnectWithoutNpcInput = {
    where: ShopItemWhereUniqueInput
    create: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput>
  }

  export type ShopItemCreateManyNpcInputEnvelope = {
    data: ShopItemCreateManyNpcInput | ShopItemCreateManyNpcInput[]
    skipDuplicates?: boolean
  }

  export type QuestCreateWithoutNpcInput = {
    id?: string
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QuestUncheckedCreateWithoutNpcInput = {
    id?: string
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type QuestCreateOrConnectWithoutNpcInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput>
  }

  export type QuestCreateManyNpcInputEnvelope = {
    data: QuestCreateManyNpcInput | QuestCreateManyNpcInput[]
    skipDuplicates?: boolean
  }

  export type MapTileUpsertWithoutNpcsInput = {
    update: XOR<MapTileUpdateWithoutNpcsInput, MapTileUncheckedUpdateWithoutNpcsInput>
    create: XOR<MapTileCreateWithoutNpcsInput, MapTileUncheckedCreateWithoutNpcsInput>
    where?: MapTileWhereInput
  }

  export type MapTileUpdateToOneWithWhereWithoutNpcsInput = {
    where?: MapTileWhereInput
    data: XOR<MapTileUpdateWithoutNpcsInput, MapTileUncheckedUpdateWithoutNpcsInput>
  }

  export type MapTileUpdateWithoutNpcsInput = {
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUpdateManyWithoutTileNestedInput
    encounters?: EncounterUpdateManyWithoutTileNestedInput
  }

  export type MapTileUncheckedUpdateWithoutNpcsInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUncheckedUpdateManyWithoutTileNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutTileNestedInput
  }

  export type ShopItemUpsertWithWhereUniqueWithoutNpcInput = {
    where: ShopItemWhereUniqueInput
    update: XOR<ShopItemUpdateWithoutNpcInput, ShopItemUncheckedUpdateWithoutNpcInput>
    create: XOR<ShopItemCreateWithoutNpcInput, ShopItemUncheckedCreateWithoutNpcInput>
  }

  export type ShopItemUpdateWithWhereUniqueWithoutNpcInput = {
    where: ShopItemWhereUniqueInput
    data: XOR<ShopItemUpdateWithoutNpcInput, ShopItemUncheckedUpdateWithoutNpcInput>
  }

  export type ShopItemUpdateManyWithWhereWithoutNpcInput = {
    where: ShopItemScalarWhereInput
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyWithoutNpcInput>
  }

  export type ShopItemScalarWhereInput = {
    AND?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    OR?: ShopItemScalarWhereInput[]
    NOT?: ShopItemScalarWhereInput | ShopItemScalarWhereInput[]
    id?: StringFilter<"ShopItem"> | string
    npcId?: StringFilter<"ShopItem"> | string
    itemId?: StringFilter<"ShopItem"> | string
    price?: IntFilter<"ShopItem"> | number
    stock?: IntNullableFilter<"ShopItem"> | number | null
    createdAt?: DateTimeFilter<"ShopItem"> | Date | string
  }

  export type QuestUpsertWithWhereUniqueWithoutNpcInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutNpcInput, QuestUncheckedUpdateWithoutNpcInput>
    create: XOR<QuestCreateWithoutNpcInput, QuestUncheckedCreateWithoutNpcInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutNpcInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutNpcInput, QuestUncheckedUpdateWithoutNpcInput>
  }

  export type QuestUpdateManyWithWhereWithoutNpcInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutNpcInput>
  }

  export type QuestScalarWhereInput = {
    AND?: QuestScalarWhereInput | QuestScalarWhereInput[]
    OR?: QuestScalarWhereInput[]
    NOT?: QuestScalarWhereInput | QuestScalarWhereInput[]
    id?: StringFilter<"Quest"> | string
    npcId?: StringNullableFilter<"Quest"> | string | null
    title?: StringFilter<"Quest"> | string
    description?: StringFilter<"Quest"> | string
    questType?: EnumQuestTypeFilter<"Quest"> | $Enums.QuestType
    reward?: StringNullableFilter<"Quest"> | string | null
    requirements?: StringNullableFilter<"Quest"> | string | null
    isActive?: BoolFilter<"Quest"> | boolean
    createdAt?: DateTimeFilter<"Quest"> | Date | string
  }

  export type NPCCreateWithoutShopItemsInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
    tile?: MapTileCreateNestedOneWithoutNpcsInput
    quests?: QuestCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutShopItemsInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    tileId?: number | null
    dialogue?: string | null
    createdAt?: Date | string
    quests?: QuestUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutShopItemsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutShopItemsInput, NPCUncheckedCreateWithoutShopItemsInput>
  }

  export type ItemCreateWithoutShopItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutShopItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutShopItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutShopItemsInput, ItemUncheckedCreateWithoutShopItemsInput>
  }

  export type NPCUpsertWithoutShopItemsInput = {
    update: XOR<NPCUpdateWithoutShopItemsInput, NPCUncheckedUpdateWithoutShopItemsInput>
    create: XOR<NPCCreateWithoutShopItemsInput, NPCUncheckedCreateWithoutShopItemsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutShopItemsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutShopItemsInput, NPCUncheckedUpdateWithoutShopItemsInput>
  }

  export type NPCUpdateWithoutShopItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tile?: MapTileUpdateOneWithoutNpcsNestedInput
    quests?: QuestUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutShopItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quests?: QuestUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type ItemUpsertWithoutShopItemsInput = {
    update: XOR<ItemUpdateWithoutShopItemsInput, ItemUncheckedUpdateWithoutShopItemsInput>
    create: XOR<ItemCreateWithoutShopItemsInput, ItemUncheckedCreateWithoutShopItemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutShopItemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutShopItemsInput, ItemUncheckedUpdateWithoutShopItemsInput>
  }

  export type ItemUpdateWithoutShopItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutShopItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateWithoutItemInput = {
    id?: string
    playerId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemCreateManyItemInputEnvelope = {
    data: InventoryItemCreateManyItemInput | InventoryItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ShopItemCreateWithoutItemInput = {
    id?: string
    price: number
    stock?: number | null
    createdAt?: Date | string
    npc: NPCCreateNestedOneWithoutShopItemsInput
  }

  export type ShopItemUncheckedCreateWithoutItemInput = {
    id?: string
    npcId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type ShopItemCreateOrConnectWithoutItemInput = {
    where: ShopItemWhereUniqueInput
    create: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput>
  }

  export type ShopItemCreateManyItemInputEnvelope = {
    data: ShopItemCreateManyItemInput | ShopItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type MarketListingCreateWithoutItemInput = {
    id?: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
    player: PlayerCreateNestedOneWithoutMarketListingsInput
  }

  export type MarketListingUncheckedCreateWithoutItemInput = {
    id?: string
    playerId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type MarketListingCreateOrConnectWithoutItemInput = {
    where: MarketListingWhereUniqueInput
    create: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput>
  }

  export type MarketListingCreateManyItemInputEnvelope = {
    data: MarketListingCreateManyItemInput | MarketListingCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutWeaponInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutWeaponInput = {
    id?: string
    playerId: string
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutWeaponInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput>
  }

  export type EquipmentCreateManyWeaponInputEnvelope = {
    data: EquipmentCreateManyWeaponInput | EquipmentCreateManyWeaponInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutHeadInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutHeadInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutHeadInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput>
  }

  export type EquipmentCreateManyHeadInputEnvelope = {
    data: EquipmentCreateManyHeadInput | EquipmentCreateManyHeadInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutChestInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutChestInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutChestInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput>
  }

  export type EquipmentCreateManyChestInputEnvelope = {
    data: EquipmentCreateManyChestInput | EquipmentCreateManyChestInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutLegsInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutLegsInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutLegsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput>
  }

  export type EquipmentCreateManyLegsInputEnvelope = {
    data: EquipmentCreateManyLegsInput | EquipmentCreateManyLegsInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutFeetInput = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutFeetInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutFeetInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput>
  }

  export type EquipmentCreateManyFeetInputEnvelope = {
    data: EquipmentCreateManyFeetInput | EquipmentCreateManyFeetInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutAccessory1Input = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory2?: ItemCreateNestedOneWithoutEquippedAsAccessory2Input
  }

  export type EquipmentUncheckedCreateWithoutAccessory1Input = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutAccessory1Input = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input>
  }

  export type EquipmentCreateManyAccessory1InputEnvelope = {
    data: EquipmentCreateManyAccessory1Input | EquipmentCreateManyAccessory1Input[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutAccessory2Input = {
    id?: string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutEquipmentInput
    weapon?: ItemCreateNestedOneWithoutEquippedAsWeaponInput
    head?: ItemCreateNestedOneWithoutEquippedAsHeadInput
    chest?: ItemCreateNestedOneWithoutEquippedAsChestInput
    legs?: ItemCreateNestedOneWithoutEquippedAsLegsInput
    feet?: ItemCreateNestedOneWithoutEquippedAsFeetInput
    accessory1?: ItemCreateNestedOneWithoutEquippedAsAccessory1Input
  }

  export type EquipmentUncheckedCreateWithoutAccessory2Input = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutAccessory2Input = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input>
  }

  export type EquipmentCreateManyAccessory2InputEnvelope = {
    data: EquipmentCreateManyAccessory2Input | EquipmentCreateManyAccessory2Input[]
    skipDuplicates?: boolean
  }

  export type BankVaultItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    account: BankAccountCreateNestedOneWithoutVaultItemsInput
  }

  export type BankVaultItemUncheckedCreateWithoutItemInput = {
    id?: string
    accountId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type BankVaultItemCreateOrConnectWithoutItemInput = {
    where: BankVaultItemWhereUniqueInput
    create: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput>
  }

  export type BankVaultItemCreateManyItemInputEnvelope = {
    data: BankVaultItemCreateManyItemInput | BankVaultItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutItemInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutItemInput>
  }

  export type ShopItemUpsertWithWhereUniqueWithoutItemInput = {
    where: ShopItemWhereUniqueInput
    update: XOR<ShopItemUpdateWithoutItemInput, ShopItemUncheckedUpdateWithoutItemInput>
    create: XOR<ShopItemCreateWithoutItemInput, ShopItemUncheckedCreateWithoutItemInput>
  }

  export type ShopItemUpdateWithWhereUniqueWithoutItemInput = {
    where: ShopItemWhereUniqueInput
    data: XOR<ShopItemUpdateWithoutItemInput, ShopItemUncheckedUpdateWithoutItemInput>
  }

  export type ShopItemUpdateManyWithWhereWithoutItemInput = {
    where: ShopItemScalarWhereInput
    data: XOR<ShopItemUpdateManyMutationInput, ShopItemUncheckedUpdateManyWithoutItemInput>
  }

  export type MarketListingUpsertWithWhereUniqueWithoutItemInput = {
    where: MarketListingWhereUniqueInput
    update: XOR<MarketListingUpdateWithoutItemInput, MarketListingUncheckedUpdateWithoutItemInput>
    create: XOR<MarketListingCreateWithoutItemInput, MarketListingUncheckedCreateWithoutItemInput>
  }

  export type MarketListingUpdateWithWhereUniqueWithoutItemInput = {
    where: MarketListingWhereUniqueInput
    data: XOR<MarketListingUpdateWithoutItemInput, MarketListingUncheckedUpdateWithoutItemInput>
  }

  export type MarketListingUpdateManyWithWhereWithoutItemInput = {
    where: MarketListingScalarWhereInput
    data: XOR<MarketListingUpdateManyMutationInput, MarketListingUncheckedUpdateManyWithoutItemInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutWeaponInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutWeaponInput, EquipmentUncheckedUpdateWithoutWeaponInput>
    create: XOR<EquipmentCreateWithoutWeaponInput, EquipmentUncheckedCreateWithoutWeaponInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutWeaponInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutWeaponInput, EquipmentUncheckedUpdateWithoutWeaponInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutWeaponInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutWeaponInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    playerId?: StringFilter<"Equipment"> | string
    weaponId?: StringNullableFilter<"Equipment"> | string | null
    headId?: StringNullableFilter<"Equipment"> | string | null
    chestId?: StringNullableFilter<"Equipment"> | string | null
    legsId?: StringNullableFilter<"Equipment"> | string | null
    feetId?: StringNullableFilter<"Equipment"> | string | null
    accessory1Id?: StringNullableFilter<"Equipment"> | string | null
    accessory2Id?: StringNullableFilter<"Equipment"> | string | null
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
  }

  export type EquipmentUpsertWithWhereUniqueWithoutHeadInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutHeadInput, EquipmentUncheckedUpdateWithoutHeadInput>
    create: XOR<EquipmentCreateWithoutHeadInput, EquipmentUncheckedCreateWithoutHeadInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutHeadInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutHeadInput, EquipmentUncheckedUpdateWithoutHeadInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutHeadInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutHeadInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutChestInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutChestInput, EquipmentUncheckedUpdateWithoutChestInput>
    create: XOR<EquipmentCreateWithoutChestInput, EquipmentUncheckedCreateWithoutChestInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutChestInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutChestInput, EquipmentUncheckedUpdateWithoutChestInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutChestInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutChestInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutLegsInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutLegsInput, EquipmentUncheckedUpdateWithoutLegsInput>
    create: XOR<EquipmentCreateWithoutLegsInput, EquipmentUncheckedCreateWithoutLegsInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutLegsInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutLegsInput, EquipmentUncheckedUpdateWithoutLegsInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutLegsInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutLegsInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutFeetInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutFeetInput, EquipmentUncheckedUpdateWithoutFeetInput>
    create: XOR<EquipmentCreateWithoutFeetInput, EquipmentUncheckedCreateWithoutFeetInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutFeetInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutFeetInput, EquipmentUncheckedUpdateWithoutFeetInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutFeetInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutFeetInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutAccessory1Input = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutAccessory1Input, EquipmentUncheckedUpdateWithoutAccessory1Input>
    create: XOR<EquipmentCreateWithoutAccessory1Input, EquipmentUncheckedCreateWithoutAccessory1Input>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutAccessory1Input = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutAccessory1Input, EquipmentUncheckedUpdateWithoutAccessory1Input>
  }

  export type EquipmentUpdateManyWithWhereWithoutAccessory1Input = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutAccessory1Input>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutAccessory2Input = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutAccessory2Input, EquipmentUncheckedUpdateWithoutAccessory2Input>
    create: XOR<EquipmentCreateWithoutAccessory2Input, EquipmentUncheckedCreateWithoutAccessory2Input>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutAccessory2Input = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutAccessory2Input, EquipmentUncheckedUpdateWithoutAccessory2Input>
  }

  export type EquipmentUpdateManyWithWhereWithoutAccessory2Input = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutAccessory2Input>
  }

  export type BankVaultItemUpsertWithWhereUniqueWithoutItemInput = {
    where: BankVaultItemWhereUniqueInput
    update: XOR<BankVaultItemUpdateWithoutItemInput, BankVaultItemUncheckedUpdateWithoutItemInput>
    create: XOR<BankVaultItemCreateWithoutItemInput, BankVaultItemUncheckedCreateWithoutItemInput>
  }

  export type BankVaultItemUpdateWithWhereUniqueWithoutItemInput = {
    where: BankVaultItemWhereUniqueInput
    data: XOR<BankVaultItemUpdateWithoutItemInput, BankVaultItemUncheckedUpdateWithoutItemInput>
  }

  export type BankVaultItemUpdateManyWithWhereWithoutItemInput = {
    where: BankVaultItemScalarWhereInput
    data: XOR<BankVaultItemUpdateManyMutationInput, BankVaultItemUncheckedUpdateManyWithoutItemInput>
  }

  export type BankVaultItemScalarWhereInput = {
    AND?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
    OR?: BankVaultItemScalarWhereInput[]
    NOT?: BankVaultItemScalarWhereInput | BankVaultItemScalarWhereInput[]
    id?: StringFilter<"BankVaultItem"> | string
    accountId?: StringFilter<"BankVaultItem"> | string
    itemId?: StringFilter<"BankVaultItem"> | string
    quantity?: IntFilter<"BankVaultItem"> | number
    createdAt?: DateTimeFilter<"BankVaultItem"> | Date | string
  }

  export type PlayerCreateWithoutInventoryInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutInventoryInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutInventoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
  }

  export type ItemCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInventoryItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
  }

  export type PlayerUpsertWithoutInventoryInput = {
    update: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutInventoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type PlayerUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutInventoryItemsInput = {
    update: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ItemUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PlayerCreateWithoutEquipmentInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutEquipmentInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutEquipmentInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutEquipmentInput, PlayerUncheckedCreateWithoutEquipmentInput>
  }

  export type ItemCreateWithoutEquippedAsWeaponInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsWeaponInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsWeaponInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsWeaponInput, ItemUncheckedCreateWithoutEquippedAsWeaponInput>
  }

  export type ItemCreateWithoutEquippedAsHeadInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsHeadInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsHeadInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsHeadInput, ItemUncheckedCreateWithoutEquippedAsHeadInput>
  }

  export type ItemCreateWithoutEquippedAsChestInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsChestInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsChestInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsChestInput, ItemUncheckedCreateWithoutEquippedAsChestInput>
  }

  export type ItemCreateWithoutEquippedAsLegsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsLegsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsLegsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsLegsInput, ItemUncheckedCreateWithoutEquippedAsLegsInput>
  }

  export type ItemCreateWithoutEquippedAsFeetInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsFeetInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsFeetInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsFeetInput, ItemUncheckedCreateWithoutEquippedAsFeetInput>
  }

  export type ItemCreateWithoutEquippedAsAccessory1Input = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsAccessory1Input = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsAccessory1Input = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsAccessory1Input, ItemUncheckedCreateWithoutEquippedAsAccessory1Input>
  }

  export type ItemCreateWithoutEquippedAsAccessory2Input = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEquippedAsAccessory2Input = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEquippedAsAccessory2Input = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEquippedAsAccessory2Input, ItemUncheckedCreateWithoutEquippedAsAccessory2Input>
  }

  export type PlayerUpsertWithoutEquipmentInput = {
    update: XOR<PlayerUpdateWithoutEquipmentInput, PlayerUncheckedUpdateWithoutEquipmentInput>
    create: XOR<PlayerCreateWithoutEquipmentInput, PlayerUncheckedCreateWithoutEquipmentInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutEquipmentInput, PlayerUncheckedUpdateWithoutEquipmentInput>
  }

  export type PlayerUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutEquippedAsWeaponInput = {
    update: XOR<ItemUpdateWithoutEquippedAsWeaponInput, ItemUncheckedUpdateWithoutEquippedAsWeaponInput>
    create: XOR<ItemCreateWithoutEquippedAsWeaponInput, ItemUncheckedCreateWithoutEquippedAsWeaponInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsWeaponInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsWeaponInput, ItemUncheckedUpdateWithoutEquippedAsWeaponInput>
  }

  export type ItemUpdateWithoutEquippedAsWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsHeadInput = {
    update: XOR<ItemUpdateWithoutEquippedAsHeadInput, ItemUncheckedUpdateWithoutEquippedAsHeadInput>
    create: XOR<ItemCreateWithoutEquippedAsHeadInput, ItemUncheckedCreateWithoutEquippedAsHeadInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsHeadInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsHeadInput, ItemUncheckedUpdateWithoutEquippedAsHeadInput>
  }

  export type ItemUpdateWithoutEquippedAsHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsChestInput = {
    update: XOR<ItemUpdateWithoutEquippedAsChestInput, ItemUncheckedUpdateWithoutEquippedAsChestInput>
    create: XOR<ItemCreateWithoutEquippedAsChestInput, ItemUncheckedCreateWithoutEquippedAsChestInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsChestInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsChestInput, ItemUncheckedUpdateWithoutEquippedAsChestInput>
  }

  export type ItemUpdateWithoutEquippedAsChestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsChestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsLegsInput = {
    update: XOR<ItemUpdateWithoutEquippedAsLegsInput, ItemUncheckedUpdateWithoutEquippedAsLegsInput>
    create: XOR<ItemCreateWithoutEquippedAsLegsInput, ItemUncheckedCreateWithoutEquippedAsLegsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsLegsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsLegsInput, ItemUncheckedUpdateWithoutEquippedAsLegsInput>
  }

  export type ItemUpdateWithoutEquippedAsLegsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsLegsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsFeetInput = {
    update: XOR<ItemUpdateWithoutEquippedAsFeetInput, ItemUncheckedUpdateWithoutEquippedAsFeetInput>
    create: XOR<ItemCreateWithoutEquippedAsFeetInput, ItemUncheckedCreateWithoutEquippedAsFeetInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsFeetInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsFeetInput, ItemUncheckedUpdateWithoutEquippedAsFeetInput>
  }

  export type ItemUpdateWithoutEquippedAsFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsAccessory1Input = {
    update: XOR<ItemUpdateWithoutEquippedAsAccessory1Input, ItemUncheckedUpdateWithoutEquippedAsAccessory1Input>
    create: XOR<ItemCreateWithoutEquippedAsAccessory1Input, ItemUncheckedCreateWithoutEquippedAsAccessory1Input>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsAccessory1Input = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsAccessory1Input, ItemUncheckedUpdateWithoutEquippedAsAccessory1Input>
  }

  export type ItemUpdateWithoutEquippedAsAccessory1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsAccessory1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUpsertWithoutEquippedAsAccessory2Input = {
    update: XOR<ItemUpdateWithoutEquippedAsAccessory2Input, ItemUncheckedUpdateWithoutEquippedAsAccessory2Input>
    create: XOR<ItemCreateWithoutEquippedAsAccessory2Input, ItemUncheckedCreateWithoutEquippedAsAccessory2Input>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutEquippedAsAccessory2Input = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutEquippedAsAccessory2Input, ItemUncheckedUpdateWithoutEquippedAsAccessory2Input>
  }

  export type ItemUpdateWithoutEquippedAsAccessory2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutEquippedAsAccessory2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PlayerCreateWithoutOccupationInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutOccupationInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutOccupationInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutOccupationInput, PlayerUncheckedCreateWithoutOccupationInput>
  }

  export type PlayerUpsertWithoutOccupationInput = {
    update: XOR<PlayerUpdateWithoutOccupationInput, PlayerUncheckedUpdateWithoutOccupationInput>
    create: XOR<PlayerCreateWithoutOccupationInput, PlayerUncheckedCreateWithoutOccupationInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutOccupationInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutOccupationInput, PlayerUncheckedUpdateWithoutOccupationInput>
  }

  export type PlayerUpdateWithoutOccupationInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutOccupationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutSkillsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSkillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
  }

  export type PlayerUpsertWithoutSkillsInput = {
    update: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
    create: XOR<PlayerCreateWithoutSkillsInput, PlayerUncheckedCreateWithoutSkillsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSkillsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSkillsInput, PlayerUncheckedUpdateWithoutSkillsInput>
  }

  export type PlayerUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MapTileCreateWithoutEncountersInput = {
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionCreateNestedManyWithoutTileInput
    npcs?: NPCCreateNestedManyWithoutTileInput
  }

  export type MapTileUncheckedCreateWithoutEncountersInput = {
    id?: number
    x: number
    y: number
    tileType: $Enums.TileType
    zoneType: $Enums.ZoneType
    isSafeZone?: boolean
    hasResource?: boolean
    resourceType?: $Enums.ResourceType | null
    description?: string | null
    positions?: MapPositionUncheckedCreateNestedManyWithoutTileInput
    npcs?: NPCUncheckedCreateNestedManyWithoutTileInput
  }

  export type MapTileCreateOrConnectWithoutEncountersInput = {
    where: MapTileWhereUniqueInput
    create: XOR<MapTileCreateWithoutEncountersInput, MapTileUncheckedCreateWithoutEncountersInput>
  }

  export type MapTileUpsertWithoutEncountersInput = {
    update: XOR<MapTileUpdateWithoutEncountersInput, MapTileUncheckedUpdateWithoutEncountersInput>
    create: XOR<MapTileCreateWithoutEncountersInput, MapTileUncheckedCreateWithoutEncountersInput>
    where?: MapTileWhereInput
  }

  export type MapTileUpdateToOneWithWhereWithoutEncountersInput = {
    where?: MapTileWhereInput
    data: XOR<MapTileUpdateWithoutEncountersInput, MapTileUncheckedUpdateWithoutEncountersInput>
  }

  export type MapTileUpdateWithoutEncountersInput = {
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUpdateManyWithoutTileNestedInput
    npcs?: NPCUpdateManyWithoutTileNestedInput
  }

  export type MapTileUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    tileType?: EnumTileTypeFieldUpdateOperationsInput | $Enums.TileType
    zoneType?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    isSafeZone?: BoolFieldUpdateOperationsInput | boolean
    hasResource?: BoolFieldUpdateOperationsInput | boolean
    resourceType?: NullableEnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: MapPositionUncheckedUpdateManyWithoutTileNestedInput
    npcs?: NPCUncheckedUpdateManyWithoutTileNestedInput
  }

  export type PlayerCreateWithoutCombatLogsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCombatLogsInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCombatLogsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCombatLogsInput, PlayerUncheckedCreateWithoutCombatLogsInput>
  }

  export type PlayerUpsertWithoutCombatLogsInput = {
    update: XOR<PlayerUpdateWithoutCombatLogsInput, PlayerUncheckedUpdateWithoutCombatLogsInput>
    create: XOR<PlayerCreateWithoutCombatLogsInput, PlayerUncheckedCreateWithoutCombatLogsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutCombatLogsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutCombatLogsInput, PlayerUncheckedUpdateWithoutCombatLogsInput>
  }

  export type PlayerUpdateWithoutCombatLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCombatLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutDeathLogsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutDeathLogsInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutDeathLogsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutDeathLogsInput, PlayerUncheckedCreateWithoutDeathLogsInput>
  }

  export type PlayerUpsertWithoutDeathLogsInput = {
    update: XOR<PlayerUpdateWithoutDeathLogsInput, PlayerUncheckedUpdateWithoutDeathLogsInput>
    create: XOR<PlayerCreateWithoutDeathLogsInput, PlayerUncheckedCreateWithoutDeathLogsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutDeathLogsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutDeathLogsInput, PlayerUncheckedUpdateWithoutDeathLogsInput>
  }

  export type PlayerUpdateWithoutDeathLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutDeathLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type GuildMemberCreateWithoutGuildInput = {
    id?: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
    player: PlayerCreateNestedOneWithoutGuildMemberInput
  }

  export type GuildMemberUncheckedCreateWithoutGuildInput = {
    id?: string
    playerId: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
  }

  export type GuildMemberCreateOrConnectWithoutGuildInput = {
    where: GuildMemberWhereUniqueInput
    create: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput>
  }

  export type GuildMemberCreateManyGuildInputEnvelope = {
    data: GuildMemberCreateManyGuildInput | GuildMemberCreateManyGuildInput[]
    skipDuplicates?: boolean
  }

  export type GuildBankCreateWithoutGuildInput = {
    id?: string
    gold?: number
    updatedAt?: Date | string
  }

  export type GuildBankUncheckedCreateWithoutGuildInput = {
    id?: string
    gold?: number
    updatedAt?: Date | string
  }

  export type GuildBankCreateOrConnectWithoutGuildInput = {
    where: GuildBankWhereUniqueInput
    create: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
  }

  export type GuildQuestCreateWithoutGuildInput = {
    id?: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuildQuestUncheckedCreateWithoutGuildInput = {
    id?: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuildQuestCreateOrConnectWithoutGuildInput = {
    where: GuildQuestWhereUniqueInput
    create: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput>
  }

  export type GuildQuestCreateManyGuildInputEnvelope = {
    data: GuildQuestCreateManyGuildInput | GuildQuestCreateManyGuildInput[]
    skipDuplicates?: boolean
  }

  export type GuildMemberUpsertWithWhereUniqueWithoutGuildInput = {
    where: GuildMemberWhereUniqueInput
    update: XOR<GuildMemberUpdateWithoutGuildInput, GuildMemberUncheckedUpdateWithoutGuildInput>
    create: XOR<GuildMemberCreateWithoutGuildInput, GuildMemberUncheckedCreateWithoutGuildInput>
  }

  export type GuildMemberUpdateWithWhereUniqueWithoutGuildInput = {
    where: GuildMemberWhereUniqueInput
    data: XOR<GuildMemberUpdateWithoutGuildInput, GuildMemberUncheckedUpdateWithoutGuildInput>
  }

  export type GuildMemberUpdateManyWithWhereWithoutGuildInput = {
    where: GuildMemberScalarWhereInput
    data: XOR<GuildMemberUpdateManyMutationInput, GuildMemberUncheckedUpdateManyWithoutGuildInput>
  }

  export type GuildMemberScalarWhereInput = {
    AND?: GuildMemberScalarWhereInput | GuildMemberScalarWhereInput[]
    OR?: GuildMemberScalarWhereInput[]
    NOT?: GuildMemberScalarWhereInput | GuildMemberScalarWhereInput[]
    id?: StringFilter<"GuildMember"> | string
    playerId?: StringFilter<"GuildMember"> | string
    guildId?: StringFilter<"GuildMember"> | string
    role?: EnumGuildRoleFilter<"GuildMember"> | $Enums.GuildRole
    joinedAt?: DateTimeFilter<"GuildMember"> | Date | string
  }

  export type GuildBankUpsertWithoutGuildInput = {
    update: XOR<GuildBankUpdateWithoutGuildInput, GuildBankUncheckedUpdateWithoutGuildInput>
    create: XOR<GuildBankCreateWithoutGuildInput, GuildBankUncheckedCreateWithoutGuildInput>
    where?: GuildBankWhereInput
  }

  export type GuildBankUpdateToOneWithWhereWithoutGuildInput = {
    where?: GuildBankWhereInput
    data: XOR<GuildBankUpdateWithoutGuildInput, GuildBankUncheckedUpdateWithoutGuildInput>
  }

  export type GuildBankUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildBankUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestUpsertWithWhereUniqueWithoutGuildInput = {
    where: GuildQuestWhereUniqueInput
    update: XOR<GuildQuestUpdateWithoutGuildInput, GuildQuestUncheckedUpdateWithoutGuildInput>
    create: XOR<GuildQuestCreateWithoutGuildInput, GuildQuestUncheckedCreateWithoutGuildInput>
  }

  export type GuildQuestUpdateWithWhereUniqueWithoutGuildInput = {
    where: GuildQuestWhereUniqueInput
    data: XOR<GuildQuestUpdateWithoutGuildInput, GuildQuestUncheckedUpdateWithoutGuildInput>
  }

  export type GuildQuestUpdateManyWithWhereWithoutGuildInput = {
    where: GuildQuestScalarWhereInput
    data: XOR<GuildQuestUpdateManyMutationInput, GuildQuestUncheckedUpdateManyWithoutGuildInput>
  }

  export type GuildQuestScalarWhereInput = {
    AND?: GuildQuestScalarWhereInput | GuildQuestScalarWhereInput[]
    OR?: GuildQuestScalarWhereInput[]
    NOT?: GuildQuestScalarWhereInput | GuildQuestScalarWhereInput[]
    id?: StringFilter<"GuildQuest"> | string
    guildId?: StringFilter<"GuildQuest"> | string
    title?: StringFilter<"GuildQuest"> | string
    description?: StringFilter<"GuildQuest"> | string
    reward?: StringNullableFilter<"GuildQuest"> | string | null
    isActive?: BoolFilter<"GuildQuest"> | boolean
    createdAt?: DateTimeFilter<"GuildQuest"> | Date | string
  }

  export type PlayerCreateWithoutGuildMemberInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutGuildMemberInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutGuildMemberInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGuildMemberInput, PlayerUncheckedCreateWithoutGuildMemberInput>
  }

  export type GuildCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bank?: GuildBankCreateNestedOneWithoutGuildInput
    quests?: GuildQuestCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bank?: GuildBankUncheckedCreateNestedOneWithoutGuildInput
    quests?: GuildQuestUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutMembersInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutMembersInput, GuildUncheckedCreateWithoutMembersInput>
  }

  export type PlayerUpsertWithoutGuildMemberInput = {
    update: XOR<PlayerUpdateWithoutGuildMemberInput, PlayerUncheckedUpdateWithoutGuildMemberInput>
    create: XOR<PlayerCreateWithoutGuildMemberInput, PlayerUncheckedCreateWithoutGuildMemberInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutGuildMemberInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutGuildMemberInput, PlayerUncheckedUpdateWithoutGuildMemberInput>
  }

  export type PlayerUpdateWithoutGuildMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGuildMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type GuildUpsertWithoutMembersInput = {
    update: XOR<GuildUpdateWithoutMembersInput, GuildUncheckedUpdateWithoutMembersInput>
    create: XOR<GuildCreateWithoutMembersInput, GuildUncheckedCreateWithoutMembersInput>
    where?: GuildWhereInput
  }

  export type GuildUpdateToOneWithWhereWithoutMembersInput = {
    where?: GuildWhereInput
    data: XOR<GuildUpdateWithoutMembersInput, GuildUncheckedUpdateWithoutMembersInput>
  }

  export type GuildUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: GuildBankUpdateOneWithoutGuildNestedInput
    quests?: GuildQuestUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: GuildBankUncheckedUpdateOneWithoutGuildNestedInput
    quests?: GuildQuestUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type GuildCreateWithoutBankInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberCreateNestedManyWithoutGuildInput
    quests?: GuildQuestCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutBankInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberUncheckedCreateNestedManyWithoutGuildInput
    quests?: GuildQuestUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutBankInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutBankInput, GuildUncheckedCreateWithoutBankInput>
  }

  export type GuildUpsertWithoutBankInput = {
    update: XOR<GuildUpdateWithoutBankInput, GuildUncheckedUpdateWithoutBankInput>
    create: XOR<GuildCreateWithoutBankInput, GuildUncheckedCreateWithoutBankInput>
    where?: GuildWhereInput
  }

  export type GuildUpdateToOneWithWhereWithoutBankInput = {
    where?: GuildWhereInput
    data: XOR<GuildUpdateWithoutBankInput, GuildUncheckedUpdateWithoutBankInput>
  }

  export type GuildUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUpdateManyWithoutGuildNestedInput
    quests?: GuildQuestUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUncheckedUpdateManyWithoutGuildNestedInput
    quests?: GuildQuestUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type GuildCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberCreateNestedManyWithoutGuildInput
    bank?: GuildBankCreateNestedOneWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    level?: number
    gold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GuildMemberUncheckedCreateNestedManyWithoutGuildInput
    bank?: GuildBankUncheckedCreateNestedOneWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutQuestsInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutQuestsInput, GuildUncheckedCreateWithoutQuestsInput>
  }

  export type GuildUpsertWithoutQuestsInput = {
    update: XOR<GuildUpdateWithoutQuestsInput, GuildUncheckedUpdateWithoutQuestsInput>
    create: XOR<GuildCreateWithoutQuestsInput, GuildUncheckedCreateWithoutQuestsInput>
    where?: GuildWhereInput
  }

  export type GuildUpdateToOneWithWhereWithoutQuestsInput = {
    where?: GuildWhereInput
    data: XOR<GuildUpdateWithoutQuestsInput, GuildUncheckedUpdateWithoutQuestsInput>
  }

  export type GuildUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUpdateManyWithoutGuildNestedInput
    bank?: GuildBankUpdateOneWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GuildMemberUncheckedUpdateManyWithoutGuildNestedInput
    bank?: GuildBankUncheckedUpdateOneWithoutGuildNestedInput
  }

  export type PlayerCreateWithoutBankAccountInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutBankAccountInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutBankAccountInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutBankAccountInput, PlayerUncheckedCreateWithoutBankAccountInput>
  }

  export type BankVaultItemCreateWithoutAccountInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutBankVaultItemsInput
  }

  export type BankVaultItemUncheckedCreateWithoutAccountInput = {
    id?: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type BankVaultItemCreateOrConnectWithoutAccountInput = {
    where: BankVaultItemWhereUniqueInput
    create: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput>
  }

  export type BankVaultItemCreateManyAccountInputEnvelope = {
    data: BankVaultItemCreateManyAccountInput | BankVaultItemCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutBankAccountInput = {
    update: XOR<PlayerUpdateWithoutBankAccountInput, PlayerUncheckedUpdateWithoutBankAccountInput>
    create: XOR<PlayerCreateWithoutBankAccountInput, PlayerUncheckedCreateWithoutBankAccountInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutBankAccountInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutBankAccountInput, PlayerUncheckedUpdateWithoutBankAccountInput>
  }

  export type PlayerUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type BankVaultItemUpsertWithWhereUniqueWithoutAccountInput = {
    where: BankVaultItemWhereUniqueInput
    update: XOR<BankVaultItemUpdateWithoutAccountInput, BankVaultItemUncheckedUpdateWithoutAccountInput>
    create: XOR<BankVaultItemCreateWithoutAccountInput, BankVaultItemUncheckedCreateWithoutAccountInput>
  }

  export type BankVaultItemUpdateWithWhereUniqueWithoutAccountInput = {
    where: BankVaultItemWhereUniqueInput
    data: XOR<BankVaultItemUpdateWithoutAccountInput, BankVaultItemUncheckedUpdateWithoutAccountInput>
  }

  export type BankVaultItemUpdateManyWithWhereWithoutAccountInput = {
    where: BankVaultItemScalarWhereInput
    data: XOR<BankVaultItemUpdateManyMutationInput, BankVaultItemUncheckedUpdateManyWithoutAccountInput>
  }

  export type BankAccountCreateWithoutVaultItemsInput = {
    id?: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateWithoutVaultItemsInput = {
    id?: string
    playerId: string
    gold?: number
    vaultLevel?: number
    updatedAt?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutVaultItemsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutVaultItemsInput, BankAccountUncheckedCreateWithoutVaultItemsInput>
  }

  export type ItemCreateWithoutBankVaultItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    marketListings?: MarketListingCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
  }

  export type ItemUncheckedCreateWithoutBankVaultItemsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    marketListings?: MarketListingUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
  }

  export type ItemCreateOrConnectWithoutBankVaultItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBankVaultItemsInput, ItemUncheckedCreateWithoutBankVaultItemsInput>
  }

  export type BankAccountUpsertWithoutVaultItemsInput = {
    update: XOR<BankAccountUpdateWithoutVaultItemsInput, BankAccountUncheckedUpdateWithoutVaultItemsInput>
    create: XOR<BankAccountCreateWithoutVaultItemsInput, BankAccountUncheckedCreateWithoutVaultItemsInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutVaultItemsInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutVaultItemsInput, BankAccountUncheckedUpdateWithoutVaultItemsInput>
  }

  export type BankAccountUpdateWithoutVaultItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutVaultItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gold?: IntFieldUpdateOperationsInput | number
    vaultLevel?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutBankVaultItemsInput = {
    update: XOR<ItemUpdateWithoutBankVaultItemsInput, ItemUncheckedUpdateWithoutBankVaultItemsInput>
    create: XOR<ItemCreateWithoutBankVaultItemsInput, ItemUncheckedCreateWithoutBankVaultItemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBankVaultItemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBankVaultItemsInput, ItemUncheckedUpdateWithoutBankVaultItemsInput>
  }

  export type ItemUpdateWithoutBankVaultItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
  }

  export type ItemUncheckedUpdateWithoutBankVaultItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    marketListings?: MarketListingUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
  }

  export type PlayerCreateWithoutMarketListingsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerInput
    stats?: PlayerStatsCreateNestedOneWithoutPlayerInput
    position?: MapPositionCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentCreateNestedOneWithoutPlayerInput
    occupation?: OccupationCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountCreateNestedOneWithoutPlayerInput
    combatLogs?: CombatLogCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMarketListingsInput = {
    id?: string
    userId: string
    characterName: string
    level?: number
    experience?: number
    gold?: number
    deathCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: PlayerStatsUncheckedCreateNestedOneWithoutPlayerInput
    position?: MapPositionUncheckedCreateNestedOneWithoutPlayerInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutPlayerInput
    equipment?: EquipmentUncheckedCreateNestedOneWithoutPlayerInput
    occupation?: OccupationUncheckedCreateNestedOneWithoutPlayerInput
    guildMember?: GuildMemberUncheckedCreateNestedOneWithoutPlayerInput
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutPlayerInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutPlayerInput
    deathLogs?: DeathLogUncheckedCreateNestedManyWithoutPlayerInput
    skills?: PlayerSkillUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMarketListingsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarketListingsInput, PlayerUncheckedCreateWithoutMarketListingsInput>
  }

  export type ItemCreateWithoutMarketListingsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
    shopItems?: ShopItemCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutMarketListingsInput = {
    id?: string
    name: string
    description?: string | null
    itemType: $Enums.ItemType
    itemRarity: $Enums.ItemRarity
    tier?: number
    value: number
    stackable?: boolean
    maxStack?: number
    equipmentSlot?: $Enums.EquipmentSlot | null
    vitalityBonus?: number
    strengthBonus?: number
    speedBonus?: number
    dexterityBonus?: number
    hpBonus?: number
    spBonus?: number
    createdAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutItemInput
    equippedAsWeapon?: EquipmentUncheckedCreateNestedManyWithoutWeaponInput
    equippedAsHead?: EquipmentUncheckedCreateNestedManyWithoutHeadInput
    equippedAsChest?: EquipmentUncheckedCreateNestedManyWithoutChestInput
    equippedAsLegs?: EquipmentUncheckedCreateNestedManyWithoutLegsInput
    equippedAsFeet?: EquipmentUncheckedCreateNestedManyWithoutFeetInput
    equippedAsAccessory1?: EquipmentUncheckedCreateNestedManyWithoutAccessory1Input
    equippedAsAccessory2?: EquipmentUncheckedCreateNestedManyWithoutAccessory2Input
    bankVaultItems?: BankVaultItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutMarketListingsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutMarketListingsInput, ItemUncheckedCreateWithoutMarketListingsInput>
  }

  export type PlayerUpsertWithoutMarketListingsInput = {
    update: XOR<PlayerUpdateWithoutMarketListingsInput, PlayerUncheckedUpdateWithoutMarketListingsInput>
    create: XOR<PlayerCreateWithoutMarketListingsInput, PlayerUncheckedCreateWithoutMarketListingsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMarketListingsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMarketListingsInput, PlayerUncheckedUpdateWithoutMarketListingsInput>
  }

  export type PlayerUpdateWithoutMarketListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerNestedInput
    stats?: PlayerStatsUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUpdateOneWithoutPlayerNestedInput
    combatLogs?: CombatLogUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarketListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    gold?: IntFieldUpdateOperationsInput | number
    deathCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: PlayerStatsUncheckedUpdateOneWithoutPlayerNestedInput
    position?: MapPositionUncheckedUpdateOneWithoutPlayerNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutPlayerNestedInput
    equipment?: EquipmentUncheckedUpdateOneWithoutPlayerNestedInput
    occupation?: OccupationUncheckedUpdateOneWithoutPlayerNestedInput
    guildMember?: GuildMemberUncheckedUpdateOneWithoutPlayerNestedInput
    bankAccount?: BankAccountUncheckedUpdateOneWithoutPlayerNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutPlayerNestedInput
    deathLogs?: DeathLogUncheckedUpdateManyWithoutPlayerNestedInput
    skills?: PlayerSkillUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutMarketListingsInput = {
    update: XOR<ItemUpdateWithoutMarketListingsInput, ItemUncheckedUpdateWithoutMarketListingsInput>
    create: XOR<ItemCreateWithoutMarketListingsInput, ItemUncheckedCreateWithoutMarketListingsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutMarketListingsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutMarketListingsInput, ItemUncheckedUpdateWithoutMarketListingsInput>
  }

  export type ItemUpdateWithoutMarketListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutMarketListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    itemRarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    tier?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    maxStack?: IntFieldUpdateOperationsInput | number
    equipmentSlot?: NullableEnumEquipmentSlotFieldUpdateOperationsInput | $Enums.EquipmentSlot | null
    vitalityBonus?: IntFieldUpdateOperationsInput | number
    strengthBonus?: IntFieldUpdateOperationsInput | number
    speedBonus?: IntFieldUpdateOperationsInput | number
    dexterityBonus?: IntFieldUpdateOperationsInput | number
    hpBonus?: IntFieldUpdateOperationsInput | number
    spBonus?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
    shopItems?: ShopItemUncheckedUpdateManyWithoutItemNestedInput
    equippedAsWeapon?: EquipmentUncheckedUpdateManyWithoutWeaponNestedInput
    equippedAsHead?: EquipmentUncheckedUpdateManyWithoutHeadNestedInput
    equippedAsChest?: EquipmentUncheckedUpdateManyWithoutChestNestedInput
    equippedAsLegs?: EquipmentUncheckedUpdateManyWithoutLegsNestedInput
    equippedAsFeet?: EquipmentUncheckedUpdateManyWithoutFeetNestedInput
    equippedAsAccessory1?: EquipmentUncheckedUpdateManyWithoutAccessory1NestedInput
    equippedAsAccessory2?: EquipmentUncheckedUpdateManyWithoutAccessory2NestedInput
    bankVaultItems?: BankVaultItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type NPCCreateWithoutQuestsInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
    tile?: MapTileCreateNestedOneWithoutNpcsInput
    shopItems?: ShopItemCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    tileId?: number | null
    dialogue?: string | null
    createdAt?: Date | string
    shopItems?: ShopItemUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutQuestsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
  }

  export type NPCUpsertWithoutQuestsInput = {
    update: XOR<NPCUpdateWithoutQuestsInput, NPCUncheckedUpdateWithoutQuestsInput>
    create: XOR<NPCCreateWithoutQuestsInput, NPCUncheckedCreateWithoutQuestsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutQuestsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutQuestsInput, NPCUncheckedUpdateWithoutQuestsInput>
  }

  export type NPCUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tile?: MapTileUpdateOneWithoutNpcsNestedInput
    shopItems?: ShopItemUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    tileId?: NullableIntFieldUpdateOperationsInput | number | null
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type PostCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyPlayerInput = {
    id?: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type MarketListingCreateManyPlayerInput = {
    id?: string
    itemId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type CombatLogCreateManyPlayerInput = {
    id?: string
    encounterId?: string | null
    turnNumber: number
    action: string
    result: string
    createdAt?: Date | string
  }

  export type DeathLogCreateManyPlayerInput = {
    id?: string
    deathCount: number
    cause?: string | null
    locationX?: number | null
    locationY?: number | null
    createdAt?: Date | string
  }

  export type PlayerSkillCreateManyPlayerInput = {
    id?: string
    skillName: string
    level?: number
    experience?: number
    createdAt?: Date | string
  }

  export type InventoryItemUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutMarketListingsNestedInput
  }

  export type MarketListingUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketListingUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CombatLogUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    turnNumber?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeathLogUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    deathCount?: IntFieldUpdateOperationsInput | number
    cause?: NullableStringFieldUpdateOperationsInput | string | null
    locationX?: NullableIntFieldUpdateOperationsInput | number | null
    locationY?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerSkillUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapPositionCreateManyTileInput = {
    id?: string
    playerId: string
    tileX: number
    tileY: number
    updatedAt?: Date | string
  }

  export type NPCCreateManyTileInput = {
    id?: string
    name: string
    npcType: $Enums.NPCType
    tileX: number
    tileY: number
    dialogue?: string | null
    createdAt?: Date | string
  }

  export type EncounterCreateManyTileInput = {
    id?: string
    tileX: number
    tileY: number
    enemyType: string
    enemyLevel: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type MapPositionUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPositionNestedInput
  }

  export type MapPositionUncheckedUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapPositionUncheckedUpdateManyWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUpdateManyWithoutNpcNestedInput
    quests?: QuestUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopItems?: ShopItemUncheckedUpdateManyWithoutNpcNestedInput
    quests?: QuestUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    npcType?: EnumNPCTypeFieldUpdateOperationsInput | $Enums.NPCType
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    dialogue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyWithoutTileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tileX?: IntFieldUpdateOperationsInput | number
    tileY?: IntFieldUpdateOperationsInput | number
    enemyType?: StringFieldUpdateOperationsInput | string
    enemyLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemCreateManyNpcInput = {
    id?: string
    itemId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type QuestCreateManyNpcInput = {
    id?: string
    title: string
    description: string
    questType: $Enums.QuestType
    reward?: string | null
    requirements?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ShopItemUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutShopItemsNestedInput
  }

  export type ShopItemUncheckedUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUncheckedUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUncheckedUpdateManyWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    questType?: EnumQuestTypeFieldUpdateOperationsInput | $Enums.QuestType
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyItemInput = {
    id?: string
    playerId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type ShopItemCreateManyItemInput = {
    id?: string
    npcId: string
    price: number
    stock?: number | null
    createdAt?: Date | string
  }

  export type MarketListingCreateManyItemInput = {
    id?: string
    playerId: string
    quantity: number
    pricePerUnit: number
    totalPrice: number
    listingTax: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    soldAt?: Date | string | null
  }

  export type EquipmentCreateManyWeaponInput = {
    id?: string
    playerId: string
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyHeadInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyChestInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyLegsInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyFeetInput = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    accessory1Id?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyAccessory1Input = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory2Id?: string | null
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyAccessory2Input = {
    id?: string
    playerId: string
    weaponId?: string | null
    headId?: string | null
    chestId?: string | null
    legsId?: string | null
    feetId?: string | null
    accessory1Id?: string | null
    updatedAt?: Date | string
  }

  export type BankVaultItemCreateManyItemInput = {
    id?: string
    accountId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type InventoryItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npc?: NPCUpdateOneRequiredWithoutShopItemsNestedInput
  }

  export type ShopItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketListingUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    player?: PlayerUpdateOneRequiredWithoutMarketListingsNestedInput
  }

  export type MarketListingUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketListingUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    pricePerUnit?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    listingTax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    soldAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutChestInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutChestInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutChestInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutLegsInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutLegsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutLegsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutFeetInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutAccessory1Input = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory2?: ItemUpdateOneWithoutEquippedAsAccessory2NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutAccessory1Input = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutAccessory1Input = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory2Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutAccessory2Input = {
    id?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutEquipmentNestedInput
    weapon?: ItemUpdateOneWithoutEquippedAsWeaponNestedInput
    head?: ItemUpdateOneWithoutEquippedAsHeadNestedInput
    chest?: ItemUpdateOneWithoutEquippedAsChestNestedInput
    legs?: ItemUpdateOneWithoutEquippedAsLegsNestedInput
    feet?: ItemUpdateOneWithoutEquippedAsFeetNestedInput
    accessory1?: ItemUpdateOneWithoutEquippedAsAccessory1NestedInput
  }

  export type EquipmentUncheckedUpdateWithoutAccessory2Input = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyWithoutAccessory2Input = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    weaponId?: NullableStringFieldUpdateOperationsInput | string | null
    headId?: NullableStringFieldUpdateOperationsInput | string | null
    chestId?: NullableStringFieldUpdateOperationsInput | string | null
    legsId?: NullableStringFieldUpdateOperationsInput | string | null
    feetId?: NullableStringFieldUpdateOperationsInput | string | null
    accessory1Id?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutVaultItemsNestedInput
  }

  export type BankVaultItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberCreateManyGuildInput = {
    id?: string
    playerId: string
    role?: $Enums.GuildRole
    joinedAt?: Date | string
  }

  export type GuildQuestCreateManyGuildInput = {
    id?: string
    title: string
    description: string
    reward?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type GuildMemberUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutGuildMemberNestedInput
  }

  export type GuildMemberUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildMemberUncheckedUpdateManyWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    role?: EnumGuildRoleFieldUpdateOperationsInput | $Enums.GuildRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestUncheckedUpdateWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuildQuestUncheckedUpdateManyWithoutGuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemCreateManyAccountInput = {
    id?: string
    itemId: string
    quantity?: number
    createdAt?: Date | string
  }

  export type BankVaultItemUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBankVaultItemsNestedInput
  }

  export type BankVaultItemUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankVaultItemUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}