generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Post {
  id          Int      @id @default(autoincrement())
  name        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([name])
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum UserRole {
  PLAYER
  MODERATOR
  ADMIN
  CONTENT
}

model User {
  id                   String                  @id @default(cuid())
  name                 String?
  email                String                  @unique
  emailVerified        DateTime?
  image                String?
  password             String
  gender               String
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  username             String                  @unique
  role                 UserRole                @default(PLAYER) // Legacy single role for backward compatibility
  // Player created data
  credit               Int                     @default(0) // Player-created credit/currency
  deletedDates         Json? // Array of deletion dates for tracking
  // Moderation fields
  isBanned             Boolean                 @default(false)
  bannedUntil          DateTime?
  banReason            String?
  isMuted              Boolean                 @default(false)
  mutedUntil           DateTime?
  muteReason           String?
  deletedAt            DateTime? // soft delete
  // Account-level flags (banned, admin, tester can be added here)
  accounts             Account[]
  characters           Character[]
  player               Player?
  posts                Post[]
  sessions             Session[]
  profile              PlayerProfile?
  // Note: Battle moved to playerId - battles are character-specific, not account-level
  bankTransactionsFrom BankTransaction[]       @relation("BankTransactionFrom")
  bankTransactionsTo   BankTransaction[]       @relation("BankTransactionTo")
  // Leaderboard stats are account-level aggregations (okay to keep on User)
  leaderboardStats     PlayerLeaderboardStats?
  statsPeriods         PlayerStatsPeriod[]
  adminActions         AdminActionLog[]        @relation("AdminActor")
  // Multi-role support
  roles                UserRoleAssignment[]
  // IP history tracking
  ipHistory            UserIpHistory[]
  // Chat
  chatMessages         ChatMessage[]
  chatReactions        ChatReaction[]
  chatMentions         ChatMention[]           @relation("MentionedUser")
  chatMentionsBy       ChatMention[]           @relation("MentionedBy")
  notifications        Notification[]
}

model Character {
  id             String    @id @default(cuid())
  userId         String
  name           String
  level          Int       @default(1)
  vitality       Int       @default(5)
  strength       Int       @default(5)
  speed          Int       @default(5)
  dexterity      Int       @default(5)
  maxStamina     Int
  currentStamina Int
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  currentHp      Int
  deaths         Int       @default(0)
  permDeaths     Int       @default(0) // Admin-editable permanent death count
  floor          Int       @default(1)
  gender         String
  location       String    @default("Town Square")
  maxHp          Int
  deathAt        DateTime?
  deathReason    String?
  position       Position? // World map position
  user           User      @relation(fields: [userId], references: [id])
}

// Simple position model for character world map tracking
// Separate from MapPosition which is more complex (tile-based)
model Position {
  id          String    @id @default(cuid())
  characterId String    @unique
  x           Int
  y           Int
  zone        String // Zone name/identifier
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@index([x, y])
  @@index([zone])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Player {
  id                         String                @id @default(cuid())
  userId                     String                @unique
  characterName              String                @unique
  level                      Int                   @default(1)
  experience                 Int                   @default(0)
  gold                       Int                   @default(0)
  deathCount                 Int                   @default(0)
  isDeleted                  Boolean               @default(false)
  createdAt                  DateTime              @default(now())
  updatedAt                  DateTime              @updatedAt
  bankAccount                BankAccount?
  battles                    Battle[] // Character-specific battles
  combatLogs                 CombatLog[]
  deathLogs                  DeathLog[]
  equipment                  Equipment?
  guildMember                GuildMember?
  inventory                  InventoryItem[]
  position                   MapPosition?
  marketListings             MarketListing[]
  marketTransactionsAsBuyer  MarketTransaction[]   @relation("Buyer")
  marketTransactionsAsSeller MarketTransaction[]   @relation("Seller")
  occupation                 Occupation?
  user                       User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skills                     PlayerSkill[]
  skillLoadout               PlayerSkillLoadout?
  stats                      PlayerStats?
  userJobs                   UserJob[]
  craftAttempts              CraftAttempt[]
  gatherAttempts             GatherAttempt[]
  trainingSkills             PlayerTrainingSkill[]
  activeTrainingAction       PlayerActiveAction?
  skillActionLogs            SkillActionLog[]

  @@index([characterName])
  @@index([userId])
}

model PlayerStats {
  id             String   @id @default(cuid())
  playerId       String   @unique
  // Base stats (permanent, from level-ups and base character)
  vitalityBase   Int      @default(10)
  strengthBase   Int      @default(10)
  speedBase      Int      @default(10)
  dexterityBase  Int      @default(10)
  // Trained stats (from training, can decay, soft caps apply)
  vitalityTrain  Int      @default(0)
  strengthTrain  Int      @default(0)
  speedTrain     Int      @default(0)
  dexterityTrain Int      @default(0)
  // Computed totals (base + trained) - can be calculated or stored for performance
  vitality       Int      @default(10)
  strength       Int      @default(10)
  speed          Int      @default(10)
  dexterity      Int      @default(10)
  // HP/SP
  maxHP          Int      @default(100)
  currentHP      Int      @default(100)
  maxSP          Int      @default(50)
  currentSP      Int      @default(50)
  statPoints     Int      @default(0)
  hpRegenPerMin  Int      @default(100)
  spRegenPerMin  Int      @default(100)
  lastRegenAt    DateTime @default(now())
  updatedAt      DateTime @updatedAt
  player         Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model World {
  id        String        @id @default(cuid())
  name      String
  width     Int
  height    Int
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  tiles     MapTile[]
  positions MapPosition[]

  @@index([name])
}

model MapTile {
  id           Int           @id @default(autoincrement())
  worldId      String
  x            Int
  y            Int
  tileType     TileType
  zoneType     ZoneType
  isSafeZone   Boolean       @default(false)
  hasResource  Boolean       @default(false)
  resourceType ResourceType?
  description  String?
  meta         Json? // JSON for additional tile metadata
  encounters   Encounter[]
  positions    MapPosition[]
  npcs         NPC[]
  world        World         @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@unique([worldId, x, y])
  @@index([worldId, x, y])
  @@index([tileType])
  @@index([zoneType])
  @@index([worldId])
}

model MapPosition {
  id              String   @id @default(cuid())
  playerId        String   @unique
  worldId         String
  tileX           Int
  tileY           Int
  tileId          Int?
  discoveredTiles Json? // boolean[] for discovered tiles (length = width * height)
  updatedAt       DateTime @updatedAt
  player          Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tile            MapTile? @relation(fields: [tileId], references: [id])
  world           World    @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@index([tileX, tileY])
  @@index([worldId])
}

model NPC {
  id        String     @id @default(cuid())
  name      String
  npcType   NPCType
  tileX     Int
  tileY     Int
  tileId    Int?
  dialogue  String?
  createdAt DateTime   @default(now())
  tile      MapTile?   @relation(fields: [tileId], references: [id])
  quests    Quest[]
  shopItems ShopItem[]

  @@index([tileX, tileY])
  @@index([npcType])
  @@index([tileId])
}

model ShopItem {
  id        String   @id @default(cuid())
  npcId     String
  itemId    String
  price     Int
  stock     Int?
  createdAt DateTime @default(now())
  item      Item     @relation(fields: [itemId], references: [id])
  npc       NPC      @relation(fields: [npcId], references: [id], onDelete: Cascade)
}

model Item {
  id                 String              @id @default(cuid())
  key                String?             @unique
  name               String
  description        String?
  itemType           ItemType            @default(MATERIAL)
  itemRarity         ItemRarity
  tier               Int                 @default(1)
  value              Int
  stackable          Boolean             @default(false)
  maxStack           Int                 @default(999)
  equipmentSlot      EquipmentSlot?
  vitalityBonus      Int                 @default(0)
  strengthBonus      Int                 @default(0)
  speedBonus         Int                 @default(0)
  dexterityBonus     Int                 @default(0)
  hpBonus            Int                 @default(0)
  spBonus            Int                 @default(0)
  defenseBonus       Int                 @default(0)
  isTradeable        Boolean             @default(true)
  isActive           Boolean             @default(true)
  tags               String[]            @default([])
  createdAt          DateTime            @default(now())
  bankVaultItems     BankVaultItem[]
  equippedAsHead     Equipment[]         @relation("Head")
  equippedAsLeftArm  Equipment[]         @relation("LeftArm")
  equippedAsRightArm Equipment[]         @relation("RightArm")
  equippedAsBody     Equipment[]         @relation("Body")
  equippedAsLegs     Equipment[]         @relation("Legs")
  equippedAsFeet     Equipment[]         @relation("Feet")
  equippedAsRing1    Equipment[]         @relation("Ring1")
  equippedAsRing2    Equipment[]         @relation("Ring2")
  equippedAsRing3    Equipment[]         @relation("Ring3")
  equippedAsNecklace Equipment[]         @relation("Necklace")
  equippedAsBelt     Equipment[]         @relation("Belt")
  equippedAsCloak    Equipment[]         @relation("Cloak")
  inventoryItems     InventoryItem[]
  marketListings     MarketListing[]
  marketTransactions MarketTransaction[]
  shopItems          ShopItem[]
  recipeOutputs      Recipe[]            @relation("RecipeOutput")
  recipeInputs       RecipeInput[]       @relation("RecipeInput")
  nodeYields         NodeYield[]         @relation("NodeYield")
  skillActionInputs  SkillActionInput[]  @relation("SkillActionInput")
  skillActionOutputs SkillActionOutput[] @relation("SkillActionOutput")
  dropTableEntries   DropTableEntry[]
  itemEffects        ItemEffect[]        @relation("ItemEffect")

  @@index([itemType])
  @@index([itemRarity])
  @@index([tier])
  @@index([isActive])
}

model InventoryItem {
  id        String   @id @default(cuid())
  playerId  String
  itemId    String
  quantity  Int      @default(1) // Must be >= 0, enforced at application level
  createdAt DateTime @default(now())
  item      Item     @relation(fields: [itemId], references: [id])
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  // Note: Stack safety enforced in application logic (quantity >= 0, quantity <= item.maxStack if stackable)

  @@unique([playerId, itemId])
  @@index([playerId])
  @@index([itemId])
}

model Equipment {
  id             String   @id @default(cuid())
  playerId       String   @unique
  headItemId     String?
  leftArmItemId  String?
  rightArmItemId String?
  bodyItemId     String?
  legsItemId     String?
  feetItemId     String?
  ring1ItemId    String?
  ring2ItemId    String?
  ring3ItemId    String?
  necklaceItemId String?
  beltItemId     String?
  cloakItemId    String?
  updatedAt      DateTime @updatedAt
  head           Item?    @relation("Head", fields: [headItemId], references: [id])
  leftArm        Item?    @relation("LeftArm", fields: [leftArmItemId], references: [id])
  rightArm       Item?    @relation("RightArm", fields: [rightArmItemId], references: [id])
  body           Item?    @relation("Body", fields: [bodyItemId], references: [id])
  legs           Item?    @relation("Legs", fields: [legsItemId], references: [id])
  feet           Item?    @relation("Feet", fields: [feetItemId], references: [id])
  ring1          Item?    @relation("Ring1", fields: [ring1ItemId], references: [id])
  ring2          Item?    @relation("Ring2", fields: [ring2ItemId], references: [id])
  ring3          Item?    @relation("Ring3", fields: [ring3ItemId], references: [id])
  necklace       Item?    @relation("Necklace", fields: [necklaceItemId], references: [id])
  belt           Item?    @relation("Belt", fields: [beltItemId], references: [id])
  cloak          Item?    @relation("Cloak", fields: [cloakItemId], references: [id])
  player         Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model Occupation {
  id           String               @id @default(cuid())
  playerId     String               @unique
  primaryJob   PrimaryOccupation?
  secondaryJob SecondaryOccupation?
  level        Int                  @default(1)
  experience   Int                  @default(0)
  updatedAt    DateTime             @updatedAt
  player       Player               @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model Skill {
  id            String               @id @default(cuid())
  key           String               @unique
  slug          String               @unique
  // Global taxonomy fields
  name          String
  description   String?
  tags          Json? // Array of strings: ["combat", "fire", "starter"]
  status        ContentStatus        @default(DRAFT)
  version       Int                  @default(1)
  createdBy     String?
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  // Legacy archive field
  isArchived    Boolean              @default(false)
  // Skill-specific fields
  staminaCost   Int                  @default(0)
  cooldownTurns Int                  @default(0) // Cooldown in turns
  castTimeTurns Int                  @default(0) // Cast time in turns
  levelUnlock   Int? // Level required to unlock this skill
  // Categorization
  skillType     SkillType            @default(ATTACK)
  damageType    DamageType? // Required for ATTACK skills
  // Cost/Pacing
  hits          Int                  @default(1)
  targeting     SkillTargeting       @default(SINGLE)
  maxTargets    Int? // Required when targeting != SINGLE
  // Damage Definition
  basePower     Int? // Required when skillType=ATTACK or has damage effects
  scalingStat   StatType? // Stat that scales damage
  scalingRatio  Float                @default(1.0)
  flatBonus     Int                  @default(0)
  // Relations
  playerSkills  PlayerSkill[]
  slot1Loadouts PlayerSkillLoadout[] @relation("Slot1")
  slot2Loadouts PlayerSkillLoadout[] @relation("Slot2")
  slot3Loadouts PlayerSkillLoadout[] @relation("Slot3")
  slot4Loadouts PlayerSkillLoadout[] @relation("Slot4")
  slot5Loadouts PlayerSkillLoadout[] @relation("Slot5")
  slot6Loadouts PlayerSkillLoadout[] @relation("Slot6")
  slot7Loadouts PlayerSkillLoadout[] @relation("Slot7")
  slot8Loadouts PlayerSkillLoadout[] @relation("Slot8")
  effects       SkillEffect[]

  @@index([key])
  @@index([slug])
  @@index([status])
  @@index([isArchived])
  @@index([skillType])
  @@index([createdBy])
}

model SkillEffect {
  id                String          @id @default(cuid())
  skillId           String
  type              SkillEffectType
  stat              StatType? // Required for BUFF_STAT/DEBUFF_STAT
  value             Int // Meaning depends on type
  ratio             Float? // Scaling component (optional)
  durationTurns     Int             @default(0) // 0 means instantaneous
  chance            Float           @default(1.0) // 0-1
  tickIntervalTurns Int             @default(1) // For DOT/HOT
  maxStacks         Int             @default(1)
  note              String? // Designer notes
  ordering          Int             @default(0) // Execution/display order
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  skill             Skill           @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@index([skillId, ordering])
  @@index([skillId])
}

model PlayerSkill {
  id        String   @id @default(cuid())
  playerId  String
  skillId   String
  learnedAt DateTime @default(now())
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  skill     Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([playerId, skillId])
  @@index([playerId])
  @@index([skillId])
}

model PlayerSkillLoadout {
  id           String   @id @default(cuid())
  playerId     String   @unique
  slot1SkillId String?
  slot2SkillId String?
  slot3SkillId String?
  slot4SkillId String?
  slot5SkillId String?
  slot6SkillId String?
  slot7SkillId String?
  slot8SkillId String?
  updatedAt    DateTime @updatedAt
  player       Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  slot1Skill   Skill?   @relation("Slot1", fields: [slot1SkillId], references: [id])
  slot2Skill   Skill?   @relation("Slot2", fields: [slot2SkillId], references: [id])
  slot3Skill   Skill?   @relation("Slot3", fields: [slot3SkillId], references: [id])
  slot4Skill   Skill?   @relation("Slot4", fields: [slot4SkillId], references: [id])
  slot5Skill   Skill?   @relation("Slot5", fields: [slot5SkillId], references: [id])
  slot6Skill   Skill?   @relation("Slot6", fields: [slot6SkillId], references: [id])
  slot7Skill   Skill?   @relation("Slot7", fields: [slot7SkillId], references: [id])
  slot8Skill   Skill?   @relation("Slot8", fields: [slot8SkillId], references: [id])

  @@index([playerId])
}

model Encounter {
  id         String      @id @default(cuid())
  tileX      Int
  tileY      Int
  tileId     Int?
  enemyType  String
  enemyLevel Int
  isActive   Boolean     @default(true)
  createdAt  DateTime    @default(now())
  combatLogs CombatLog[]
  tile       MapTile?    @relation(fields: [tileId], references: [id])

  @@index([tileX, tileY])
  @@index([tileId])
  @@index([isActive])
}

model CombatLog {
  id          String     @id @default(cuid())
  playerId    String
  encounterId String?
  turnNumber  Int
  action      String
  result      String
  createdAt   DateTime   @default(now())
  encounter   Encounter? @relation(fields: [encounterId], references: [id])
  player      Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([encounterId])
}

model DeathLog {
  id        String   @id @default(cuid())
  playerId  String // Character/Player ID (character-specific death tracking)
  cause     String // Cause of death (required for permadeath integrity)
  location  String? // Location/zone where death occurred
  locationX Int? // X coordinate if applicable
  locationY Int? // Y coordinate if applicable
  createdAt DateTime @default(now())
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([createdAt])
}

model DeathRecord {
  id            String   @id @default(cuid())
  characterName String
  userId        String?
  floorReached  Int
  causeOfDeath  String
  deathsUsed    Int
  createdAt     DateTime @default(now())
}

model Guild {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?
  level       Int           @default(1)
  gold        Int           @default(0)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  bank        GuildBank?
  members     GuildMember[]
  quests      GuildQuest[]

  @@index([name])
}

model GuildMember {
  id       String    @id @default(cuid())
  playerId String    @unique
  guildId  String
  role     GuildRole @default(MEMBER)
  joinedAt DateTime  @default(now())
  guild    Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  player   Player    @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([guildId])
}

model GuildBank {
  id        String   @id @default(cuid())
  guildId   String   @unique
  gold      Int      @default(0)
  updatedAt DateTime @updatedAt
  guild     Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
}

model GuildQuest {
  id          String   @id @default(cuid())
  guildId     String
  title       String
  description String
  reward      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  guild       Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([isActive])
}

model BankAccount {
  id                    String            @id @default(cuid())
  playerId              String            @unique
  balanceCoins          Int               @default(0)
  lastInterestClaimedAt DateTime? // When user manually claimed interest
  lastInterestApplied   DateTime? // When automatic interest was last applied (audit safety)
  vaultLevel            Int               @default(1)
  updatedAt             DateTime          @updatedAt
  player                Player            @relation(fields: [playerId], references: [id], onDelete: Cascade)
  vaultItems            BankVaultItem[]
  transactions          BankTransaction[]
}

model BankVaultItem {
  id        String      @id @default(cuid())
  accountId String
  itemId    String
  quantity  Int         @default(1)
  createdAt DateTime    @default(now())
  account   BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  item      Item        @relation(fields: [itemId], references: [id])

  @@index([accountId])
  @@index([itemId])
}

model BankTransaction {
  id          String              @id @default(cuid())
  type        BankTransactionType
  amountCoins Int
  fromUserId  String?
  toUserId    String?
  note        String?
  accountId   String?
  createdAt   DateTime            @default(now())
  account     BankAccount?        @relation(fields: [accountId], references: [id], onDelete: Cascade)
  fromUser    User?               @relation("BankTransactionFrom", fields: [fromUserId], references: [id])
  toUser      User?               @relation("BankTransactionTo", fields: [toUserId], references: [id])

  @@index([fromUserId])
  @@index([toUserId])
  @@index([accountId])
  @@index([createdAt])
}

enum BankTransactionType {
  TRANSFER
  DEPOSIT
  WITHDRAW
  INTEREST
}

model MarketListing {
  id           String              @id @default(cuid())
  playerId     String
  itemId       String
  quantity     Int
  pricePerUnit Int
  totalPrice   Int
  listingTax   Int
  isActive     Boolean             @default(true)
  expiresAt    DateTime?
  createdAt    DateTime            @default(now())
  soldAt       DateTime?
  item         Item                @relation(fields: [itemId], references: [id])
  player       Player              @relation(fields: [playerId], references: [id], onDelete: Cascade)
  transactions MarketTransaction[]

  @@index([playerId])
  @@index([itemId])
  @@index([isActive])
  @@index([expiresAt])
}

model MarketTransaction {
  id         String        @id @default(cuid())
  listingId  String
  buyerId    String
  sellerId   String
  itemId     String
  quantity   Int
  totalPrice Int
  createdAt  DateTime      @default(now())
  buyer      Player        @relation("Buyer", fields: [buyerId], references: [id], onDelete: Cascade)
  item       Item          @relation(fields: [itemId], references: [id])
  listing    MarketListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  seller     Player        @relation("Seller", fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([buyerId])
  @@index([sellerId])
  @@index([listingId])
  @@index([itemId])
}

model Quest {
  id           String    @id @default(cuid())
  npcId        String?
  title        String
  description  String
  questType    QuestType
  reward       String?
  requirements String?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  npc          NPC?      @relation(fields: [npcId], references: [id])

  @@index([npcId])
  @@index([isActive])
  @@index([questType])
}

enum TileType {
  GRASS
  FOREST
  MOUNTAIN
  RIVER
  DESERT
  DUNGEON
  TOWN
  SHRINE
  ROAD
  PLAIN
  WATER
  // New versioned map tile types
  GROUND
  WALL
  DOOR
  PORTAL
  POI
}

enum ZoneType {
  SAFE
  LOW_DANGER
  MEDIUM_DANGER
  HIGH_DANGER
  EXTREME_DANGER
}

enum ResourceType {
  ORE
  HERB
  FISH
  WOOD
  RARE_ITEM
}

enum NPCType {
  MERCHANT
  QUEST_GIVER
  TRAINER
  BANKER
  GUILD_MASTER
  GUARD
  TAVERN_KEEPER
}

enum ItemType {
  WEAPON
  ARMOR
  ACCESSORY
  CONSUMABLE
  MATERIAL
  QUEST_ITEM
  TOOL
  EQUIPMENT
  QUEST
  CURRENCY
  KEY
  MISC
}

enum ItemRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum EquipmentSlot {
  HEAD
  ARMS
  BODY
  LEGS
  FEET
  RING
  NECKLACE
  BELT
  CLOAK
  OFFHAND
  MAINHAND
}

enum PrimaryOccupation {
  BLACKSMITH
  ALCHEMIST
  COOK
  TAILOR
  MERCHANT
  BEAST_HANDLER
}

enum SecondaryOccupation {
  MINER
  HERBALIST
  FISHER
  LOGGER
  FORAGER
}

enum GuildRole {
  LEADER
  OFFICER
  MEMBER
}

enum QuestType {
  KILL
  GATHER
  DELIVER
  EXPLORE
  CRAFT
}

enum QuestRepeatability {
  ONCE
  DAILY
  WEEKLY
  REPEATABLE
}

enum QuestStepType {
  KILL_ENEMY
  GATHER_ITEM
  CRAFT_ITEM
  VISIT_LOCATION
  DELIVER_ITEM
  TALK_TO_NPC
  INTERACT_NODE
}

enum QuestRewardType {
  XP_CHARACTER
  XP_OCCUPATION
  ITEM
  GOLD
  RECIPE_UNLOCK
  SKILL_UNLOCK
}

enum JobCategory {
  CRAFT
  GATHER
}

enum CraftingStation {
  SMELTER
  ANVIL
  FORGE
  TEMPERING_RACK
}

model Job {
  id             String          @id @default(cuid())
  key            String          @unique
  name           String
  description    String?
  category       JobCategory
  icon           String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  userJobs       UserJob[]
  recipes        Recipe[]
  nodes          GatheringNode[]
  trainingSkills TrainingSkill[]

  @@index([category])
  @@index([key])
}

model UserJob {
  id        String   @id @default(cuid())
  playerId  String
  jobId     String
  level     Int      @default(1)
  xp        Int      @default(0)
  active    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([playerId, jobId])
  @@index([playerId])
  @@index([jobId])
}

model Recipe {
  id                       String             @id @default(cuid())
  // Global taxonomy fields
  name                     String
  description              String?
  tags                     Json? // Array of strings: ["weapon", "tier1", "starter"]
  status                   ContentStatus      @default(DRAFT)
  version                  Int                @default(1)
  createdBy                String?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  // Recipe-specific fields
  jobId                    String
  difficulty               Int                @default(1)
  requiredJobLevel         Int                @default(1)
  outputItemId             String
  outputQty                Int                @default(1)
  // Station and crafting details
  station                  CraftingStation? // Legacy enum (for backward compatibility with blacksmith)
  stationDefinitionId      String? // Data-driven station reference (for alchemy and future)
  category                 String? // Recipe category (e.g., "POTION", "BREW", "OIL", "POWDER", "SALVE", "ELIXIR", "BOMB", "UTILITY")
  craftTimeSeconds         Int                @default(0)
  xp                       Int                @default(0)
  successRate              Float? // Nullable: null means use calculated rate, 0-1 means override
  isDiscoverable           Boolean            @default(false)
  isActive                 Boolean            @default(true)
  // Validation override
  allowNonGatherableInputs Boolean            @default(false)
  sourceGatherJobKey       String? // e.g., "miner" for blacksmith recipes that use miner items
  job                      Job                @relation(fields: [jobId], references: [id], onDelete: Cascade)
  outputItem               Item               @relation("RecipeOutput", fields: [outputItemId], references: [id])
  stationDefinition        StationDefinition? @relation(fields: [stationDefinitionId], references: [id], onDelete: SetNull)
  inputs                   RecipeInput[]
  craftAttempts            CraftAttempt[]

  @@index([jobId])
  @@index([outputItemId])
  @@index([status])
  @@index([createdBy])
  @@index([requiredJobLevel])
  @@index([station])
  @@index([stationDefinitionId])
  @@index([category])
  @@index([isActive])
}

model RecipeInput {
  id        String   @id @default(cuid())
  recipeId  String
  itemId    String
  qty       Int      @default(1)
  createdAt DateTime @default(now())
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  item      Item     @relation("RecipeInput", fields: [itemId], references: [id])

  @@index([recipeId])
  @@index([itemId])
}

model CraftAttempt {
  id        String   @id @default(cuid())
  playerId  String
  recipeId  String
  success   Boolean
  xpGained  Int
  createdAt DateTime @default(now())
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@index([playerId, createdAt])
  @@index([recipeId, createdAt])
  @@index([playerId])
  @@index([recipeId])
  @@index([createdAt])
}

// Data-driven crafting station definitions (editable via Content Panel)
model StationDefinition {
  id          String        @id @default(cuid())
  key         String        @unique
  // Global taxonomy fields
  name        String
  description String?
  tags        Json? // Array of strings: ["alchemy", "basic", "advanced"]
  status      ContentStatus @default(DRAFT)
  version     Int           @default(1)
  createdBy   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  // Station-specific fields
  stationType String // e.g., "ALCHEMY", "BLACKSMITH" - profession this station belongs to
  unlockLevel Int           @default(1) // Required job level to unlock
  isEnabled   Boolean       @default(true)
  metadata    Json? // Additional station properties (speed modifier, bonus XP, etc.)
  recipes     Recipe[] // Recipes that use this station

  @@index([key])
  @@index([status])
  @@index([stationType])
  @@index([unlockLevel])
  @@index([isEnabled])
  @@index([createdBy])
}

// Data-driven effect definitions for consumables (potions, oils, bombs, etc.)
model EffectDefinition {
  id              String        @id @default(cuid())
  key             String        @unique
  // Global taxonomy fields
  name            String
  description     String?
  tags            Json? // Array of strings: ["healing", "combat", "utility"]
  status          ContentStatus @default(DRAFT)
  version         Int           @default(1)
  createdBy       String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  // Effect-specific fields
  type            String // "HEAL_INSTANT" | "HEAL_REGEN" | "STAMINA_RESTORE" | "BUFF_STAT" | "RESISTANCE" | "DAMAGE_OVER_TIME" | "UTILITY"
  magnitude       Float         @default(0) // Effect strength (healing amount, damage, stat bonus, etc.)
  durationSeconds Int? // Nullable: null means instant, >0 means duration-based
  tickSeconds     Int? // For DOT/HOT effects: interval between ticks
  stackingRule    String        @default("NONE") // "NONE" | "REFRESH" | "STACK" | "REPLACE_WEAKER"
  pvpScalar       Float? // PvP modifier (e.g., 0.5 = 50% effectiveness in PvP)
  cooldownSeconds Int? // Cooldown before effect can be applied again
  metadata        Json? // Additional effect data (stat type for BUFF_STAT, resistance type, etc.)
  itemEffects     ItemEffect[] // Items that have this effect

  @@index([key])
  @@index([status])
  @@index([type])
  @@index([createdBy])
}

// Join table: Item <-> EffectDefinition (many-to-many)
// Items can have multiple effects, effects can be on multiple items
model ItemEffect {
  id        String           @id @default(cuid())
  itemId    String
  effectId  String
  ordering  Int              @default(0) // Execution order if item has multiple effects
  createdAt DateTime         @default(now())
  item      Item             @relation("ItemEffect", fields: [itemId], references: [id], onDelete: Cascade)
  effect    EffectDefinition @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@unique([itemId, effectId, ordering])
  @@index([itemId])
  @@index([effectId])
  @@index([ordering])
}

model GatheringNode {
  id                String          @id @default(cuid())
  key               String          @unique
  // Global taxonomy fields
  name              String
  description       String?
  tags              Json? // Array of strings: ["ore", "tier1", "safe"]
  status            ContentStatus   @default(DRAFT)
  version           Int             @default(1)
  createdBy         String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  // Node-specific fields
  jobId             String
  dangerTier        Int             @default(1)
  tier              Int             @default(1)
  requiredJobLevel  Int             @default(1)
  gatherTimeSeconds Int             @default(30)
  xpReward          Int             @default(10)
  cooldownSeconds   Int?
  isActive          Boolean         @default(true)
  job               Job             @relation(fields: [jobId], references: [id], onDelete: Cascade)
  yields            NodeYield[]
  gatherAttempts    GatherAttempt[]

  @@index([jobId])
  @@index([key])
  @@index([status])
  @@index([createdBy])
  @@index([tier])
  @@index([requiredJobLevel])
  @@index([isActive])
}

model NodeYield {
  id        String        @id @default(cuid())
  nodeId    String
  itemId    String
  minQty    Int           @default(1)
  maxQty    Int           @default(1)
  chance    Float? // nullable for now; if null treat as 1.0
  weight    Int           @default(100) // legacy field, kept for backwards compatibility
  createdAt DateTime      @default(now())
  node      GatheringNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  item      Item          @relation("NodeYield", fields: [itemId], references: [id])

  @@index([nodeId])
  @@index([itemId])
}

model GatherAttempt {
  id        String        @id @default(cuid())
  playerId  String
  nodeId    String
  success   Boolean
  xpGained  Int
  createdAt DateTime      @default(now())
  player    Player        @relation(fields: [playerId], references: [id], onDelete: Cascade)
  node      GatheringNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  @@index([playerId, createdAt])
  @@index([nodeId, createdAt])
  @@index([playerId])
  @@index([nodeId])
  @@index([createdAt])
}

model PlayerProfile {
  id           String              @id @default(cuid())
  userId       String              @unique
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  profileStats PlayerProfileStats?
  pvpRecord    PlayerPvpRecord?
  pveRecord    PlayerPveRecord?
  social       PlayerSocial?
  achievements PlayerAchievement[]

  @@index([userId])
}

model PlayerProfileStats {
  id        String        @id @default(cuid())
  profileId String        @unique
  vitality  Int           @default(10)
  strength  Int           @default(10)
  speed     Int           @default(10)
  dexterity Int           @default(10)
  updatedAt DateTime      @updatedAt
  profile   PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model PlayerPvpRecord {
  id                  String        @id @default(cuid())
  profileId           String        @unique
  wins                Int           @default(0)
  losses              Int           @default(0)
  pvpWinStreakCurrent Int           @default(0)
  pvpWinStreakBest    Int           @default(0)
  updatedAt           DateTime      @updatedAt
  profile             PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model PlayerPveRecord {
  id          String        @id @default(cuid())
  profileId   String        @unique
  totalKills  Int           @default(0)
  bossesSlain Int           @default(0)
  deathsUsed  Int           @default(0)
  deathsLimit Int           @default(5)
  updatedAt   DateTime      @updatedAt
  profile     PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model Achievement {
  id          String              @id @default(cuid())
  key         String              @unique
  name        String
  description String?
  icon        String?
  rarity      AchievementRarity   @default(COMMON)
  createdAt   DateTime            @default(now())
  players     PlayerAchievement[]

  @@index([key])
}

model PlayerAchievement {
  id            String        @id @default(cuid())
  profileId     String
  achievementId String
  unlockedAt    DateTime      @default(now())
  profile       PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  achievement   Achievement   @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([profileId, achievementId])
  @@index([profileId])
  @@index([achievementId])
}

model PlayerSocial {
  id                     String        @id @default(cuid())
  profileId              String        @unique
  guildName              String?
  title                  String?
  tagline                String?
  journal                String? // BBCode journal for public profile display
  commendationsHelpful   Int           @default(0)
  commendationsSkilled   Int           @default(0)
  commendationsStrategic Int           @default(0)
  friendsCount           Int           @default(0)
  guildRole              String?
  updatedAt              DateTime      @updatedAt
  profile                PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

enum AchievementRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum ContentStatus {
  DRAFT
  ACTIVE
  DISABLED
  PUBLISHED
  ARCHIVED
}

enum TileOverlay {
  NONE
  SAFEZONE
  DANGER
  TOWN
  DUNGEON
  RESOURCE_RICH
}

enum POIType {
  NPC
  SHOP
  BANK
  GUILD_HALL
  PORTAL
  SHRINE
  QUEST_BOARD
}

enum SkillType {
  ATTACK
  BUFF
  HEAL
  UTILITY
  DEBUFF
}

enum DamageType {
  PHYSICAL
  MAGIC
  TRUE
}

enum SkillTargeting {
  SINGLE
  MULTI
  AOE
}

enum StatType {
  VITALITY
  STRENGTH
  SPEED
  DEXTERITY
}

enum SkillEffectType {
  DAMAGE
  HEAL
  BUFF_STAT
  DEBUFF_STAT
  DOT
  HOT
  STUN
  SILENCE
  TAUNT
  SHIELD
  CLEANSE
  DISPEL
}

enum BattleStatus {
  ACTIVE
  WON
  LOST
  FLED
}

model Monster {
  id         String   @id @default(cuid())
  key        String   @unique
  name       String
  level      Int      @default(1)
  vitality   Int
  strength   Int
  speed      Int
  dexterity  Int
  maxHp      Int
  xpReward   Int      @default(0)
  goldReward Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  battles    Battle[]

  @@index([level])
  @@index([key])
}

model Battle {
  id         String       @id @default(cuid())
  playerId   String // Changed from userId - battles are character-specific, not account-level
  monsterId  String
  status     BattleStatus @default(ACTIVE)
  turnNumber Int          @default(1)
  playerHp   Int
  playerSp   Int
  monsterHp  Int
  log        Json         @default("[]")
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  player     Player       @relation(fields: [playerId], references: [id], onDelete: Cascade)
  monster    Monster      @relation(fields: [monsterId], references: [id])

  @@index([playerId])
  @@index([status])
  @@index([playerId, status])
}

model PlayerLeaderboardStats {
  userId     String   @id
  pveKills   Int      @default(0)
  pvpKills   Int      @default(0)
  pvpWins    Int      @default(0)
  pvpLosses  Int      @default(0)
  jobXpTotal Int      @default(0)
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([pveKills])
  @@index([pvpKills])
  @@index([jobXpTotal])
}

model PlayerStatsPeriod {
  id          String   @id @default(cuid())
  userId      String
  periodType  String // "daily" | "weekly"
  periodStart DateTime
  pveKills    Int      @default(0)
  pvpKills    Int      @default(0)
  pvpWins     Int      @default(0)
  pvpLosses   Int      @default(0)
  jobXpTotal  Int      @default(0)
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, periodType, periodStart])
  @@index([periodType, periodStart])
  @@index([userId, periodType, periodStart])
}

// Admin & Moderation
model AdminActionLog {
  id                String   @id @default(cuid())
  actorId           String
  targetUserId      String?
  targetCharacterId String?
  action            String
  reason            String?
  metadata          Json?
  createdAt         DateTime @default(now())
  actor             User     @relation("AdminActor", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([targetUserId, createdAt])
  @@index([targetCharacterId, createdAt])
  @@index([actorId, createdAt])
}

// Audit & Event Logging
model AuditEvent {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  actorUserId      String?
  actorCharacterId String?
  targetUserId     String?
  targetEntityType String? // e.g. "User", "EnemyTemplate", "DropTable"
  targetEntityId   String?
  action           String // e.g. "USER_BANNED", "ROLE_GRANTED", "CONTENT_UPDATED"
  reason           String?
  payloadJson      Json
  ipAddress        String?
  userAgent        String?

  @@index([createdAt])
  @@index([actorUserId, createdAt])
  @@index([targetUserId, createdAt])
  @@index([targetEntityType, targetEntityId])
}

// Content Templates (Game CMS)
// Global Content Taxonomy: All templates share common metadata
model ItemTemplate {
  id            String         @id @default(cuid())
  // Global taxonomy fields
  name          String
  description   String?
  tags          Json? // Array of strings: ["fire", "starter", "rare"]
  status        ContentStatus  @default(DRAFT)
  version       Int            @default(1)
  createdBy     String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  // Item-specific fields
  itemType      ItemType?
  equipmentSlot EquipmentSlot?
  rarity        ItemRarity     @default(COMMON)
  stackable     Boolean        @default(false)
  maxStack      Int            @default(1)
  value         Int            @default(0)
  damage        Int            @default(0) // Damage value for weapons
  statsJSON     Json? // Item stats: { vitality, strength, speed, dexterity, hp, sp, defense }
  icon          String?
  // Legacy fields (kept for backward compatibility)
  isArchived    Boolean        @default(false)
  deletedAt     DateTime?

  @@index([status])
  @@index([isArchived])
  @@index([rarity])
  @@index([createdBy])
}

model MonsterTemplate {
  id          String        @id @default(cuid())
  // Global taxonomy fields
  name        String
  description String?
  tags        Json? // Array of strings: ["boss", "fire", "rare"]
  status      ContentStatus @default(DRAFT)
  version     Int           @default(1)
  createdBy   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  // Monster-specific fields
  level       Int           @default(1)
  hp          Int
  sp          Int           @default(0)
  damage      Int           @default(0) // Base damage the monster deals
  goldReward  Int           @default(0) // Coins/gold rewarded when defeated
  statsJSON   Json // { vitality, strength, speed, dexterity }
  lootTableId String?
  // Legacy fields
  isArchived  Boolean       @default(false)
  deletedAt   DateTime?

  @@index([status])
  @@index([isArchived])
  @@index([level])
  @@index([createdBy])
}

model QuestTemplate {
  id                  String             @id @default(cuid())
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  // Identity fields
  name                String
  slug                String             @unique
  description         String?
  // Status and workflow
  status              ContentStatus      @default(DRAFT)
  // Quest configuration
  repeatability       QuestRepeatability @default(ONCE)
  recommendedMinLevel Int?
  occupationType      String? // Optional: reference to occupation type
  prerequisiteQuestId String?
  prerequisiteQuest   QuestTemplate?     @relation("QuestPrerequisites", fields: [prerequisiteQuestId], references: [id], onDelete: SetNull)
  prerequisiteFor     QuestTemplate[]    @relation("QuestPrerequisites")
  // Start trigger (optional)
  startTriggerType    String? // MANUAL | ON_ENTER_TILE | ON_INTERACT_POI
  startTriggerRefId   String? // tileId/poiId etc
  // Relations
  steps               QuestStep[]
  rewards             QuestReward[]

  @@index([slug])
  @@index([status])
  @@index([repeatability])
  @@index([prerequisiteQuestId])
  @@index([createdAt])
}

model QuestStep {
  id             String        @id @default(cuid())
  questId        String
  quest          QuestTemplate @relation(fields: [questId], references: [id], onDelete: Cascade)
  ordering       Int // Step order (1-based, must be contiguous)
  type           QuestStepType
  title          String? // Short label for the step
  description    String? // Player-facing description
  targetRefType  String? // EnemyTemplate | Item | MapTile | NPC | ResourceNode etc.
  targetRefId    String? // ID of the target entity
  quantity       Int           @default(1) // Required quantity (e.g., kill 10, gather 5)
  conditionsJson Json? // Future: time windows, must be in map zone, etc.
  isOptional     Boolean       @default(false)

  @@unique([questId, ordering])
  @@index([questId])
  @@index([type])
}

model QuestReward {
  id          String          @id @default(cuid())
  questId     String
  quest       QuestTemplate   @relation(fields: [questId], references: [id], onDelete: Cascade)
  type        QuestRewardType
  refId       String? // Item ID, Recipe ID, Skill ID, etc. (depending on type)
  amount      Int             @default(0) // XP amount, gold amount, item quantity
  probability Float           @default(1.0) // 0.0-1.0, for random rewards
  notes       String? // Designer notes

  @@index([questId])
  @@index([type])
}

model MapZone {
  id             String        @id @default(cuid())
  // Global taxonomy fields
  name           String
  description    String?
  tags           Json? // Array of strings: ["starter", "dungeon", "safe"]
  status         ContentStatus @default(DRAFT)
  version        Int           @default(1)
  createdBy      String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  // Map-specific fields
  width          Int
  height         Int
  tilesJSON      Json // Tile data structure
  poisJSON       Json? // Points of interest
  spawnJSON      Json? // Spawn data
  coinsReward    Int           @default(0) // Base coins available in this map zone
  damageModifier Int           @default(0) // Damage modifier for this map (environmental hazards, etc.)
  // Legacy fields
  isArchived     Boolean       @default(false)
  deletedAt      DateTime?

  @@index([status])
  @@index([isArchived])
  @@index([createdBy])
}

// Multi-role support: Many-to-many relationship between User and UserRole
model UserRoleAssignment {
  id         String   @id @default(cuid())
  userId     String
  role       UserRole
  assignedAt DateTime @default(now())
  assignedBy String? // Admin who assigned the role
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([userId])
  @@index([role])
}

// IP history tracking for moderation
model UserIpHistory {
  id        String   @id @default(cuid())
  userId    String
  ipAddress String
  userAgent String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([ipAddress])
}

// ============================================
// Melvor-Inspired Skill Training System
// ============================================

enum SkillCategory {
  GATHERING
  PROCESSING
  COMBAT
  UTILITY
}

// Training Skill (e.g., Mining, Cooking, Crafting, Alchemy)
model TrainingSkill {
  id           String                @id @default(cuid())
  key          String                @unique
  // Global taxonomy fields
  name         String
  description  String?
  tags         Json? // Array of strings: ["gathering", "starter"]
  status       ContentStatus         @default(DRAFT)
  version      Int                   @default(1)
  createdBy    String?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  // Skill-specific fields
  category     SkillCategory
  maxLevel     Int                   @default(99) // Melvor-style cap (or scalable)
  xpCurveBase  Float                 @default(1.15) // Exponential curve base (Melvor uses ~1.15)
  icon         String?
  // Job relationship (optional - skills can be job-specific or general)
  jobId        String?
  job          Job?                  @relation(fields: [jobId], references: [id], onDelete: SetNull)
  // Relations
  actions      SkillAction[]
  playerSkills PlayerTrainingSkill[]

  @@index([key])
  @@index([status])
  @@index([category])
  @@index([createdBy])
  @@index([jobId])
}

// Skill Action - Repeatable task that trains a skill (e.g., "Mine Iron", "Cook Meat")
model SkillAction {
  id                   String               @id @default(cuid())
  key                  String               @unique
  // Global taxonomy fields
  name                 String
  description          String?
  tags                 Json? // Array of strings: ["tier1", "starter"]
  status               ContentStatus        @default(DRAFT)
  version              Int                  @default(1)
  createdBy            String?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  // Action-specific fields
  skillId              String
  requiredLevel        Int                  @default(1) // Minimum skill level to unlock
  actionTimeSeconds    Int                  @default(3) // Time per action in seconds (Melvor-style)
  xpReward             Int                  @default(10) // XP granted per action completion
  successRate          Float                @default(1.0) // 0.0 to 1.0, default 100% success
  staminaCost          Int                  @default(0) // Optional stamina cost per action
  unlockConditionsJSON Json? // Additional unlock conditions (e.g., {"questId": "quest_1"})
  bonusEffectsJSON     Json? // Optional bonuses (e.g., {"speedModifier": 0.1})
  // Relations
  skill                TrainingSkill        @relation(fields: [skillId], references: [id], onDelete: Cascade)
  inputItems           SkillActionInput[]
  outputItems          SkillActionOutput[]
  activePlayers        PlayerActiveAction[]
  logs                 SkillActionLog[]

  @@index([skillId])
  @@index([requiredLevel])
  @@index([status])
  @@index([key])
  @@index([createdBy])
}

// Input items required for an action
model SkillActionInput {
  id        String      @id @default(cuid())
  actionId  String
  itemId    String
  quantity  Int         @default(1)
  createdAt DateTime    @default(now())
  action    SkillAction @relation(fields: [actionId], references: [id], onDelete: Cascade)
  item      Item        @relation("SkillActionInput", fields: [itemId], references: [id])

  @@index([actionId])
  @@index([itemId])
}

// Output items granted by an action
model SkillActionOutput {
  id          String      @id @default(cuid())
  actionId    String
  itemId      String
  minQuantity Int         @default(1)
  maxQuantity Int         @default(1)
  weight      Int         @default(100) // Weight for random selection (if multiple outputs)
  createdAt   DateTime    @default(now())
  action      SkillAction @relation(fields: [actionId], references: [id], onDelete: Cascade)
  item        Item        @relation("SkillActionOutput", fields: [itemId], references: [id])

  @@index([actionId])
  @@index([itemId])
}

// Player's progression in a training skill
model PlayerTrainingSkill {
  id        String        @id @default(cuid())
  playerId  String
  skillId   String
  level     Int           @default(1)
  xp        Int           @default(0) // Total XP accumulated (Melvor-style)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  player    Player        @relation(fields: [playerId], references: [id], onDelete: Cascade)
  skill     TrainingSkill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([playerId, skillId])
  @@index([playerId])
  @@index([skillId])
  @@index([playerId, level])
}

// Currently active training action (one per player)
model PlayerActiveAction {
  id               String      @id @default(cuid())
  playerId         String      @unique
  actionId         String
  startedAt        DateTime    @default(now())
  nextCompletionAt DateTime // When the next action completion should occur
  actionsCompleted Int         @default(0) // Counter for completed actions in this session
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  player           Player      @relation(fields: [playerId], references: [id], onDelete: Cascade)
  action           SkillAction @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([actionId])
  @@index([nextCompletionAt])
}

// Log of completed skill actions (for analytics, leaderboards, perma-death tracking)
model SkillActionLog {
  id                String      @id @default(cuid())
  playerId          String
  actionId          String
  skillId           String
  success           Boolean     @default(true)
  xpGained          Int         @default(0)
  itemsConsumedJSON Json? // Array of {itemId, quantity}
  itemsGainedJSON   Json? // Array of {itemId, quantity}
  createdAt         DateTime    @default(now())
  player            Player      @relation(fields: [playerId], references: [id], onDelete: Cascade)
  action            SkillAction @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@index([playerId, createdAt])
  @@index([actionId, createdAt])
  @@index([skillId, createdAt])
  @@index([playerId])
  @@index([actionId])
  @@index([skillId])
  @@index([createdAt])
}

// ============================================
// Global Chat System
// ============================================

model ChatMessage {
  id              String         @id @default(cuid())
  userId          String
  room            String         @default("global")
  content         String // Sanitized HTML content
  parentMessageId String? // For replies
  deletedAt       DateTime? // Soft delete for expired messages
  expiresAt       DateTime? // Auto-delete after 4 hours
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentMessage   ChatMessage?   @relation("MessageReplies", fields: [parentMessageId], references: [id], onDelete: Cascade)
  replies         ChatMessage[]  @relation("MessageReplies")
  reactions       ChatReaction[]
  mentions        ChatMention[]

  @@index([room, createdAt])
  @@index([userId])
  @@index([createdAt])
  @@index([parentMessageId])
  @@index([expiresAt])
  @@index([deletedAt])
}

model ChatReaction {
  id        String      @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime    @default(now())
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

model ChatMention {
  id                String      @id @default(cuid())
  messageId         String
  mentionedUserId   String
  mentionedByUserId String
  createdAt         DateTime    @default(now())
  message           ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  mentionedUser     User        @relation("MentionedUser", fields: [mentionedUserId], references: [id], onDelete: Cascade)
  mentionedByUser   User        @relation("MentionedBy", fields: [mentionedByUserId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([mentionedUserId])
  @@index([mentionedByUserId])
}

enum NotificationType {
  MENTION
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  dataJson  Json // Flexible JSON data for different notification types
  readAt    DateTime?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([createdAt])
}

// Content Panel Models (EnemyTemplate, DropTable, EncounterDefinition)
model EnemyTemplate {
  id          String           @id @default(cuid())
  name        String
  slug        String           @unique
  level       Int              @default(1)
  maxHp       Int
  attack      Int              @default(0)
  defense     Int              @default(0)
  xpReward    Int              @default(0)
  goldReward  Int              @default(0)
  dropTableId String?
  isArchived  Boolean          @default(false)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  dropTable   DropTable?       @relation(fields: [dropTableId], references: [id], onDelete: SetNull)
  encounters  EncounterEnemy[]

  @@index([slug])
  @@index([isArchived])
}

model DropTable {
  id         String           @id @default(cuid())
  name       String
  slug       String           @unique
  isArchived Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  entries    DropTableEntry[]
  enemies    EnemyTemplate[]

  @@index([slug])
  @@index([isArchived])
}

model DropTableEntry {
  id          String    @id @default(cuid())
  dropTableId String
  itemId      String
  weight      Int       @default(100)
  minQty      Int       @default(1)
  maxQty      Int       @default(1)
  createdAt   DateTime  @default(now())
  dropTable   DropTable @relation(fields: [dropTableId], references: [id], onDelete: Cascade)
  item        Item      @relation(fields: [itemId], references: [id])

  @@index([dropTableId])
  @@index([itemId])
}

model EncounterDefinition {
  id         String           @id @default(cuid())
  name       String
  slug       String           @unique
  status     ContentStatus    @default(DRAFT)
  zoneId     String?
  isArchived Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  enemies    EncounterEnemy[]
  mapTiles   MapVersionTile[]

  @@index([slug])
  @@index([isArchived])
  @@index([status])
}

model EncounterEnemy {
  id              String              @id @default(cuid())
  encounterId     String
  enemyTemplateId String
  weight          Int                 @default(100)
  createdAt       DateTime            @default(now())
  encounter       EncounterDefinition @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  enemyTemplate   EnemyTemplate       @relation(fields: [enemyTemplateId], references: [id], onDelete: Cascade)

  @@index([encounterId])
  @@index([enemyTemplateId])
}

// Stub models for versioned map system references
model ResourceNodeDefinition {
  id         String           @id @default(cuid())
  slug       String           @unique
  name       String
  status     ContentStatus    @default(DRAFT)
  isArchived Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  mapTiles   MapVersionTile[]

  @@index([slug])
  @@index([status])
  @@index([isArchived])
}

model QuestTrigger {
  id         String           @id @default(cuid())
  slug       String           @unique
  name       String
  status     ContentStatus    @default(DRAFT)
  isArchived Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  mapTiles   MapVersionTile[]

  @@index([slug])
  @@index([status])
  @@index([isArchived])
}

// Versioned Map System Models
model MapDefinition {
  id                  String       @id @default(cuid())
  name                String
  slug                String       @unique
  description         String?
  biome               String?
  recommendedMinLevel Int?
  recommendedMaxLevel Int?
  dangerRating        Int          @default(1)
  isArchived          Boolean      @default(false)
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  versions            MapVersion[]

  @@index([slug])
  @@index([isArchived])
}

model MapVersion {
  id              String           @id @default(cuid())
  mapId           String
  versionNumber   Int
  status          ContentStatus    @default(DRAFT)
  width           Int
  height          Int
  changeNotes     String?
  publishedAt     DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  map             MapDefinition    @relation(fields: [mapId], references: [id], onDelete: Cascade)
  tiles           MapVersionTile[]
  zones           MapZoneVersion[]
  pois            MapPOI[]
  poiDestinations MapPOI[]         @relation("MapPOIDestination")

  @@unique([mapId, versionNumber])
  @@index([mapId])
  @@index([status])
  @@index([mapId, status])
}

model MapVersionTile {
  id                    String                  @id @default(cuid())
  mapVersionId          String
  x                     Int
  y                     Int
  tileType              TileType                @default(PLAIN)
  overlay               TileOverlay             @default(NONE)
  isWalkable            Boolean                 @default(true)
  movementCost          Int                     @default(1)
  safeZone              Boolean                 @default(false)
  fogDiscoverable       Boolean                 @default(true)
  encounterDefinitionId String?
  resourceNodeId        String?
  questTriggerId        String?
  notes                 String?
  tagsJson              Json?
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  mapVersion            MapVersion              @relation(fields: [mapVersionId], references: [id], onDelete: Cascade)
  encounterDefinition   EncounterDefinition?    @relation(fields: [encounterDefinitionId], references: [id], onDelete: SetNull)
  resourceNode          ResourceNodeDefinition? @relation(fields: [resourceNodeId], references: [id], onDelete: SetNull)
  questTrigger          QuestTrigger?           @relation(fields: [questTriggerId], references: [id], onDelete: SetNull)

  @@unique([mapVersionId, x, y])
  @@index([mapVersionId])
  @@index([tileType])
  @@index([overlay])
}

model MapZoneVersion {
  id                           String     @id @default(cuid())
  mapVersionId                 String
  name                         String
  slug                         String
  minX                         Int
  minY                         Int
  maxX                         Int
  maxY                         Int
  recommendedMinLevel          Int?
  recommendedMaxLevel          Int?
  dangerRating                 Int?
  defaultEncounterDefinitionId String?
  defaultResourceNodeId        String?
  createdAt                    DateTime   @default(now())
  updatedAt                    DateTime   @updatedAt
  mapVersion                   MapVersion @relation(fields: [mapVersionId], references: [id], onDelete: Cascade)

  @@index([mapVersionId])
  @@index([mapVersionId, slug])
}

model MapPOI {
  id                      String      @id @default(cuid())
  mapVersionId            String
  type                    POIType
  name                    String
  x                       Int
  y                       Int
  icon                    String?
  destinationMapVersionId String?
  destinationX            Int?
  destinationY            Int?
  notes                   String?
  createdAt               DateTime    @default(now())
  updatedAt               DateTime    @updatedAt
  mapVersion              MapVersion  @relation(fields: [mapVersionId], references: [id], onDelete: Cascade)
  destinationMapVersion   MapVersion? @relation("MapPOIDestination", fields: [destinationMapVersionId], references: [id], onDelete: SetNull)

  @@index([mapVersionId])
  @@index([mapVersionId, x, y])
}
