generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Post {
  id          Int      @id @default(autoincrement())
  name        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([name])
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                    String              @id @default(cuid())
  name                  String?
  email                 String              @unique
  emailVerified         DateTime?
  image                 String?
  password              String
  gender                String
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  username              String              @unique
  // Account-level flags (banned, admin, tester can be added here)
  accounts              Account[]
  characters            Character[]
  player                Player?
  posts                 Post[]
  sessions              Session[]
  profile               PlayerProfile?
  // Note: Battle moved to playerId - battles are character-specific, not account-level
  bankTransactionsFrom  BankTransaction[]   @relation("BankTransactionFrom")
  bankTransactionsTo    BankTransaction[]   @relation("BankTransactionTo")
  // Leaderboard stats are account-level aggregations (okay to keep on User)
  leaderboardStats      PlayerLeaderboardStats?
  statsPeriods          PlayerStatsPeriod[]
}

model Character {
  id             String    @id @default(cuid())
  userId         String
  name           String
  level          Int       @default(1)
  vitality       Int       @default(5)
  strength       Int       @default(5)
  speed          Int       @default(5)
  dexterity      Int       @default(5)
  maxStamina     Int
  currentStamina Int
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  currentHp      Int
  deaths         Int       @default(0)
  floor          Int       @default(1)
  gender         String
  location       String    @default("Town Square")
  maxHp          Int
  deathAt        DateTime?
  deathReason    String?
  position       Position? // World map position
  user           User      @relation(fields: [userId], references: [id])
}

// Simple position model for character world map tracking
// Separate from MapPosition which is more complex (tile-based)
model Position {
  id          String    @id @default(cuid())
  characterId String    @unique
  x           Int
  y           Int
  zone        String    // Zone name/identifier
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@index([x, y])
  @@index([zone])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Player {
  id                         String              @id @default(cuid())
  userId                     String              @unique
  characterName              String              @unique
  level                      Int                 @default(1)
  experience                 Int                 @default(0)
  gold                       Int                 @default(0)
  deathCount                 Int                 @default(0)
  isDeleted                  Boolean             @default(false)
  createdAt                  DateTime            @default(now())
  updatedAt                  DateTime            @updatedAt
  bankAccount                BankAccount?
  battles                    Battle[]           // Character-specific battles
  combatLogs                 CombatLog[]
  deathLogs                  DeathLog[]
  equipment                  Equipment?
  guildMember                GuildMember?
  inventory                  InventoryItem[]
  position                   MapPosition?
  marketListings             MarketListing[]
  marketTransactionsAsBuyer  MarketTransaction[] @relation("Buyer")
  marketTransactionsAsSeller MarketTransaction[] @relation("Seller")
  occupation                 Occupation?
  user                       User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  skills                     PlayerSkill[]
  skillLoadout               PlayerSkillLoadout?
  stats                      PlayerStats?
  userJobs                   UserJob[]
  craftAttempts              CraftAttempt[]
  gatherAttempts             GatherAttempt[]

  @@index([characterName])
  @@index([userId])
}

model PlayerStats {
  id             String   @id @default(cuid())
  playerId       String   @unique
  // Base stats (permanent, from level-ups and base character)
  vitalityBase   Int      @default(10)
  strengthBase   Int      @default(10)
  speedBase      Int      @default(10)
  dexterityBase  Int      @default(10)
  // Trained stats (from training, can decay, soft caps apply)
  vitalityTrain  Int      @default(0)
  strengthTrain  Int      @default(0)
  speedTrain     Int      @default(0)
  dexterityTrain Int      @default(0)
  // Computed totals (base + trained) - can be calculated or stored for performance
  vitality       Int      @default(10)
  strength       Int      @default(10)
  speed          Int      @default(10)
  dexterity      Int      @default(10)
  // HP/SP
  maxHP          Int      @default(100)
  currentHP      Int      @default(100)
  maxSP          Int      @default(50)
  currentSP      Int      @default(50)
  statPoints     Int      @default(0)
  hpRegenPerMin  Int      @default(100)
  spRegenPerMin  Int      @default(100)
  lastRegenAt    DateTime @default(now())
  updatedAt      DateTime @updatedAt
  player         Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model World {
  id        String        @id @default(cuid())
  name      String
  width     Int
  height    Int
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  tiles     MapTile[]
  positions MapPosition[]

  @@index([name])
}

model MapTile {
  id           Int           @id @default(autoincrement())
  worldId      String
  x            Int
  y            Int
  tileType     TileType
  zoneType     ZoneType
  isSafeZone   Boolean       @default(false)
  hasResource  Boolean       @default(false)
  resourceType ResourceType?
  description  String?
  meta         Json?         // JSON for additional tile metadata
  encounters   Encounter[]
  positions    MapPosition[]
  npcs         NPC[]
  world        World         @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@unique([worldId, x, y])
  @@index([worldId, x, y])
  @@index([tileType])
  @@index([zoneType])
  @@index([worldId])
}

model MapPosition {
  id        String   @id @default(cuid())
  playerId  String   @unique
  worldId   String
  tileX     Int
  tileY     Int
  tileId    Int?
  updatedAt DateTime @updatedAt
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tile      MapTile? @relation(fields: [tileId], references: [id])
  world     World    @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@index([tileX, tileY])
  @@index([worldId])
}

model NPC {
  id        String     @id @default(cuid())
  name      String
  npcType   NPCType
  tileX     Int
  tileY     Int
  tileId    Int?
  dialogue  String?
  createdAt DateTime   @default(now())
  tile      MapTile?   @relation(fields: [tileId], references: [id])
  quests    Quest[]
  shopItems ShopItem[]

  @@index([tileX, tileY])
  @@index([npcType])
  @@index([tileId])
}

model ShopItem {
  id        String   @id @default(cuid())
  npcId     String
  itemId    String
  price     Int
  stock     Int?
  createdAt DateTime @default(now())
  item      Item     @relation(fields: [itemId], references: [id])
  npc       NPC      @relation(fields: [npcId], references: [id], onDelete: Cascade)
}

model Item {
  id                   String              @id @default(cuid())
  key                  String?              @unique
  name                 String
  description          String?
  itemType             ItemType
  itemRarity           ItemRarity
  tier                 Int                 @default(1)
  value                Int
  stackable            Boolean             @default(false)
  maxStack             Int                 @default(1)
  equipmentSlot        EquipmentSlot?
  vitalityBonus        Int                 @default(0)
  strengthBonus        Int                 @default(0)
  speedBonus           Int                 @default(0)
  dexterityBonus       Int                 @default(0)
  hpBonus              Int                 @default(0)
  spBonus              Int                 @default(0)
  createdAt            DateTime            @default(now())
  bankVaultItems       BankVaultItem[]
  equippedAsHead       Equipment[]         @relation("Head")
  equippedAsLeftArm   Equipment[]         @relation("LeftArm")
  equippedAsRightArm  Equipment[]         @relation("RightArm")
  equippedAsBody      Equipment[]         @relation("Body")
  equippedAsLegs      Equipment[]         @relation("Legs")
  equippedAsFeet       Equipment[]         @relation("Feet")
  equippedAsRing1      Equipment[]         @relation("Ring1")
  equippedAsRing2     Equipment[]         @relation("Ring2")
  equippedAsRing3      Equipment[]         @relation("Ring3")
  equippedAsNecklace   Equipment[]         @relation("Necklace")
  equippedAsBelt       Equipment[]         @relation("Belt")
  equippedAsCloak      Equipment[]         @relation("Cloak")
  inventoryItems       InventoryItem[]
  marketListings       MarketListing[]
  marketTransactions   MarketTransaction[]
  shopItems            ShopItem[]
  recipeOutputs        Recipe[]            @relation("RecipeOutput")
  recipeInputs         RecipeInput[]       @relation("RecipeInput")
  nodeYields           NodeYield[]         @relation("NodeYield")

  @@index([itemType])
  @@index([itemRarity])
  @@index([tier])
}

model InventoryItem {
  id        String   @id @default(cuid())
  playerId  String
  itemId    String
  quantity  Int      @default(1) // Must be >= 0, enforced at application level
  createdAt DateTime @default(now())
  item      Item     @relation(fields: [itemId], references: [id])
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([playerId, itemId])
  @@index([playerId])
  @@index([itemId])
  // Note: Stack safety enforced in application logic (quantity >= 0, quantity <= item.maxStack if stackable)
}

model Equipment {
  id            String   @id @default(cuid())
  playerId      String   @unique
  headItemId    String?
  leftArmItemId String?
  rightArmItemId String?
  bodyItemId    String?
  legsItemId    String?
  feetItemId    String?
  ring1ItemId   String?
  ring2ItemId   String?
  ring3ItemId   String?
  necklaceItemId String?
  beltItemId    String?
  cloakItemId   String?
  updatedAt     DateTime @updatedAt
  head          Item?    @relation("Head", fields: [headItemId], references: [id])
  leftArm       Item?    @relation("LeftArm", fields: [leftArmItemId], references: [id])
  rightArm      Item?    @relation("RightArm", fields: [rightArmItemId], references: [id])
  body          Item?    @relation("Body", fields: [bodyItemId], references: [id])
  legs          Item?    @relation("Legs", fields: [legsItemId], references: [id])
  feet          Item?    @relation("Feet", fields: [feetItemId], references: [id])
  ring1         Item?    @relation("Ring1", fields: [ring1ItemId], references: [id])
  ring2         Item?    @relation("Ring2", fields: [ring2ItemId], references: [id])
  ring3         Item?    @relation("Ring3", fields: [ring3ItemId], references: [id])
  necklace      Item?    @relation("Necklace", fields: [necklaceItemId], references: [id])
  belt          Item?    @relation("Belt", fields: [beltItemId], references: [id])
  cloak         Item?    @relation("Cloak", fields: [cloakItemId], references: [id])
  player        Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model Occupation {
  id           String               @id @default(cuid())
  playerId     String               @unique
  primaryJob   PrimaryOccupation?
  secondaryJob SecondaryOccupation?
  level        Int                  @default(1)
  experience   Int                  @default(0)
  updatedAt    DateTime             @updatedAt
  player       Player               @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model Skill {
  id            String   @id @default(cuid())
  key           String   @unique
  name          String
  description   String?
  staminaCost   Int      @default(0)
  cooldownSeconds Int    @default(0)
  tags          String?  // JSON array placeholder
  jobUnlock     String?  // Job key that unlocks this skill
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  playerSkills  PlayerSkill[]
  slot1Loadouts PlayerSkillLoadout[] @relation("Slot1")
  slot2Loadouts PlayerSkillLoadout[] @relation("Slot2")
  slot3Loadouts PlayerSkillLoadout[] @relation("Slot3")
  slot4Loadouts PlayerSkillLoadout[] @relation("Slot4")
  slot5Loadouts PlayerSkillLoadout[] @relation("Slot5")
  slot6Loadouts PlayerSkillLoadout[] @relation("Slot6")
  slot7Loadouts PlayerSkillLoadout[] @relation("Slot7")
  slot8Loadouts PlayerSkillLoadout[] @relation("Slot8")

  @@index([key])
}

model PlayerSkill {
  id         String   @id @default(cuid())
  playerId   String
  skillId    String
  learnedAt  DateTime @default(now())
  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  skill      Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([playerId, skillId])
  @@index([playerId])
  @@index([skillId])
}

model PlayerSkillLoadout {
  id         String   @id @default(cuid())
  playerId   String   @unique
  slot1SkillId String?
  slot2SkillId String?
  slot3SkillId String?
  slot4SkillId String?
  slot5SkillId String?
  slot6SkillId String?
  slot7SkillId String?
  slot8SkillId String?
  updatedAt  DateTime @updatedAt
  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  slot1Skill Skill?   @relation("Slot1", fields: [slot1SkillId], references: [id])
  slot2Skill Skill?   @relation("Slot2", fields: [slot2SkillId], references: [id])
  slot3Skill Skill?   @relation("Slot3", fields: [slot3SkillId], references: [id])
  slot4Skill Skill?   @relation("Slot4", fields: [slot4SkillId], references: [id])
  slot5Skill Skill?   @relation("Slot5", fields: [slot5SkillId], references: [id])
  slot6Skill Skill?   @relation("Slot6", fields: [slot6SkillId], references: [id])
  slot7Skill Skill?   @relation("Slot7", fields: [slot7SkillId], references: [id])
  slot8Skill Skill?   @relation("Slot8", fields: [slot8SkillId], references: [id])

  @@index([playerId])
}

model Encounter {
  id         String      @id @default(cuid())
  tileX      Int
  tileY      Int
  tileId     Int?
  enemyType  String
  enemyLevel Int
  isActive   Boolean     @default(true)
  createdAt  DateTime    @default(now())
  combatLogs CombatLog[]
  tile       MapTile?    @relation(fields: [tileId], references: [id])

  @@index([tileX, tileY])
  @@index([tileId])
  @@index([isActive])
}

model CombatLog {
  id          String     @id @default(cuid())
  playerId    String
  encounterId String?
  turnNumber  Int
  action      String
  result      String
  createdAt   DateTime   @default(now())
  encounter   Encounter? @relation(fields: [encounterId], references: [id])
  player      Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([encounterId])
}

model DeathLog {
  id          String   @id @default(cuid())
  playerId    String   // Character/Player ID (character-specific death tracking)
  cause       String   // Cause of death (required for permadeath integrity)
  location    String?  // Location/zone where death occurred
  locationX   Int?     // X coordinate if applicable
  locationY   Int?     // Y coordinate if applicable
  createdAt   DateTime @default(now())
  player      Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([createdAt])
}

model DeathRecord {
  id            String   @id @default(cuid())
  characterName String
  userId        String?
  floorReached  Int
  causeOfDeath  String
  deathsUsed    Int
  createdAt     DateTime @default(now())
}

model Guild {
  id          String        @id @default(cuid())
  name        String        @unique
  description String?
  level       Int           @default(1)
  gold        Int           @default(0)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  bank        GuildBank?
  members     GuildMember[]
  quests      GuildQuest[]

  @@index([name])
}

model GuildMember {
  id       String    @id @default(cuid())
  playerId String    @unique
  guildId  String
  role     GuildRole @default(MEMBER)
  joinedAt DateTime  @default(now())
  guild    Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  player   Player    @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([guildId])
}

model GuildBank {
  id        String   @id @default(cuid())
  guildId   String   @unique
  gold      Int      @default(0)
  updatedAt DateTime @updatedAt
  guild     Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
}

model GuildQuest {
  id          String   @id @default(cuid())
  guildId     String
  title       String
  description String
  reward      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  guild       Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId])
  @@index([isActive])
}

model BankAccount {
  id                  String            @id @default(cuid())
  playerId            String            @unique
  balanceCoins        Int               @default(0)
  lastInterestClaimedAt DateTime?       // When user manually claimed interest
  lastInterestApplied DateTime?         // When automatic interest was last applied (audit safety)
  vaultLevel          Int               @default(1)
  updatedAt           DateTime          @updatedAt
  player              Player            @relation(fields: [playerId], references: [id], onDelete: Cascade)
  vaultItems          BankVaultItem[]
  transactions        BankTransaction[]
}

model BankVaultItem {
  id        String      @id @default(cuid())
  accountId String
  itemId    String
  quantity  Int         @default(1)
  createdAt DateTime    @default(now())
  account   BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  item      Item        @relation(fields: [itemId], references: [id])

  @@index([accountId])
  @@index([itemId])
}

model BankTransaction {
  id        String            @id @default(cuid())
  type      BankTransactionType
  amountCoins Int
  fromUserId String?
  toUserId   String?
  note       String?
  accountId  String?
  createdAt  DateTime         @default(now())
  account    BankAccount?      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  fromUser   User?             @relation("BankTransactionFrom", fields: [fromUserId], references: [id])
  toUser     User?             @relation("BankTransactionTo", fields: [toUserId], references: [id])

  @@index([fromUserId])
  @@index([toUserId])
  @@index([accountId])
  @@index([createdAt])
}

enum BankTransactionType {
  TRANSFER
  DEPOSIT
  WITHDRAW
  INTEREST
}

model MarketListing {
  id           String              @id @default(cuid())
  playerId     String
  itemId       String
  quantity     Int
  pricePerUnit Int
  totalPrice   Int
  listingTax   Int
  isActive     Boolean             @default(true)
  expiresAt    DateTime?
  createdAt    DateTime            @default(now())
  soldAt       DateTime?
  item         Item                @relation(fields: [itemId], references: [id])
  player       Player              @relation(fields: [playerId], references: [id], onDelete: Cascade)
  transactions MarketTransaction[]

  @@index([playerId])
  @@index([itemId])
  @@index([isActive])
  @@index([expiresAt])
}

model MarketTransaction {
  id         String        @id @default(cuid())
  listingId  String
  buyerId    String
  sellerId   String
  itemId     String
  quantity   Int
  totalPrice Int
  createdAt  DateTime      @default(now())
  buyer      Player        @relation("Buyer", fields: [buyerId], references: [id], onDelete: Cascade)
  item       Item          @relation(fields: [itemId], references: [id])
  listing    MarketListing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  seller     Player        @relation("Seller", fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([buyerId])
  @@index([sellerId])
  @@index([listingId])
  @@index([itemId])
}

model Quest {
  id           String    @id @default(cuid())
  npcId        String?
  title        String
  description  String
  questType    QuestType
  reward       String?
  requirements String?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  npc          NPC?      @relation(fields: [npcId], references: [id])

  @@index([npcId])
  @@index([isActive])
  @@index([questType])
}

enum TileType {
  GRASS
  FOREST
  MOUNTAIN
  RIVER
  DESERT
  DUNGEON
  TOWN
  SHRINE
  ROAD
  PLAIN
  WATER
}

enum ZoneType {
  SAFE
  LOW_DANGER
  MEDIUM_DANGER
  HIGH_DANGER
  EXTREME_DANGER
}

enum ResourceType {
  ORE
  HERB
  FISH
  WOOD
  RARE_ITEM
}

enum NPCType {
  MERCHANT
  QUEST_GIVER
  TRAINER
  BANKER
  GUILD_MASTER
  GUARD
  TAVERN_KEEPER
}

enum ItemType {
  WEAPON
  ARMOR
  ACCESSORY
  CONSUMABLE
  MATERIAL
  QUEST_ITEM
  TOOL
  EQUIPMENT
}

enum ItemRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum EquipmentSlot {
  HEAD
  LEFT_ARM
  RIGHT_ARM
  BODY
  LEGS
  FEET
  RING
  NECKLACE
  BELT
  CLOAK
}

enum PrimaryOccupation {
  BLACKSMITH
  ALCHEMIST
  COOK
  TAILOR
  MERCHANT
  BEAST_HANDLER
}

enum SecondaryOccupation {
  MINER
  HERBALIST
  FISHER
  LOGGER
  FORAGER
}

enum GuildRole {
  LEADER
  OFFICER
  MEMBER
}

enum QuestType {
  KILL
  GATHER
  DELIVER
  EXPLORE
  CRAFT
}

enum JobCategory {
  CRAFT
  GATHER
}

model Job {
  id          String        @id @default(cuid())
  key         String        @unique
  name        String
  description String?
  category    JobCategory
  icon        String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  userJobs    UserJob[]
  recipes     Recipe[]
  nodes       GatheringNode[]

  @@index([category])
  @@index([key])
}

model UserJob {
  id          String   @id @default(cuid())
  playerId    String
  jobId       String
  level       Int      @default(1)
  xp          Int      @default(0)
  active      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  player      Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([playerId, jobId])
  @@index([playerId])
  @@index([jobId])
}

model Recipe {
  id            String        @id @default(cuid())
  jobId         String
  name          String
  description   String?
  difficulty    Int           @default(1)
  outputItemId  String
  outputQty     Int           @default(1)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  job           Job           @relation(fields: [jobId], references: [id], onDelete: Cascade)
  outputItem    Item          @relation("RecipeOutput", fields: [outputItemId], references: [id])
  inputs        RecipeInput[]
  craftAttempts CraftAttempt[]

  @@index([jobId])
  @@index([outputItemId])
}

model RecipeInput {
  id        String   @id @default(cuid())
  recipeId  String
  itemId    String
  qty       Int      @default(1)
  createdAt DateTime @default(now())
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  item      Item     @relation("RecipeInput", fields: [itemId], references: [id])

  @@index([recipeId])
  @@index([itemId])
}

model CraftAttempt {
  id         String   @id @default(cuid())
  playerId   String
  recipeId   String
  success    Boolean
  xpGained   Int
  createdAt  DateTime @default(now())
  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@index([playerId, createdAt])
  @@index([recipeId, createdAt])
  @@index([playerId])
  @@index([recipeId])
  @@index([createdAt])
}

model GatheringNode {
  id          String        @id @default(cuid())
  key         String        @unique
  name        String
  jobId       String
  dangerTier  Int           @default(1)
  description String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  job         Job           @relation(fields: [jobId], references: [id], onDelete: Cascade)
  yields      NodeYield[]
  gatherAttempts GatherAttempt[]

  @@index([jobId])
  @@index([key])
}

model NodeYield {
  id          String        @id @default(cuid())
  nodeId      String
  itemId      String
  minQty      Int           @default(1)
  maxQty      Int           @default(1)
  weight      Int           @default(100)
  createdAt   DateTime      @default(now())
  node        GatheringNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  item        Item          @relation("NodeYield", fields: [itemId], references: [id])

  @@index([nodeId])
  @@index([itemId])
}

model GatherAttempt {
  id         String        @id @default(cuid())
  playerId   String
  nodeId     String
  success    Boolean
  xpGained   Int
  createdAt  DateTime      @default(now())
  player     Player        @relation(fields: [playerId], references: [id], onDelete: Cascade)
  node       GatheringNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  @@index([playerId, createdAt])
  @@index([nodeId, createdAt])
  @@index([playerId])
  @@index([nodeId])
  @@index([createdAt])
}

model PlayerProfile {
  id            String           @id @default(cuid())
  userId        String           @unique
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  profileStats  PlayerProfileStats?
  pvpRecord     PlayerPvpRecord?
  pveRecord     PlayerPveRecord?
  social        PlayerSocial?
  achievements  PlayerAchievement[]

  @@index([userId])
}

model PlayerProfileStats {
  id         String        @id @default(cuid())
  profileId  String        @unique
  vitality   Int           @default(10)
  strength   Int           @default(10)
  speed      Int           @default(10)
  dexterity  Int           @default(10)
  updatedAt  DateTime      @updatedAt
  profile    PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model PlayerPvpRecord {
  id                 String        @id @default(cuid())
  profileId          String        @unique
  wins               Int           @default(0)
  losses             Int           @default(0)
  pvpWinStreakCurrent Int          @default(0)
  pvpWinStreakBest    Int          @default(0)
  updatedAt          DateTime      @updatedAt
  profile            PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model PlayerPveRecord {
  id           String        @id @default(cuid())
  profileId    String        @unique
  totalKills   Int           @default(0)
  bossesSlain  Int           @default(0)
  deathsUsed   Int           @default(0)
  deathsLimit  Int           @default(5)
  updatedAt    DateTime      @updatedAt
  profile      PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

model Achievement {
  id          String             @id @default(cuid())
  key         String             @unique
  name        String
  description String?
  icon        String?
  rarity      AchievementRarity @default(COMMON)
  createdAt   DateTime           @default(now())
  players     PlayerAchievement[]

  @@index([key])
}

model PlayerAchievement {
  id            String       @id @default(cuid())
  profileId     String
  achievementId String
  unlockedAt    DateTime     @default(now())
  profile       PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  achievement   Achievement  @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([profileId, achievementId])
  @@index([profileId])
  @@index([achievementId])
}

model PlayerSocial {
  id                String        @id @default(cuid())
  profileId         String        @unique
  guildName         String?
  title             String?
  tagline           String?
  commendationsHelpful Int        @default(0)
  commendationsSkilled Int        @default(0)
  commendationsStrategic Int      @default(0)
  friendsCount      Int           @default(0)
  guildRole         String?
  updatedAt         DateTime      @updatedAt
  profile           PlayerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
}

enum AchievementRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum BattleStatus {
  ACTIVE
  WON
  LOST
  FLED
}

model Monster {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String
  level       Int      @default(1)
  vitality    Int
  strength    Int
  speed       Int
  dexterity   Int
  maxHp       Int
  xpReward    Int      @default(0)
  goldReward  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  battles     Battle[]

  @@index([level])
  @@index([key])
}

model Battle {
  id          String      @id @default(cuid())
  playerId    String      // Changed from userId - battles are character-specific, not account-level
  monsterId   String
  status      BattleStatus @default(ACTIVE)
  turnNumber  Int         @default(1)
  playerHp    Int
  playerSp    Int
  monsterHp   Int
  log         Json        @default("[]")
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  player      Player      @relation(fields: [playerId], references: [id], onDelete: Cascade)
  monster     Monster     @relation(fields: [monsterId], references: [id])

  @@index([playerId])
  @@index([status])
  @@index([playerId, status])
}

model PlayerLeaderboardStats {
  userId      String   @id
  pveKills    Int      @default(0)
  pvpKills    Int      @default(0)
  pvpWins     Int      @default(0)
  pvpLosses   Int      @default(0)
  jobXpTotal  Int      @default(0)
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([pveKills])
  @@index([pvpKills])
  @@index([jobXpTotal])
}

model PlayerStatsPeriod {
  id          String   @id @default(cuid())
  userId      String
  periodType  String   // "daily" | "weekly"
  periodStart DateTime
  pveKills    Int      @default(0)
  pvpKills    Int      @default(0)
  pvpWins     Int      @default(0)
  pvpLosses   Int      @default(0)
  jobXpTotal  Int      @default(0)
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, periodType, periodStart])
  @@index([periodType, periodStart])
  @@index([userId, periodType, periodStart])
}
